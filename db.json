{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/gallery/code-highlight.png","path":"gallery/code-highlight.png","modified":0,"renderable":0},{"_id":"source/gallery/little-girl.jpg","path":"gallery/little-girl.jpg","modified":0,"renderable":0},{"_id":"source/gallery/music1.jpg","path":"gallery/music1.jpg","modified":0,"renderable":0},{"_id":"source/gallery/music2.jpg","path":"gallery/music2.jpg","modified":0,"renderable":0},{"_id":"source/gallery/niagara.jpg","path":"gallery/niagara.jpg","modified":0,"renderable":0},{"_id":"source/gallery/smartphone.jpg","path":"gallery/smartphone.jpg","modified":0,"renderable":0},{"_id":"source/gallery/markdown.jpg","path":"gallery/markdown.jpg","modified":0,"renderable":0},{"_id":"source/gallery/guitarist.jpg","path":"gallery/guitarist.jpg","modified":0,"renderable":0},{"_id":"source/gallery/salt-lake.jpg","path":"gallery/salt-lake.jpg","modified":0,"renderable":0},{"_id":"themes/hiker/source/css/archive.css","path":"css/archive.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/header-post.css","path":"css/header-post.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/home.css","path":"css/home.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/vdonate.css","path":"css/vdonate.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/dialog.css","path":"css/dialog.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/home.js","path":"js/home.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/dialog.js","path":"js/dialog.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/preview/browser-support.png","path":"preview/browser-support.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/scripts.js","path":"js/scripts.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/preview/donation-btn.png","path":"preview/donation-btn.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/preview/theme-color.png","path":"preview/theme-color.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/vdonate.js","path":"js/vdonate.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/jquery-3.1.1.min.js","path":"js/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/mylogo1.jpg","path":"css/images/mylogo1.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/homelogo.jpg","path":"css/images/homelogo.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"source/gallery/shoes.jpg","path":"gallery/shoes.jpg","modified":0,"renderable":0},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/d3.min.js","path":"js/d3.min.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/sample.jpg","path":"css/images/sample.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/mylogo.jpg","path":"css/images/mylogo.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/preview/preview-mobile.png","path":"preview/preview-mobile.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/pose.jpg","path":"css/images/pose.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/home-bg.jpg","path":"css/images/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/home-bg2.jpg","path":"css/images/home-bg2.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/preview/code-theme.jpg","path":"preview/code-theme.jpg","modified":0,"renderable":1},{"_id":"source/images/线性代数应该这样学1.jpg","path":"images/线性代数应该这样学1.jpg","modified":0,"renderable":0},{"_id":"themes/hiker/source/preview/preview-pc.png","path":"preview/preview-pc.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hiker/.travis.yml","hash":"24851843a40973daaee47b2697e8b0dc4e6556b3","modified":1502121404135},{"_id":"themes/hiker/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1502121404164},{"_id":"themes/hiker/LICENSE","hash":"4ea4173f28adf2f688a59e3c5e6fa833bcdf7ced","modified":1502121404191},{"_id":"themes/hiker/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1502121404111},{"_id":"themes/hiker/_config.yml","hash":"e6b234fd6f1af4d16f9cf62eee251bfa999802b0","modified":1505831910957},{"_id":"themes/hiker/README.cn.md","hash":"2a5e5b98ba2f09dddc752f51ec2ba99664d163ed","modified":1502121404213},{"_id":"themes/hiker/package-lock.json","hash":"c59e59b6569718588066315a44bb5b01f09dc4a0","modified":1517988542570},{"_id":"themes/hiker/README.md","hash":"5a4a695b827c24c444ae044db141e01280eea0ca","modified":1502121404233},{"_id":"themes/hiker/package.json","hash":"ac7430d36de467f41a686fb716c8538c52f0e206","modified":1502168863342},{"_id":"source/_posts/2018学习和复习.md","hash":"dc96acccb4170c43bfbefd4c370e653a045582e4","modified":1521547581951},{"_id":"source/_posts/2018新年与考研.md","hash":"84f8bd9541eb3c8b743153ac43ab24496688437f","modified":1520404392338},{"_id":"source/_posts/2017-11-5.md","hash":"d3ced31910bf5f9230a0eb19b5704f928725e7b7","modified":1509889484010},{"_id":"source/about/index.md","hash":"96e6c2d51b05783718a9f4f9decdc3af7ff922ef","modified":1502162029514},{"_id":"source/_posts/IEEE802.11无线LANs概述.md","hash":"3eb11cdd32772a5553919120e3df7e7505bc2401","modified":1514720100116},{"_id":"source/archives/index.md","hash":"2ceff6070662cf6f1fbdaca7f560af5f9e9aa689","modified":1502162020729},{"_id":"source/_posts/Install-MySQL5-7.md","hash":"26f6e50536f12bfed3d6887024620fbaa0895da2","modified":1508996221302},{"_id":"source/_posts/k-means.md","hash":"4252c0ff4fefcd175845022a10332e46c4df3e7d","modified":1505833198696},{"_id":"source/_posts/JS函数式编程笔记2.md","hash":"f8e309d58e6581f9944c0ca4c9e7cc250b4f3acd","modified":1517999310549},{"_id":"source/_posts/VAET阅读稿.md","hash":"f1cad7dad2cd3ab841ba5c7539bb94afc060e952","modified":1507882436481},{"_id":"source/_posts/JS函数式编程笔记1.md","hash":"298e3b1ee0cc47f4acd9782135a453a88bab26aa","modified":1514720247419},{"_id":"source/_posts/关于未来方向学习的思考.md","hash":"6982f872ca2bd3486ecfe99987915113a56ce8f6","modified":1506252864519},{"_id":"source/_posts/人工智能发展报告.md","hash":"82dd63b16a1a45168c9d00ab2c728c9010e7f220","modified":1506252822785},{"_id":"source/_posts/从《线性代数应该这样学》到《Redis的设计与实现》.md","hash":"6d865cdc8a7831d7584f00bf91967f28ecdfc418","modified":1506252854204},{"_id":"source/_posts/最近一周总结.md","hash":"1790e33193d0ec4cf78dabb35ac5e0bd24f5515a","modified":1506252884874},{"_id":"source/_posts/机器学习里的一些小概念.md","hash":"15e2caaf5ddc29e3c70aba6d6627f0eb0eea1512","modified":1505833213982},{"_id":"source/_posts/《Web API的设计与开发》读书笔记.md","hash":"8d8bccb0adc15d24fc4bad3772dc07fce9aee615","modified":1505833186213},{"_id":"source/_posts/暑假机器学习总结.md","hash":"a2b0ce0452827fb4c84d9ea607e674d276e5db4d","modified":1506252871239},{"_id":"source/_posts/欢迎，刚搭建好的博客.md","hash":"a3252f09181a3739add81b483ab54d9486a5331d","modified":1508837204991},{"_id":"source/_posts/计算机网络实验.md","hash":"19f1bfc847a495275d97bdee91b8cfc6a6452d61","modified":1512897472896},{"_id":"source/_posts/计算机系统结构.md","hash":"8683a53b94608ee160b51442f31f5d9a604fffc2","modified":1511165895382},{"_id":"source/categories/index.md","hash":"5fca52c6be1c7641676abe5daa5a17cf07d5d1f8","modified":1502162840355},{"_id":"source/gallery/code-highlight.png","hash":"80e0318ffb139ffb0d960ed10613161854c65aa5","modified":1502123876376},{"_id":"source/gallery/little-girl.jpg","hash":"d73f0122778c1625a141f2537759e80a23ea3f84","modified":1502123876427},{"_id":"source/tags/index.md","hash":"5ca71bf5f75554913ceb111c0012ae8d5288bd29","modified":1502162048256},{"_id":"source/gallery/music1.jpg","hash":"b1e26e83b9d038e91c27f436997fc697b1680856","modified":1502123876464},{"_id":"source/gallery/music2.jpg","hash":"33d498bbad9a3350f35fc2df7207936bd0f8bf49","modified":1502123876482},{"_id":"source/gallery/niagara.jpg","hash":"ef5ed9bcc839cfdabaa596086fbbc89dc2337684","modified":1502123876497},{"_id":"source/gallery/smartphone.jpg","hash":"d03ea985e9550dcdc7a2729f975f82baeedf99bd","modified":1502123876555},{"_id":"themes/hiker/languages/de.yml","hash":"3e244f9c48b641edd821bdeb743bdbcd0919685f","modified":1502121404289},{"_id":"themes/hiker/languages/en.yml","hash":"22ab885c29bf8812d799df29211346783a39d278","modified":1502121404322},{"_id":"themes/hiker/languages/default.yml","hash":"22ab885c29bf8812d799df29211346783a39d278","modified":1502121404308},{"_id":"themes/hiker/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1502121404342},{"_id":"themes/hiker/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1502121404375},{"_id":"themes/hiker/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1502121404359},{"_id":"themes/hiker/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1502121404429},{"_id":"themes/hiker/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1502121404392},{"_id":"themes/hiker/languages/zh-CN.yml","hash":"2f0bcf559dd78025679872511adfcf40e85e9ff5","modified":1502121404448},{"_id":"themes/hiker/languages/pt.yml","hash":"46bd5f121f4704e2cd6c0950ec18b549f03bfe5c","modified":1502121404408},{"_id":"themes/hiker/languages/zh-TW.yml","hash":"7672fbe7ee9c166f77bc644647295f5886cbc50e","modified":1502121404465},{"_id":"themes/hiker/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1502121404595},{"_id":"themes/hiker/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1502121404616},{"_id":"themes/hiker/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502121404722},{"_id":"themes/hiker/layout/categories.ejs","hash":"ac33c728b49863d3ca961547d33209618f591e4f","modified":1502121404574},{"_id":"themes/hiker/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1502121404705},{"_id":"themes/hiker/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1502121404742},{"_id":"themes/hiker/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1502121406457},{"_id":"themes/hiker/layout/tags.ejs","hash":"340ded907f5f52ef73c50bb9f1f27bf2f5de3fa7","modified":1502121404783},{"_id":"source/gallery/markdown.jpg","hash":"5f2921d97b4c68ec029cbaea17bdc106108cd857","modified":1502123876442},{"_id":"themes/hiker/node_modules/exit/.npmignore","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1379691245000},{"_id":"themes/hiker/node_modules/findup-sync/.npmignore","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1351803462000},{"_id":"themes/hiker/layout/archive.ejs","hash":"877ed5677c6fc12a3050843dd3d97cb6b53caceb","modified":1502121404529},{"_id":"themes/hiker/layout/layout.ejs","hash":"aa685e9762a356f9b677e6f9d17e04694492fb83","modified":1502121404686},{"_id":"themes/hiker/node_modules/nopt/.npmignore","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1317851223000},{"_id":"source/_posts/Install-MySQL5-7/Navicat使用期限.png","hash":"44a9c588fbb1ab98c051b6a1594111320bd83670","modified":1491977662881},{"_id":"source/_posts/IEEE802.11无线LANs概述/中央基站.jpg","hash":"d62dc25402e8f1ef2c0c36387d3e3f0f38eb36c1","modified":1514294334471},{"_id":"source/_posts/Install-MySQL5-7/Navicat使用界面.png","hash":"b0ec26c42dc7073171ecb0f8167dc5f4667ac072","modified":1491977735072},{"_id":"source/_posts/Install-MySQL5-7/mysql安装路径.png","hash":"7ace4992962207ad64f3a67a1c6fa0db6c42fd19","modified":1491978729202},{"_id":"source/_posts/IEEE802.11无线LANs概述/BBS.jpg","hash":"47473d70e9aa1d824e744ba2801ce6ccfda5df7b","modified":1514353041363},{"_id":"source/_posts/Install-MySQL5-7/mysql配置完成.png","hash":"910ed89a5169eab6a6c076e515c29b60492bdd5c","modified":1491983678401},{"_id":"source/_posts/Install-MySQL5-7/mysql启动.png","hash":"c831dd980eeaef21c46443487390f8686597a1bc","modified":1491979320814},{"_id":"source/_posts/Install-MySQL5-7/mysql安装.png","hash":"e72d16b4db2137c49cf965a292b54dbbc23c700e","modified":1491978496538},{"_id":"source/_posts/Install-MySQL5-7/操作界面.png","hash":"c7fb104144c22084fe85eb2d24106952d2f293e8","modified":1491978252900},{"_id":"source/_posts/Install-MySQL5-7/查看mysql字符编码.png","hash":"845976a25ef31e3b0dbf4c725e2a58cbdef32cec","modified":1491982915314},{"_id":"source/_posts/Install-MySQL5-7/mysql目录结构.png","hash":"7266aa139e47bc21e10a632149181cdaa1c36076","modified":1491976079423},{"_id":"source/_posts/JS函数式编程笔记2/functor映射2.png","hash":"8a02e555182eb65c4683d7d8e984d385ee3b43f6","modified":1517987385673},{"_id":"source/_posts/VAET阅读稿/fig12.png","hash":"f3db366a3ba03846dfe43c5601d9dbd9fdafb3e0","modified":1507799804096},{"_id":"source/_posts/计算机网络实验/DNS-request.png","hash":"40612c4a20494d0cd5f83d58173f74cbc2a2eebf","modified":1510365312751},{"_id":"source/gallery/guitarist.jpg","hash":"36b49a2f0183ac20207c44a8172e410e4d6865e6","modified":1502123876397},{"_id":"source/gallery/salt-lake.jpg","hash":"75f95771de904d94b675e967f2f07114641bcdc2","modified":1502123876515},{"_id":"themes/hiker/layout/_partial/archive-post.ejs","hash":"55d661b63ffe41489bffe4d0570af50a1b952d63","modified":1502121404849},{"_id":"source/_posts/计算机系统结构/3-11.jpg","hash":"d4a80d52141d6fe35acac9107b677d2c1bf4daf2","modified":1511165806462},{"_id":"themes/hiker/layout/_partial/baidu-analytics.ejs","hash":"5776714a003d2b96b04b5399f67e0899d821247e","modified":1502121405006},{"_id":"themes/hiker/layout/_partial/after-footer.ejs","hash":"cf844d9dda22b63e990c2b9e5c8bee82c41fd3aa","modified":1502121404830},{"_id":"themes/hiker/layout/_partial/busuanzi-analytics.ejs","hash":"7de568681c315e88127bec120b8100ce6640210f","modified":1502121405034},{"_id":"themes/hiker/layout/_partial/archive.ejs","hash":"538346df9267cb701bb985faf0d5de2fa4c1e4e7","modified":1502121404902},{"_id":"themes/hiker/layout/_partial/cnzz-analytics.ejs","hash":"87410fedf15383f119706c96f71552be14248d57","modified":1502121405055},{"_id":"themes/hiker/layout/_partial/donate.ejs","hash":"046e168c6aad9889199c9a48b57dc973b4f46dab","modified":1502121405225},{"_id":"themes/hiker/layout/_partial/dialog.ejs","hash":"453934257d0efa8124afc686f299e7a21e7a1c4d","modified":1502121405192},{"_id":"themes/hiker/layout/_partial/article.ejs","hash":"761ffbb86a237e2148a5353cf6ab9a44ddbc91a7","modified":1502121404966},{"_id":"themes/hiker/layout/_partial/facebook-sdk.ejs","hash":"06038db50d2e1febdefa3f8e1512b332c7da5a17","modified":1502121405258},{"_id":"themes/hiker/layout/_partial/footer.ejs","hash":"dfbfe362953c8d44c875554f55fad74bd80b2afb","modified":1502121405308},{"_id":"themes/hiker/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1502121405344},{"_id":"themes/hiker/layout/_partial/header-post.ejs","hash":"734773126757ef9f21524cec082dcdb4268cabf4","modified":1502121405498},{"_id":"themes/hiker/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1502121405379},{"_id":"themes/hiker/layout/_partial/comment.ejs","hash":"1471bafc3e1b348cdd081ad8f79e6656323ec04b","modified":1502121405168},{"_id":"themes/hiker/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1502121405700},{"_id":"themes/hiker/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1502121405735},{"_id":"themes/hiker/layout/_widget/archive.ejs","hash":"9fffde4e794b35f07c96eaec6d9373a40014da8f","modified":1502121406109},{"_id":"themes/hiker/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1502121406138},{"_id":"themes/hiker/layout/_partial/tencent-analytics.ejs","hash":"93120ad06c5d73ca777470faf570e993a805e049","modified":1502121405779},{"_id":"themes/hiker/layout/_partial/head.ejs","hash":"7622979657edfc25c6039b03f74ff1a01ec45b96","modified":1502121405461},{"_id":"themes/hiker/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1502121406167},{"_id":"themes/hiker/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1502121406221},{"_id":"themes/hiker/layout/_widget/social.ejs","hash":"013beb5d78dfe34507b766f551b4a43ff628a5fe","modified":1502121406195},{"_id":"themes/hiker/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1502121406241},{"_id":"themes/hiker/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1502121406340},{"_id":"themes/hiker/layout/search/insight.ejs","hash":"c97ef6478f8cd45458614cd78511c23cbd4e7a28","modified":1502121406403},{"_id":"themes/hiker/layout/search/index.ejs","hash":"a027a663baaffa212f5eb4947d43008419376177","modified":1502121406373},{"_id":"themes/hiker/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1502121406308},{"_id":"themes/hiker/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1502121406430},{"_id":"themes/hiker/node_modules/.bin/cake","hash":"0c9f0a8e11284708b6b49d492ecac6f588124b74","modified":1502121473620},{"_id":"themes/hiker/node_modules/.bin/cake.cmd","hash":"3a36c5e4c53bd569c3fd3e4448b0ee3af459a17e","modified":1502121473620},{"_id":"themes/hiker/node_modules/.bin/coffee","hash":"a7874b2a3e873f99386274a819eb6a5dd6ce0565","modified":1502121473620},{"_id":"themes/hiker/node_modules/.bin/esparse","hash":"bd1eb9e2387ec86549489459bfa277e23c7c6a70","modified":1502121473607},{"_id":"themes/hiker/node_modules/.bin/coffee.cmd","hash":"e02fd3c6a67f6f74988ec5471078f63a38fedcd0","modified":1502121473620},{"_id":"themes/hiker/node_modules/.bin/esparse.cmd","hash":"eb7f8a6db227b70e87ebd6adf6c1907ba33f07a1","modified":1502121473607},{"_id":"themes/hiker/node_modules/.bin/esvalidate","hash":"eb15f43581a3b8be57ffe0339c22e0ce9206f4fb","modified":1502121473610},{"_id":"themes/hiker/node_modules/.bin/esvalidate.cmd","hash":"97acf9ac21c7931b55694f9202d3b13f2f16470c","modified":1502121473607},{"_id":"themes/hiker/node_modules/.bin/js-yaml","hash":"6a5cdebf73dc2878ae2edd15a39eafef4142a35f","modified":1502121473524},{"_id":"themes/hiker/node_modules/.bin/js-yaml.cmd","hash":"15a04f2ee96e8cd6f1564511e6c7eb2c174ca6ef","modified":1502121473524},{"_id":"themes/hiker/node_modules/.bin/nopt","hash":"6ccc2512fcda8502c733ab9717609e322603c606","modified":1502121473560},{"_id":"themes/hiker/node_modules/.bin/nopt.cmd","hash":"ff6d6bd0f6583ce1712e51888a74d9a3a7b10dfa","modified":1502121473560},{"_id":"themes/hiker/node_modules/.bin/rimraf","hash":"415d9c0eae0532980d190d0d4286eb2b5cf854c5","modified":1502121473551},{"_id":"themes/hiker/layout/_partial/header.ejs","hash":"7089d6af82224f5246d6de83ce8c17337b781f46","modified":1502121405677},{"_id":"themes/hiker/node_modules/.bin/which","hash":"0a816df3d5e49ffec52fcc7685d90b9ddc58f0ab","modified":1502121473513},{"_id":"themes/hiker/node_modules/.bin/rimraf.cmd","hash":"88aae323a343add10bb0a119f7b56ffb4ff25bd1","modified":1502121473551},{"_id":"themes/hiker/node_modules/.bin/which.cmd","hash":"a45b4777cb1c1246caf994f5e3cc2a39eb196498","modified":1502121473513},{"_id":"themes/hiker/node_modules/abbrev/LICENSE","hash":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1432169859000},{"_id":"themes/hiker/node_modules/abbrev/package.json","hash":"92662c16bce7a5d8b1c7006b1d8cd03684d3de30","modified":1502121473262},{"_id":"themes/hiker/node_modules/argparse/HISTORY.md","hash":"2f93eafec7f66f0924f7e146f699d47fcf2e41d4","modified":1417456148000},{"_id":"themes/hiker/node_modules/abbrev/README.md","hash":"c520bc857ec612ed88e13d794c47882d5aed3286","modified":1286218346000},{"_id":"themes/hiker/node_modules/abbrev/abbrev.js","hash":"e33940719dacc3ea04a0fb3efd7f5a57987b6257","modified":1487053799000},{"_id":"themes/hiker/node_modules/argparse/index.js","hash":"fbee159aa9d54e9ff6331e8cf57e6af2b8c086a8","modified":1417455549000},{"_id":"themes/hiker/node_modules/async/.gitmodules","hash":"5a82cf42e007663dfd60e92485c77cfb6e492c62","modified":1330309380000},{"_id":"themes/hiker/node_modules/argparse/package.json","hash":"8d9be4b8b81830df39c159fb7862a57de120cc3c","modified":1502121473234},{"_id":"themes/hiker/node_modules/async/LICENSE","hash":"99e50b7dfe39753bccb8aabce3cd1f80e960713b","modified":1330309380000},{"_id":"themes/hiker/node_modules/async/.npmignore","hash":"7a636ce8ce21a17d255497dd188fa82f9f7c0edc","modified":1330309380000},{"_id":"themes/hiker/node_modules/argparse/README.md","hash":"c5cd7c91eecc2c93c8df881ecd74761505dd0f1f","modified":1417455549000},{"_id":"themes/hiker/node_modules/async/Makefile","hash":"eee69a0169161e838d24faf6c1e609a6cbe688e4","modified":1330310311000},{"_id":"themes/hiker/node_modules/async/package.json","hash":"cddb7b19c862dc318598693546303db32bcf0634","modified":1502121473257},{"_id":"themes/hiker/node_modules/coffee-script/.npmignore","hash":"81ce9d5e8a41d8c108b73e6f3e06020b732658c1","modified":1312514256000},{"_id":"themes/hiker/node_modules/async/README.md","hash":"0205ee7a0742fc9868e6197d03521d22c2337670","modified":1337842210000},{"_id":"themes/hiker/node_modules/coffee-script/CNAME","hash":"68c58ea14f5d4a99aedabb4dcb8d4f3bc03467a7","modified":1334084270000},{"_id":"themes/hiker/node_modules/coffee-script/LICENSE","hash":"89cbbb510c5d7f8dbdfa360a442faac1c8e54976","modified":1334084354000},{"_id":"themes/hiker/node_modules/argparse/LICENSE","hash":"dbbafd9d668fb6b582e4b4e3c5f3e893a353f5ef","modified":1417455549000},{"_id":"themes/hiker/node_modules/async/index.js","hash":"a27ab3350a1167bc607fc738645eeb82eadb5c11","modified":1330309380000},{"_id":"themes/hiker/node_modules/coffee-script/README","hash":"6f18b3028c51aaa01978665e9688b62ae7594895","modified":1320793659000},{"_id":"themes/hiker/node_modules/coffee-script/package.json","hash":"200968cac3fb455eec5fa88112c8ce429811176c","modified":1502121473275},{"_id":"themes/hiker/node_modules/colors/MIT-LICENSE.txt","hash":"98053a44e1cdefb39af37fc6fdaf6752d72e39a0","modified":1374816967000},{"_id":"themes/hiker/node_modules/coffee-script/Rakefile","hash":"0d27b5b6f3767272df49a0ea7a3876f54d3a45ac","modified":1293075363000},{"_id":"themes/hiker/node_modules/colors/ReadMe.md","hash":"d969ffe7d0bd51e20c086257bf4233fb863f50ae","modified":1374816967000},{"_id":"themes/hiker/node_modules/colors/package.json","hash":"aacdec06368abac3fc9f006ee119927cf805ba35","modified":1502121473258},{"_id":"themes/hiker/node_modules/colors/example.js","hash":"59c3df605b63a9756c0b6bdc0fd6064383df7371","modified":1377120062000},{"_id":"themes/hiker/node_modules/colors/colors.js","hash":"ae7ec5ee848724835176628fb62283202612efa6","modified":1377126803000},{"_id":"themes/hiker/node_modules/colors/example.html","hash":"2637d809a0a44bc68b35a83de95db7635069f3bf","modified":1374816967000},{"_id":"themes/hiker/node_modules/dateformat/package.json","hash":"ec3c751d49226a1d614bd99f1146b4539f30b029","modified":1502121473264},{"_id":"themes/hiker/node_modules/dateformat/Readme.md","hash":"cc2452996e7233e017fef78f764b068eb2354487","modified":1317208002000},{"_id":"themes/hiker/node_modules/colors/test.js","hash":"a2bd30291ba9d1a51dcfbe1bdbcce3d715c6fc74","modified":1377120677000},{"_id":"themes/hiker/node_modules/esprima/package.json","hash":"ea8b60aa012a435ab27a73f23a2fa0f26c89e52e","modified":1502121473270},{"_id":"themes/hiker/node_modules/esprima/README.md","hash":"dcfdc84f7982c295425f9f22b8bd8bdcbb5b4bc7","modified":1377750976000},{"_id":"themes/hiker/node_modules/eventemitter2/package.json","hash":"d401d5db550d8281ee500b2880d494949d5473df","modified":1502121473259},{"_id":"themes/hiker/node_modules/eventemitter2/README.md","hash":"fb7c8c8ad5cdfd6b9d9e23942f9ac447a8672c65","modified":1403539644000},{"_id":"themes/hiker/node_modules/eventemitter2/index.js","hash":"a38bca78b416dccd824b14d360e4a4c3593b6673","modified":1403539644000},{"_id":"themes/hiker/node_modules/exit/.jshintrc","hash":"0587e11e5cb53577f178a5ec54e8291f7c8803b3","modified":1379691245000},{"_id":"themes/hiker/node_modules/exit/.travis.yml","hash":"dd90533610ce61425fd0a3d2ad81a8c32b77bdf3","modified":1379691245000},{"_id":"themes/hiker/node_modules/exit/LICENSE-MIT","hash":"b418ef01b1aa695789ec0237509d4c54bbec98ee","modified":1379691245000},{"_id":"themes/hiker/node_modules/exit/Gruntfile.js","hash":"7af27352d82472a9cea4f14b5756a759ce98df96","modified":1379691245000},{"_id":"themes/hiker/node_modules/findup-sync/.jshintrc","hash":"072aadbeb5b08628c662cb71fb2a80c77a5fefe7","modified":1394807285000},{"_id":"themes/hiker/node_modules/exit/package.json","hash":"db3be5873f753c546e772877d510c54d9b6aee8f","modified":1502121473262},{"_id":"themes/hiker/node_modules/findup-sync/LICENSE-MIT","hash":"b418ef01b1aa695789ec0237509d4c54bbec98ee","modified":1362770767000},{"_id":"themes/hiker/node_modules/exit/README.md","hash":"02e47ddbc94f472863846785579f7cce96226600","modified":1385493795000},{"_id":"themes/hiker/node_modules/findup-sync/.travis.yml","hash":"071a53a529e9acfd52d2dc2b83af3169140a6a94","modified":1362771040000},{"_id":"themes/hiker/node_modules/getobject/.jshintrc","hash":"29433d358ee71a9b57a8059eaa4a01a227c3e664","modified":1385064107000},{"_id":"themes/hiker/node_modules/findup-sync/README.md","hash":"a0c6442301c0ffebcc94378ade4b70bdee876dc0","modified":1394807394000},{"_id":"themes/hiker/node_modules/findup-sync/package.json","hash":"32b591ed21c3cf1a1affee29abd59c2dcbc82eb0","modified":1502121473238},{"_id":"themes/hiker/node_modules/getobject/LICENSE-MIT","hash":"b418ef01b1aa695789ec0237509d4c54bbec98ee","modified":1385064107000},{"_id":"themes/hiker/node_modules/getobject/.travis.yml","hash":"75d47644e03b370399b1c187df69c8f10f780b65","modified":1385064107000},{"_id":"themes/hiker/node_modules/getobject/.npmignore","hash":"4908b67461dad9714fb835308800efdeea795c62","modified":1385064107000},{"_id":"themes/hiker/node_modules/getobject/Gruntfile.js","hash":"f69e615ca9653096cdaf8d3c18ba10e0dfa9118c","modified":1385064107000},{"_id":"themes/hiker/node_modules/findup-sync/Gruntfile.js","hash":"046f1771d8cee96dc3ee1c351445ac56b3ac84a5","modified":1351803707000},{"_id":"themes/hiker/node_modules/getobject/package.json","hash":"71a7acb0eb0f3dbe2f0a3ac733091b2339671ed4","modified":1502121473255},{"_id":"themes/hiker/node_modules/glob/.npmignore","hash":"df0230e54e04f0f4739f4cdf671570dced4a1223","modified":1350315195000},{"_id":"themes/hiker/node_modules/glob/.travis.yml","hash":"b0e08ffb1a32bb17941785759a4154f995139ae8","modified":1344299893000},{"_id":"themes/hiker/node_modules/getobject/README.md","hash":"391e18fa52be1d8e5adad4fbf6805b90fdbac14c","modified":1385064360000},{"_id":"themes/hiker/node_modules/glob/LICENSE","hash":"a042a6c4248c82d810b9b617958f222c0de0f6c2","modified":1343093261000},{"_id":"themes/hiker/node_modules/glob/README.md","hash":"d44c73a135f6fbbc73c54586e74aa35cf802c1b7","modified":1344287108000},{"_id":"themes/hiker/node_modules/glob/package.json","hash":"5fc4168e6c9285b6f63d32f94253cab94ffd13b4","modified":1502121473235},{"_id":"themes/hiker/node_modules/graceful-fs/LICENSE","hash":"a042a6c4248c82d810b9b617958f222c0de0f6c2","modified":1369627536000},{"_id":"themes/hiker/node_modules/graceful-fs/.npmignore","hash":"3ca0e72fdfd533e411cc95dc9c91c5ec59661f95","modified":1322520827000},{"_id":"themes/hiker/node_modules/graceful-fs/package.json","hash":"912a3127aa5269133337ee69b57d188e21ad1395","modified":1502121473254},{"_id":"themes/hiker/node_modules/graceful-fs/README.md","hash":"c29647b03fe278f98effd353b3df894557b04b52","modified":1367341461000},{"_id":"themes/hiker/node_modules/glob/glob.js","hash":"f3efbd66544514b81ffc5f7e9e44da191cf015aa","modified":1361809438000},{"_id":"themes/hiker/node_modules/globule/.travis.yml","hash":"75d47644e03b370399b1c187df69c8f10f780b65","modified":1365707661000},{"_id":"themes/hiker/node_modules/globule/.npmignore","hash":"4908b67461dad9714fb835308800efdeea795c62","modified":1363728678000},{"_id":"themes/hiker/node_modules/globule/.jshintrc","hash":"29433d358ee71a9b57a8059eaa4a01a227c3e664","modified":1363728678000},{"_id":"themes/hiker/node_modules/globule/LICENSE-MIT","hash":"b418ef01b1aa695789ec0237509d4c54bbec98ee","modified":1363728678000},{"_id":"themes/hiker/node_modules/globule/Gruntfile.js","hash":"f69e615ca9653096cdaf8d3c18ba10e0dfa9118c","modified":1363894316000},{"_id":"themes/hiker/node_modules/grunt/.npmignore","hash":"12221116446da7f5ac78e7b9574f2741444695a7","modified":1399664145000},{"_id":"themes/hiker/node_modules/globule/package.json","hash":"664f265d0d4ecda811a589718365c2ac7d0c6ee7","modified":1502121473235},{"_id":"themes/hiker/node_modules/globule/README.md","hash":"3977f5ddc732867ab17cbbfa40eab7959124b3bc","modified":1365709973000},{"_id":"themes/hiker/node_modules/graceful-fs/graceful-fs.js","hash":"4d221ed85a222893cd9b37f07d78ecad306c6b10","modified":1373442338000},{"_id":"themes/hiker/node_modules/grunt/LICENSE-MIT","hash":"cceedc89ad746418d06ee918ccd7466df051f994","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/CONTRIBUTING.md","hash":"3c9d11bd6c0a87cbd8dfab255ace8ba90d18d042","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/README.md","hash":"1ae230f11ff2a6887497cdf3444f7e25915fd54d","modified":1399390646000},{"_id":"themes/hiker/node_modules/grunt/appveyor.yml","hash":"f4008f5045998b1bd37d0c36f7ce88e4434e1512","modified":1399664145000},{"_id":"themes/hiker/node_modules/grunt/package.json","hash":"366df4451817779d9efc2abeb3b186bdd9637bbb","modified":1502121473223},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/.npmignore","hash":"f375daee415ce9f338f742da9b0cfd727b99e7f6","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/.jshintrc","hash":"1581b45e1162fee0738b9e6500cb6fa609c569d2","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/.travis.yml","hash":"7632dc2d94109f51d334b9d2e8843c381510f56b","modified":1363328672000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/AUTHORS","hash":"a1e2f109a2a738b6e6cd65a9fb41454a59cc01df","modified":1364328401000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/CONTRIBUTING.md","hash":"3c9d11bd6c0a87cbd8dfab255ace8ba90d18d042","modified":1364328469000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/CHANGELOG","hash":"51f6639ba8ec6e9b4a9c624388a0d0648304b20e","modified":1364328383000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/LICENSE-MIT","hash":"dd60195a9ee58f7d255a13736ef0e6f276c76c3c","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/package.json","hash":"a408097c01f5d86f77620ad1a807a260ec858f85","modified":1502121473223},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/Gruntfile.js","hash":"d1cd2a27d832b58b788a06baa8a6da5f5a38158e","modified":1364328263000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/.jshintrc","hash":"4607a7a6282542b3e6f8c2e5c23e5aac4c4b17c0","modified":1373491608000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/.travis.yml","hash":"ea6496c27b706e607a310ffa0045dfa2cb84b9d3","modified":1373491608000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/.npmignore","hash":"e3fe973725530c2c143d4f694d00e8da8c4a9020","modified":1373491608000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/CONTRIBUTING.md","hash":"3c9d11bd6c0a87cbd8dfab255ace8ba90d18d042","modified":1373946346000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/AUTHORS","hash":"522c1045e170238d1cd108e5c502b5c3924b7305","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/CHANGELOG","hash":"eead732d943ac402ae9f1631d6fccad6273ac300","modified":1373946341000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/README.md","hash":"e51c82a4ecb53e0aa3e116123b2d346e84653450","modified":1364328241000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/LICENSE-MIT","hash":"8165bcd987a6b5b40e0354484293626894c470e6","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/package.json","hash":"8d0a46ddc073c140c0137543bcbb7a438dc871e3","modified":1502121473229},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/Gruntfile.js","hash":"3c43e06ce663894041434f5c1444c2777c786a7d","modified":1373945841000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/README.md","hash":"f4589462183ccf0bb8c5103fe141436556b32902","modified":1373946346000},{"_id":"themes/hiker/node_modules/grunt-git/LICENSE","hash":"b27124bde571104832b276ef0b11453ee3e98c14","modified":1362663155000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/.npmignore","hash":"8b894ec0b3bbc33011392ad9bafeb1df2634db45","modified":1450886265000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/.jshintrc","hash":"0587e11e5cb53577f178a5ec54e8291f7c8803b3","modified":1450886265000},{"_id":"themes/hiker/node_modules/grunt-git/package.json","hash":"5ffffa18aac1a1615ff41128bac21850672604dc","modified":1502121473223},{"_id":"themes/hiker/node_modules/grunt-legacy-log/LICENSE-MIT","hash":"cceedc89ad746418d06ee918ccd7466df051f994","modified":1450886265000},{"_id":"themes/hiker/node_modules/grunt-git/README.md","hash":"01c435cb3cc13177b82678f9279ce60ed0a5a030","modified":1403525250000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/README.md","hash":"e6c886b43ff8e41adb85a3ef87200bafde5b4a98","modified":1450886265000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/Gruntfile.js","hash":"5133165815b086f36f4bbf01f62483343c34d8eb","modified":1450886265000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/examples.js","hash":"d8ec800b2e3d99bf5ad84886445b056b667f89f7","modified":1450886265000},{"_id":"themes/hiker/node_modules/grunt-git/.jscs.json","hash":"73428bec9ada2425c87d1822e9bfc113c4e77b7b","modified":1398687678000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/.travis.yml","hash":"ff2d426dd199c4804eb5befca0af52195b5fbf40","modified":1450886402000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/.npmignore","hash":"8b894ec0b3bbc33011392ad9bafeb1df2634db45","modified":1432670742000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/package.json","hash":"749a42904f10748ce53a864a0b5d60410273f45d","modified":1502121473249},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/Gruntfile.js","hash":"5133165815b086f36f4bbf01f62483343c34d8eb","modified":1432670742000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/.jshintrc","hash":"0587e11e5cb53577f178a5ec54e8291f7c8803b3","modified":1432670742000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/index.js","hash":"79ea545547b0bbcb0ee8c4f85e50a0724dcaacda","modified":1450886402000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/.travis.yml","hash":"e17f38d7614f38214f713c55d85f2e6fbe8c3c0b","modified":1432670742000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/README.md","hash":"11aff4cc51503a398489a06e7b91271300b90ebb","modified":1432671191000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/.jshintrc","hash":"0587e11e5cb53577f178a5ec54e8291f7c8803b3","modified":1399476917000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/package.json","hash":"18458a78b20d5ad65bb642272e235c685b93ee6d","modified":1502121473251},{"_id":"themes/hiker/node_modules/grunt-legacy-util/.travis.yml","hash":"e17f38d7614f38214f713c55d85f2e6fbe8c3c0b","modified":1399477020000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/Gruntfile.js","hash":"5133165815b086f36f4bbf01f62483343c34d8eb","modified":1399476903000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/LICENSE-MIT","hash":"cceedc89ad746418d06ee918ccd7466df051f994","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/LICENSE-MIT","hash":"ef57deb33efffbceb7041a96ab26c76024de1743","modified":1432671162000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/index.js","hash":"bfe80b398de7f11de3a28fb7607bc3f4ced1d045","modified":1432671034000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/README.md","hash":"59d34e00f93c01672dd37d33bc780d58c3e8d83b","modified":1399651632000},{"_id":"themes/hiker/node_modules/iconv-lite/.npmignore","hash":"7b346c0a5dc4328c38c17ddc9719f8b5768f99ae","modified":1336298551000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/package.json","hash":"7efc1bbf57d3a4618465f80ed3fcfc537cb48d60","modified":1502121473229},{"_id":"themes/hiker/node_modules/grunt-legacy-util/.npmignore","hash":"8b894ec0b3bbc33011392ad9bafeb1df2634db45","modified":1397053407000},{"_id":"themes/hiker/node_modules/iconv-lite/LICENSE","hash":"4f3ca49a793f6bb8465a3731fd965a128757b8ce","modified":1320857905000},{"_id":"themes/hiker/node_modules/iconv-lite/README.md","hash":"89f8a01d1bc285aca49240e5e0954a0a1258505b","modified":1373851248000},{"_id":"themes/hiker/node_modules/iconv-lite/README.md~","hash":"9e17e6bfbab303a80e13809b7d8bc20e838fa2f2","modified":1322052600000},{"_id":"themes/hiker/node_modules/iconv-lite/package.json","hash":"a9b2ff16259ed446031d0ac7d43dfbda7cc3c4c9","modified":1502121473249},{"_id":"themes/hiker/node_modules/hooker/LICENSE-MIT","hash":"28153506c787aa9af20faa1139fb04244e9a9e69","modified":1327282452000},{"_id":"themes/hiker/node_modules/iconv-lite/.travis.yml","hash":"a0d14c115074c1762cbdc07b4207a23eb59fa949","modified":1354651426000},{"_id":"themes/hiker/node_modules/hooker/grunt.js","hash":"6d8a487620c1bb798bfd07f18a0c5d9c50771c29","modified":1327282452000},{"_id":"themes/hiker/node_modules/hooker/package.json","hash":"36f19534ce7139bc820f942fa6662ac91574013a","modified":1502121473250},{"_id":"themes/hiker/node_modules/iconv-lite/index.js","hash":"7fe902a9e2801eaf29c9e83838b3d5e49f33c9f1","modified":1373851118000},{"_id":"themes/hiker/node_modules/hooker/parent.js","hash":"bad636f06dc7aad1dbcc63f0b2255390b6cae8e4","modified":1327432396000},{"_id":"themes/hiker/node_modules/hooker/child.js","hash":"989bf3a67217c035ef911c334cb55f34f24f27b6","modified":1327432191000},{"_id":"themes/hiker/node_modules/grunt-git/.travis.yml","hash":"c331d27bf987dae046c753dccd09d4e467234217","modified":1401271749000},{"_id":"themes/hiker/node_modules/hooker/README.md","hash":"e7ac8e4968f6912bde51540738154ef328e37561","modified":1327282452000},{"_id":"themes/hiker/node_modules/inherits/README.md","hash":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/index.js","hash":"f67938caf0e914754d408b8a6509e47c269380da","modified":1399651531000},{"_id":"themes/hiker/node_modules/inherits/package.json","hash":"06fdce486266f68369c72668bedd6e0600620d65","modified":1502121473244},{"_id":"themes/hiker/node_modules/inherits/inherits_browser.js","hash":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/hiker/node_modules/inherits/inherits.js","hash":"491caba7b70590f6dcbe37d7edccd9f89ac1b9fd","modified":1473280161000},{"_id":"themes/hiker/node_modules/inherits/LICENSE","hash":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/hiker/node_modules/js-yaml/LICENSE","hash":"325c71e01846ea7b7aeaeeb541644def35186cfd","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/HISTORY.md","hash":"abce83916ea064aee439f6b80eb81e6272c3a5c7","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/README.md","hash":"6db8dd3ecbf80b8db25b390ab7f8bf9aee4f2f5f","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/index.js","hash":"d97562c3e28663b169489d3a3c90b44fef9ed68b","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/package.json","hash":"781e3df754111880126177e0a30a315ff5613c80","modified":1502121473267},{"_id":"themes/hiker/node_modules/load-grunt-tasks/package.json","hash":"8b6cbc4bebe69a38ce83fd23e641e09351ba1496","modified":1502121473223},{"_id":"themes/hiker/node_modules/lodash/README.md","hash":"0a7001ea1ad8b16081b0636669c87f51efd0b434","modified":1377878417000},{"_id":"themes/hiker/node_modules/load-grunt-tasks/readme.md","hash":"8de843a842fc3a9c6bb974fa0691396b773931cc","modified":1387295794000},{"_id":"themes/hiker/node_modules/load-grunt-tasks/load-grunt-tasks.js","hash":"197ceb005edc02926e28b9029e46f531dccd37c1","modified":1387295794000},{"_id":"themes/hiker/node_modules/lodash/package.json","hash":"2764859a86a23e14b7f602fe71223b4430fbd5b3","modified":1502121473245},{"_id":"themes/hiker/node_modules/lru-cache/.travis.yml","hash":"ac2b64b93ab810be473f67745bd9f7d4c3e8e0ff","modified":1433355858000},{"_id":"themes/hiker/node_modules/lru-cache/CONTRIBUTORS","hash":"6a6e5148568ff15b4756ee478f0da581ea97fc01","modified":1385053079000},{"_id":"themes/hiker/node_modules/lodash/lodash.min.js","hash":"61e2d40d3f02f31178334dfd7b6496e808e9c48f","modified":1356670301000},{"_id":"themes/hiker/node_modules/lru-cache/.npmignore","hash":"cc16a69ea300506c49a0844bc69745bf8f34cf40","modified":1323392699000},{"_id":"themes/hiker/node_modules/lru-cache/LICENSE","hash":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999527000},{"_id":"themes/hiker/node_modules/minimatch/.npmignore","hash":"8b894ec0b3bbc33011392ad9bafeb1df2634db45","modified":1372866257000},{"_id":"themes/hiker/node_modules/lru-cache/package.json","hash":"3b72d33ab8f4f9d3662d33015ba00cd37f28ac0d","modified":1502121473241},{"_id":"themes/hiker/node_modules/minimatch/LICENSE","hash":"4a1927e74796f06ac7e7a687ca6b44d39c65d8f4","modified":1311966493000},{"_id":"themes/hiker/node_modules/lru-cache/README.md","hash":"129fd032ba2ac7580e57e0d9988a4d06f1b344fd","modified":1448474798000},{"_id":"themes/hiker/node_modules/minimatch/README.md","hash":"32a95bf2d3d1c5463542d236af28b5ffb12b7d2d","modified":1387173103000},{"_id":"themes/hiker/node_modules/lodash/lodash.underscore.min.js","hash":"58ffea4a2bdfc281d1b0f6bf09090804d647e812","modified":1356670311000},{"_id":"themes/hiker/node_modules/nopt/LICENSE","hash":"4a1927e74796f06ac7e7a687ca6b44d39c65d8f4","modified":1317851223000},{"_id":"themes/hiker/node_modules/nopt/package.json","hash":"5d07610774c904dce4a73371329b2cb9692b35b5","modified":1502121473269},{"_id":"themes/hiker/node_modules/rimraf/LICENSE","hash":"4a1927e74796f06ac7e7a687ca6b44d39c65d8f4","modified":1306777682000},{"_id":"themes/hiker/node_modules/nopt/README.md","hash":"5cb6bac3c202ae01f012115fbd5a196cab7d4edd","modified":1317851223000},{"_id":"themes/hiker/node_modules/rimraf/AUTHORS","hash":"18341b56fef79d520c3d862b737e91c6b24ea649","modified":1327889666000},{"_id":"themes/hiker/node_modules/rimraf/package.json","hash":"c5cccc0d2381352742288078cdbc1fe7abe107af","modified":1502121473271},{"_id":"themes/hiker/node_modules/rimraf/README.md","hash":"e579a194de49c69f6404ea8c8990a7b982d3e95c","modified":1385744303000},{"_id":"themes/hiker/node_modules/minimatch/minimatch.js","hash":"66de40ad270165fabe16e5af02fae0ce2d558b7f","modified":1387223424000},{"_id":"themes/hiker/node_modules/sigmund/LICENSE","hash":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1432106334000},{"_id":"themes/hiker/node_modules/sigmund/package.json","hash":"d496d8f26b2edd56b6f736e555ae2e58b6a94b05","modified":1502121473242},{"_id":"themes/hiker/node_modules/sigmund/README.md","hash":"6007650d6a1dc24c4dc57409e7611b6998d244aa","modified":1401638608000},{"_id":"themes/hiker/node_modules/sigmund/sigmund.js","hash":"7575ead5bf4fbb3eed15ead87c050cc8e306d446","modified":1344873467000},{"_id":"themes/hiker/node_modules/rimraf/rimraf.js","hash":"44659e827a4ceb7bfb8793b80af86c5f96f8dd8c","modified":1399391937000},{"_id":"themes/hiker/node_modules/underscore/LICENSE","hash":"4a536006299d219843f69f87ecac4b52158b3efc","modified":1392067000000},{"_id":"themes/hiker/node_modules/sigmund/bench.js","hash":"7f512661bb09413fa3c814f89fdf58b157f08e63","modified":1344873467000},{"_id":"themes/hiker/node_modules/underscore/README.md","hash":"fb13eed34314e90170be6290876a9a66c4051272","modified":1390328510000},{"_id":"themes/hiker/node_modules/underscore/package.json","hash":"ecfb2b4e6a45caec0dcbfa185644236e8208c9ec","modified":1502121473232},{"_id":"themes/hiker/node_modules/underscore.string/.travis.yml","hash":"e33e8d35cf94d67804af457d709d8db1d16f73ae","modified":1373449276000},{"_id":"themes/hiker/node_modules/underscore.string/Gemfile.lock","hash":"3917bc6cd244dbbf1e7458df89f83cb688d74684","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/Gemfile","hash":"874b245ee171eaa4bed59896539e380e56ce99f0","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/Rakefile","hash":"36c73173ebaadef1ad9a49bd74c167f69f597061","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/README.markdown","hash":"97465c8b60015f348232c19d0cbd41188b060774","modified":1373452312000},{"_id":"themes/hiker/node_modules/minimatch/package.json","hash":"e972a6ac3efca1e70f7b6e7a723cc3273839e210","modified":1502121473238},{"_id":"themes/hiker/node_modules/which/LICENSE","hash":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1416911659000},{"_id":"themes/hiker/node_modules/underscore/underscore.js","hash":"07147a83bfaba702d30426c7c31bccb25e692a2e","modified":1409091073000},{"_id":"themes/hiker/node_modules/underscore.string/package.json","hash":"17c3789b137c4ff67301375a22517f3608b82c68","modified":1502121473229},{"_id":"themes/hiker/node_modules/which/README.md","hash":"23761d51e981dcb34d29a2d77f05c340cfe806a2","modified":1312741327000},{"_id":"themes/hiker/node_modules/which/package.json","hash":"34480715631f16f3e7a8805b400fe30c77cbc1a4","modified":1502121473264},{"_id":"themes/hiker/source/css/_extend.styl","hash":"5a2b18b03c18c92f130771aa97737e100202d21b","modified":1502121406480},{"_id":"themes/hiker/node_modules/underscore/underscore-min.js","hash":"fb26909af4ad2a6c240b9aa4b35bb983cf4b20e4","modified":1409091109000},{"_id":"themes/hiker/node_modules/which/which.js","hash":"7d8ead9070991a0fba0db3a843e6e7d346fe219c","modified":1424896246000},{"_id":"themes/hiker/source/css/archive.css","hash":"17cc72203cad1b0be66008d662c7494507aaee8b","modified":1502121406526},{"_id":"themes/hiker/source/css/_variables.styl","hash":"4e9477e1c96467213959ba4a4873b7a908658ee8","modified":1502161794998},{"_id":"themes/hiker/source/css/header-post.css","hash":"3f6d1f5593a353b4b05a67ee14e04ec9c986db21","modified":1502121406594},{"_id":"themes/hiker/source/css/home.css","hash":"2a7bfef438468b5b8be3f84ea6818156d371077d","modified":1502121406619},{"_id":"themes/hiker/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1502121407212},{"_id":"themes/hiker/source/css/style.styl","hash":"cbf244726bf1fde4d278b4d3768e289f9f64ae35","modified":1502121406636},{"_id":"themes/hiker/source/css/vdonate.css","hash":"bca2d291a71e7358654c51f23e8bfb467b2bc8b2","modified":1502121406660},{"_id":"themes/hiker/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1502121407250},{"_id":"themes/hiker/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1502121407227},{"_id":"themes/hiker/source/css/dialog.css","hash":"5e0333adf3f496e0d443767fe228a1d4b1a2bafc","modified":1502121406572},{"_id":"themes/hiker/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1502121407261},{"_id":"themes/hiker/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1502121407237},{"_id":"themes/hiker/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1502121407271},{"_id":"themes/hiker/node_modules/rimraf/bin.js","hash":"f6e74628b82bbd551e11947abad295c1b87cf6df","modified":1371826156000},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1502121407292},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1502121407341},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1502121407394},{"_id":"themes/hiker/source/js/home.js","hash":"e403c3290d76c5f58571cbfe4414236e41a7ac94","modified":1502121407694},{"_id":"themes/hiker/source/js/dialog.js","hash":"01e8b337c1721e0486fd5044f98b233e84ba1985","modified":1502352260503},{"_id":"themes/hiker/source/js/insight.js","hash":"f79ab175d1c8c4fb59328ee4fd9eb95808eb0be5","modified":1502121407729},{"_id":"themes/hiker/source/preview/browser-support.png","hash":"a6d8498553550c6b18a8f22bcd2f53c993c7d677","modified":1502121407974},{"_id":"themes/hiker/source/js/scripts.js","hash":"e06a8948375df71cbf77abf8617db438ece811b3","modified":1502121407872},{"_id":"themes/hiker/source/js/totop.js","hash":"29bb40144ac238d22b25d59df465aff8dc38bfd0","modified":1502121407902},{"_id":"themes/hiker/source/preview/donation-btn.png","hash":"ad78b1605b162e2399a1cdc5232f6a44298dba6c","modified":1502121408022},{"_id":"themes/hiker/source/preview/theme-color.png","hash":"725130ceea5e41bb2cc60b31e45275b4b0cc77b3","modified":1502121408085},{"_id":"themes/hiker/source/js/vdonate.js","hash":"5738414c642d30e43943a69287b3d25a0b6be135","modified":1502121407958},{"_id":"source/_posts/IEEE802.11无线LANs概述/802.11.jpg","hash":"77ce7c6d972aaf0aa89ea05bf8bc260bc6ae33c0","modified":1514297254991},{"_id":"source/_posts/JS函数式编程笔记2/functor映射实例.png","hash":"4e8963a1ec55d4ff4d8fa72705d97717e919315d","modified":1517987465254},{"_id":"source/_posts/JS函数式编程笔记2/functor映射.png","hash":"8a28f15f63fbfa5e42414a2653e9ecf84d7a0040","modified":1517987363020},{"_id":"source/_posts/VAET阅读稿/confusion-matrix.png","hash":"d4dee8a74d7f1b07f25f81419fbe663279590f48","modified":1506677603871},{"_id":"source/_posts/VAET阅读稿/decision-tree.png","hash":"5887331291434165ce3cb425f7480caecb4d05b4","modified":1506677581807},{"_id":"source/_posts/VAET阅读稿/salient-transactions.png","hash":"4e95061dcf9e8af1319ddc233c52c677487177d3","modified":1507794552001},{"_id":"source/_posts/VAET阅读稿/hierarchical-tree.png","hash":"3926154838b6bc365eaed603988e5d5d7c5eabce","modified":1506677685894},{"_id":"source/_posts/计算机网络实验/DNS-header.png","hash":"1e4cd5492288fff80818e4778dc46ed55e412cb4","modified":1510367023544},{"_id":"source/_posts/计算机网络实验/DNS-response.png","hash":"d411ad4d2eae1adcb330a8c5e5a7cb3f08f94793","modified":1510365327093},{"_id":"themes/hiker/node_modules/esprima/esprima.js","hash":"ffe7461e5c7fd420c0038e38ee80bf7809c7e9aa","modified":1377753703000},{"_id":"themes/hiker/node_modules/lodash/lodash.underscore.js","hash":"e391a12750ad716c2e501f2b2e0e02dd83a694de","modified":1356670304000},{"_id":"themes/hiker/source/css/bootstrap.css","hash":"64fdc2e7c3f8a164d21c5632b5adbbb9990ea802","modified":1502121406551},{"_id":"themes/hiker/source/js/bootstrap.js","hash":"3b965a36a6b08854ad6eddedf85c5319fd392b4a","modified":1502121407629},{"_id":"source/_posts/JS函数式编程笔记1/compose.png","hash":"ae1f8436e43c0ed5fb257359921b853d48a2d2c8","modified":1512999922978},{"_id":"source/_posts/VAET阅读稿/Knotlines.png","hash":"7a52d62f0e22ae43c40d7ba1a71f6a7dbd1c54fb","modified":1507725510261},{"_id":"source/_posts/VAET阅读稿/feature-extraction.png","hash":"beb8fec07cab227deb28c4ea842213432ad78f8c","modified":1506677563332},{"_id":"source/_posts/VAET阅读稿/visual-organization.png","hash":"ddf63d5386f71c56e0edc34d0e0df5f28adce15f","modified":1506677759499},{"_id":"source/_posts/计算机网络实验/DNS-format.png","hash":"ef1510ecbcde8f46d75a97802dbb64b77a62b84a","modified":1510366988346},{"_id":"source/_posts/计算机网络实验/DNS-not-such-name.png","hash":"178429e7f2241286cc0e4b5358939f39e1cdfe04","modified":1510367199989},{"_id":"themes/hiker/layout/_partial/post/gallery.ejs","hash":"30028f10a4f03561e53da323d06b292e1ae7990c","modified":1502121405898},{"_id":"themes/hiker/layout/_partial/post/date.ejs","hash":"380985bb414f9a0d517834f65cce57bc0b493d8c","modified":1502121405865},{"_id":"themes/hiker/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1502121405984},{"_id":"themes/hiker/layout/_partial/post/busuanzi-analytics.ejs","hash":"4ef5022062c8ee59f3413bc92e6b3ae0d5020738","modified":1502121405809},{"_id":"themes/hiker/layout/_partial/post/category.ejs","hash":"877a164bb13b46756eb111ec7bfe338a1eb36ad1","modified":1502121405838},{"_id":"themes/hiker/layout/_partial/post/title.ejs","hash":"a61267f27f2148321e549344be91dbc4e22e1a48","modified":1502121406043},{"_id":"themes/hiker/layout/_partial/post/mathjax.ejs","hash":"571c19f57c2b38ac5cd9b8f811cfad53b38616cf","modified":1502121405959},{"_id":"themes/hiker/layout/_partial/post/urlconvert.ejs","hash":"2133f1029632417f9043b9d4749d580ed0c75db0","modified":1502121406076},{"_id":"themes/hiker/node_modules/argparse/examples/arguments.js","hash":"8538260bbb595bc63ac97334024edbd486bc9a12","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/choice.js","hash":"4bd9df73749f13da8a6b9b58ebe6fcd741ace616","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/constants.js","hash":"4359e41c37d33c52a1261d71eb5b217e51d63c60","modified":1417455549000},{"_id":"themes/hiker/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1502121406019},{"_id":"themes/hiker/node_modules/argparse/examples/parents.js","hash":"ea7c71c1006bbce0556e63346635f1575ecde977","modified":1417455549000},{"_id":"themes/hiker/source/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1502121407831},{"_id":"themes/hiker/node_modules/argparse/examples/help.js","hash":"3c71ee644bc9da6474e393b07b07721d39a94a9a","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/nargs.js","hash":"2afc15fe7d18fd3d139377f9f18e7f50361473af","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/prefix_chars.js","hash":"9deda23774d63ea26d4048454d10c958252b54dc","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/sum.js","hash":"49fb15434d36407af716ce4fd5cfd9f2a9b147ee","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/sub_commands.js","hash":"2b040be65fdf4e1a3061eb42693d27f8caa9883b","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/examples/testformatters.js","hash":"8b2812fce10dfe7deba2c3b74072ba2d5a0ec6f8","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action.js","hash":"c10af341c539268c4cb032e919d7a80fc2e3438f","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/argument_parser.js","hash":"837404cd55846b7212ea9fa0a0c2d53976ce2844","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action_container.js","hash":"d91bd33b8d0bd00596090b64be550ccbe6864d10","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/argparse.js","hash":"8c53af72750678f55eaabc57d5e26056081514fe","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/namespace.js","hash":"85fb2005604feb9a7b777f9e37d9d75581fd17a2","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/const.js","hash":"94761a417f321678eca6c95cc169171017767d9a","modified":1417455549000},{"_id":"themes/hiker/node_modules/coffee-script/extras/jsl.conf","hash":"dabefa7040209a8c2c6194e2eb3a4332dc0fcd42","modified":1290392533000},{"_id":"themes/hiker/node_modules/coffee-script/bin/coffee","hash":"53426d453e8518879d69c1d8925b91434ebf8f80","modified":1320793659000},{"_id":"themes/hiker/node_modules/colors/themes/winston-light.js","hash":"ea9fb8f704581e751d85767563a3dcd826ead0e6","modified":1374816967000},{"_id":"themes/hiker/node_modules/colors/themes/winston-dark.js","hash":"0202ddb900b38f79dd5a8db1c70070d428b14cd1","modified":1374816967000},{"_id":"themes/hiker/node_modules/async/lib/async.js","hash":"64a9731748ff662d39c171db1ea0129cbf08505a","modified":1338402273000},{"_id":"themes/hiker/node_modules/dateformat/test/test_weekofyear.js","hash":"349f414ec587f90e920fe8e9a11f55b188e5ff2e","modified":1317208002000},{"_id":"themes/hiker/node_modules/esprima/bin/esparse.js","hash":"4f5180f8bb99ea6e2d1975a2d7a4c8ec2664c3a4","modified":1377555588000},{"_id":"themes/hiker/node_modules/coffee-script/bin/cake","hash":"800093682cd061078b68634a2940222459f7fbc6","modified":1320793659000},{"_id":"themes/hiker/node_modules/dateformat/test/test_weekofyear.sh","hash":"6438e2c97d0c17982bc3c191f71eeab1e47b36d9","modified":1317208002000},{"_id":"themes/hiker/node_modules/esprima/test/compat.js","hash":"7fc83f0e34c48231bc095d46e1a28052d84a44ea","modified":1377750976000},{"_id":"themes/hiker/node_modules/dateformat/lib/dateformat.js","hash":"4d74d612f5c516cd14a472ffcd7c8b1bf7c2ecb1","modified":1317208002000},{"_id":"themes/hiker/node_modules/esprima/test/reflect.js","hash":"d68e28079bd7fed77f6384639f763e158ffb0d17","modified":1377555589000},{"_id":"themes/hiker/node_modules/esprima/bin/esvalidate.js","hash":"f3414e385c8ed5f18eec4bb53fbb45321281b3ae","modified":1377750976000},{"_id":"themes/hiker/node_modules/esprima/test/run.js","hash":"75bf713cff15b900bca9ac63b986accb157e1856","modified":1377750976000},{"_id":"themes/hiker/node_modules/esprima/test/runner.js","hash":"1e298c4fe2bcd99d73a60a3770b7f557a876313b","modified":1377750976000},{"_id":"themes/hiker/node_modules/eventemitter2/lib/eventemitter2.js","hash":"12e2481da72369e2887f47099362f84f81cf1048","modified":1403539644000},{"_id":"themes/hiker/node_modules/exit/lib/exit.js","hash":"6252a9646834bf1332bd0c5659856877e445b030","modified":1385493708000},{"_id":"themes/hiker/node_modules/findup-sync/lib/findup-sync.js","hash":"a62291fcd7de02d73513f01354aa2f8dfd208937","modified":1362770767000},{"_id":"themes/hiker/node_modules/findup-sync/test/findup-sync_test.js","hash":"efe592317bc7d3dcef89ccf7023e4ce3df75e832","modified":1362770767000},{"_id":"themes/hiker/node_modules/getobject/lib/getobject.js","hash":"377c18115d45974a4b4bc08e2fd27f3256476f9b","modified":1385064254000},{"_id":"themes/hiker/node_modules/getobject/test/namespace_test.js","hash":"18f6003d346b34358c31340007e5806f288cbe16","modified":1385064314000},{"_id":"themes/hiker/node_modules/glob/examples/usr-local.js","hash":"a82d273b8acbbb0728d1d8ba541f406ecb91d612","modified":1326931644000},{"_id":"themes/hiker/node_modules/exit/test/exit_test.js","hash":"fea2036b048caf700f06ac02ee7e5c7f9d8b7e38","modified":1380115375000},{"_id":"themes/hiker/node_modules/glob/examples/g.js","hash":"c5e6ed35ba98b68b876256e9fa7b15fbac79aa27","modified":1326929552000},{"_id":"themes/hiker/node_modules/glob/test/00-setup.js","hash":"78da07aaaadb2b79467173cd94329dd64130de62","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/bash-results.json","hash":"05fd3e5b75f1b50f6eede1f544bbe7a8481e5097","modified":1361809529000},{"_id":"themes/hiker/node_modules/glob/test/bash-comparison.js","hash":"c7e27558c5870b5edc3bcd461c88f133fb22b1e2","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/cwd-test.js","hash":"3d7413c1706b868c4ee8730ecd58ebb87edcc137","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/mark.js","hash":"f28c2ca48f13937b0a202f6f08219c0ad5b81924","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/pause-resume.js","hash":"2dfb282ca01b1c5187ec0aa8793560c89ef32d51","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/root-nomount.js","hash":"13bdc59237d69e3fe0bbdea9d14a55b5c3cdeea7","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/nocase-nomagic.js","hash":"0c1f3e2cf40a95940f301925052226c4c278c9e4","modified":1361809186000},{"_id":"themes/hiker/node_modules/glob/test/zz-cleanup.js","hash":"cac3aa9dca8beaaffe9281f29ce2703a0211f345","modified":1358897151000},{"_id":"themes/hiker/node_modules/glob/test/root.js","hash":"4ea6f42a975120c5fd51613775174a8ab1ceeaad","modified":1358897151000},{"_id":"themes/hiker/node_modules/graceful-fs/test/open.js","hash":"cba0c1a5ea28e35bebe95e5dfeea93fc73540d90","modified":1371011144000},{"_id":"themes/hiker/node_modules/graceful-fs/test/ulimit.js","hash":"1b4b7cefd7fcaa3f78aab638a96c7c2f7aeb5cf9","modified":1371058145000},{"_id":"themes/hiker/node_modules/globule/lib/globule.js","hash":"618ff718047feb15254e5cf24ce5af4fd6dc1812","modified":1365709870000},{"_id":"themes/hiker/node_modules/globule/test/globule_test.js","hash":"4564e9adeb6bb1e1e67da9dc664a574d282de006","modified":1365707547000},{"_id":"themes/hiker/node_modules/grunt/internal-tasks/bump.js","hash":"7ce258496aaec202e8ce172a0b3e50d5aaf9d01f","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/internal-tasks/subgrunt.js","hash":"3b415376df01baa985a53878f5669fbea576776a","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/docs/copy-options.md","hash":"eb2247a7d7635f50c19edde354f03e0b271fa69f","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/docs/copy-examples.md","hash":"a43e07de5a9f49242c02803f0217f25c481fbffe","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/docs/overview.md","hash":"45a9f280ca24504dccdcb14ab79589d8cb71d59e","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt.js","hash":"ca781fe2be38dd38d6185e8bda929681fef5cd33","modified":1399664190000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/docs/copy-overview.md","hash":"1773dc725ac12c0ea3e85326d0d1b3d9e7ad3fd2","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/copy_test.js","hash":"82ddaa9fca306ec340635e6ebb3f919bfe2b4435","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/docs/clean-examples.md","hash":"321f291ac7eb4953f74557876788e6e204d3123e","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/tasks/copy.js","hash":"8db2e37633009a0bc3567f64d2b4f7a3e7a97f86","modified":1364328263000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/docs/clean-options.md","hash":"f448abca640f52214e679ba0198b1e3ab0e95ddd","modified":1373946235000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/docs/clean-overview.md","hash":"87b33d3d7b8deabf64925094163af88dfd10be69","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/docs/overview.md","hash":"a7974f178895c9b227914c4c90d07775b100999c","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/tasks/clean.js","hash":"5fa079752d19443367a39e1e5bf4b16ebc16881f","modified":1373946235000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_archive.js","hash":"4f7987eda505e028f7d6a6e5209441e0ef85c2d0","modified":1400491527000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/test/clean_test.js","hash":"7c7328553c6cb124d6b5c10e0a085fb0d471b894","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_clean.js","hash":"7880398fce630900dbb3f91753cb9b604e3a19ed","modified":1398687678000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_clone.js","hash":"1ae7facf595755859cf2a7c07b14ddfa7f3f49c6","modified":1403249632000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_checkout.js","hash":"68950ce4b334c226652ed6f448c78e99494e6338","modified":1400491998000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_merge.js","hash":"a74d60ede815dff0c4554ae68620734b1a797c3e","modified":1403525250000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_commit.js","hash":"4c1695bf3e0f3db5df6beb65b9a2c6c8982b5271","modified":1403154021000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_pull.js","hash":"9223bd9dcbcc57e955c04854abd1400c8aa54d5d","modified":1394606328000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_push.js","hash":"9a6066d24606308595505a47ed560315e0df420e","modified":1400491998000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_rebase.js","hash":"aa955d88c9329e31e599eed2c92bdcd821f0265d","modified":1398687678000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_reset.js","hash":"8c0df80201959704b5e75f38776b02393aa8fdc1","modified":1398687678000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_stash.js","hash":"90623ec7342c17757f70c3f6fc3caadb77afb6bc","modified":1398687678000},{"_id":"themes/hiker/node_modules/grunt-git/lib/commands.js","hash":"0e1c98db9e6a65f4f86e308eed70bca151bfb121","modified":1394606350000},{"_id":"themes/hiker/node_modules/grunt-git/lib/command_tag.js","hash":"7db9c98af4419e54573dd21bbdf9af2acdc6ca61","modified":1398687678000},{"_id":"themes/hiker/node_modules/grunt-git/tasks/git.js","hash":"5502de5a59ab9c12712633af74f15d12668e7e4d","modified":1403249632000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/test/index.js","hash":"72cc1aba54893536c22943deae22ff04439819d6","modified":1432671143000},{"_id":"themes/hiker/node_modules/iconv-lite/encodings/big5.js","hash":"59e5fcae2f129b09d9432dedf5b70505cc6b7cba","modified":1373851113000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/index.js","hash":"2f95a16f6bdc7745a5ead0842fd053522cbf42eb","modified":1399651531000},{"_id":"themes/hiker/node_modules/iconv-lite/encodings/gbk.js","hash":"e9e79e14f2cdd1039aafe9c967779b3ed5020bcf","modified":1373851113000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/test/index.js","hash":"814509b8ba9bf413763ee7df8c37d1eae5f118ec","modified":1450886402000},{"_id":"themes/hiker/node_modules/iconv-lite/encodings/singlebyte.js","hash":"2430737fa82b9beb1032b2495319325addca5379","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/generation/generate-big5-table.js","hash":"15a22de91844a507582afa9700dd27275a79e74e","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/cyrillic-test.js","hash":"187f9aff6992aacbd08411a337f891d37b9b248d","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/generation/generate-singlebyte.js","hash":"5de2c9b10c468c6016b70e16a8e449317eb95593","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/big5File.txt","hash":"3436d4f12831c6d14d9849f4aeaf7f6e337e0773","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/main-test.js","hash":"bb5b5ce9b6714685178cef4249d03a29dadfd503","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/gbk-test.js","hash":"6d522eee7746a96fb37a5c31797dcfedc15daca4","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/big5-test.js","hash":"0fe2ebde723caf8c730a509ef8d7c67b3c15e5ca","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/performance.js","hash":"8b6e8d0bcc1408cb22e2f2e11f9a04f80d30de8f","modified":1369516868000},{"_id":"themes/hiker/node_modules/hooker/dist/ba-hooker.js","hash":"f9b5b48e88a1df429688882546a074aefb67ab23","modified":1327894459000},{"_id":"themes/hiker/node_modules/iconv-lite/test/turkish-test.js","hash":"54a0d7f8fea844b78541a5d019dff06bf37287a0","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/test/greek-test.js","hash":"6b6882bf4648d4d9e081c70c5dcd78b8595649e4","modified":1373851113000},{"_id":"themes/hiker/node_modules/hooker/dist/ba-hooker.min.js","hash":"6cf4ad3546d824fbe25f66b1ee1fd51486c85ed4","modified":1327894459000},{"_id":"themes/hiker/node_modules/js-yaml/examples/custom_types.js","hash":"e49185f27da24f9d878d967b3d5cd21e1b99ef0b","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/examples/custom_types.yaml","hash":"4b5833b73d3f6d35520c0fba07a94e246272eeaf","modified":1366987222000},{"_id":"themes/hiker/node_modules/iconv-lite/test/gbkFile.txt","hash":"c095a2906fa6a7d71a8190d1d66c3678d2637cf8","modified":1322051475000},{"_id":"themes/hiker/node_modules/hooker/lib/hooker.js","hash":"8e27b6af4c39931dfca517a50dd3bd886ec746f0","modified":1327503204000},{"_id":"themes/hiker/node_modules/js-yaml/examples/dumper.js","hash":"2147f88a765068046f46a7d2cf1f0937449b0ed7","modified":1366987222000},{"_id":"themes/hiker/node_modules/hooker/test/hooker_test.js","hash":"c7413abf91cd1006681829913ce07c13df82980b","modified":1327870698000},{"_id":"themes/hiker/node_modules/js-yaml/examples/dumper.json","hash":"8bb8f301ec4f591e56cbf9848fe8807210b6ac38","modified":1366987222000},{"_id":"themes/hiker/node_modules/lodash/lodash.js","hash":"4bba0d83d0daaf993d10e1399d93c2f518b5e04b","modified":1356140414000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml.js","hash":"bf2d42d404f1659ad62d15bcf262c05dcf615048","modified":1366987222000},{"_id":"themes/hiker/node_modules/lru-cache/test/foreach.js","hash":"5493ce987892f9c740837c36acd5240d9cf93644","modified":1448413217000},{"_id":"themes/hiker/node_modules/js-yaml/examples/sample_document.js","hash":"9f8fa3a12991de01896acab2998109cf54282e27","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/examples/sample_document.yaml","hash":"d7ccb166f882439d1bc97b42fdc31e2bb4d801a5","modified":1366987222000},{"_id":"themes/hiker/node_modules/lru-cache/lib/lru-cache.js","hash":"d4091806568fef3089f4522f09d5976d91912dd4","modified":1448475000000},{"_id":"themes/hiker/node_modules/lru-cache/test/basic.js","hash":"caffd5539b398fb1f369ed259c14dc4d00eda244","modified":1448474452000},{"_id":"themes/hiker/node_modules/minimatch/test/brace-expand.js","hash":"a274bc9dea6fc8289ad997754bd58ee36bf47197","modified":1324537594000},{"_id":"themes/hiker/node_modules/lru-cache/test/memory-leak.js","hash":"5b5690f4e32c4d2fc501e7f408fdcfd25f8b4e3a","modified":1435688444000},{"_id":"themes/hiker/node_modules/minimatch/test/caching.js","hash":"310366ed1bb9228269562ca69f27534cfa611dcd","modified":1332887728000},{"_id":"themes/hiker/node_modules/minimatch/test/basic.js","hash":"91bf75896c5b86f7f8b312e2fab75fc38785371e","modified":1387171514000},{"_id":"themes/hiker/node_modules/minimatch/test/extglob-ending-with-state-char.js","hash":"bf57836fc4f7b64e8920baad6945880901a613c0","modified":1387223424000},{"_id":"themes/hiker/node_modules/lru-cache/test/serialize.js","hash":"6383a06c3f56cce6eb364b66f2301eea00db5828","modified":1448474452000},{"_id":"themes/hiker/node_modules/minimatch/test/defaults.js","hash":"681bc0bd4e4e1fc342418109294e4d151f992e58","modified":1332985301000},{"_id":"themes/hiker/node_modules/js-yaml/bin/js-yaml.js","hash":"53bede9c65e71860490461458ee5baae4efefe56","modified":1366987222000},{"_id":"themes/hiker/node_modules/nopt/examples/my-program.js","hash":"de3d4a6a7f350fd6846d3ae06334d1fafffc7054","modified":1317851223000},{"_id":"themes/hiker/node_modules/rimraf/test/setup.sh","hash":"a7dafdbc10717be56c98d42550c2bd85b8471c72","modified":1312833801000},{"_id":"themes/hiker/node_modules/nopt/bin/nopt.js","hash":"46110bf51a470f7413fb5da0abfe8790030b6762","modified":1317851223000},{"_id":"themes/hiker/node_modules/rimraf/test/test-async.js","hash":"7f6b6decc67742212d67529de9a2ee150bde37d0","modified":1312833666000},{"_id":"themes/hiker/node_modules/rimraf/test/run.sh","hash":"ad4825520114fcec855dae27491c0af1c61a22b8","modified":1399391468000},{"_id":"themes/hiker/node_modules/sigmund/test/basic.js","hash":"6424a3fd17afb57e34890c0c330ead99ceb5af25","modified":1344873467000},{"_id":"themes/hiker/node_modules/rimraf/test/test-sync.js","hash":"c84d98b3e885de4a279527831539660cefa23cb3","modified":1312833666000},{"_id":"themes/hiker/node_modules/nopt/lib/nopt.js","hash":"f53ca0f12e0125ecda5b8c13db24c9bd5a3f0150","modified":1317851223000},{"_id":"themes/hiker/node_modules/underscore.string/test/run-qunit.js","hash":"4faca6ac345dc4f9a0ab7fc3682575bbea2528d7","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/strings_standalone.js","hash":"3d7968ba71fc5040df11c009cde2a2a983632569","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/lib/underscore.string.js","hash":"c204ddb71d8a8c768a45267dc35a7cc2b6ebaabc","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/speed.js","hash":"6c8a486ff2c4a70a640f4b6abde46d39d7bce584","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test.html","hash":"59ba8455b0abcbcecea5af7dc9daece4621b88d1","modified":1373449276000},{"_id":"themes/hiker/node_modules/underscore.string/dist/underscore.string.min.js","hash":"4ececb13db18e636e63f9f903a95c8686214328e","modified":1373452312000},{"_id":"themes/hiker/source/css/_partial/archive.styl","hash":"28e78ec6e703417c50447c4710ad4bcf6cf48008","modified":1502121406680},{"_id":"themes/hiker/node_modules/underscore.string/test/test_standalone.html","hash":"86605f225d9d22a42e9df65360ee95dbd7ac98db","modified":1373449276000},{"_id":"themes/hiker/node_modules/underscore.string/test/strings.js","hash":"35fc5935e5d3de8943c64e1c5079bd0a5c7a0bfa","modified":1373452312000},{"_id":"themes/hiker/node_modules/which/bin/which","hash":"a57845c25b005b3298ba1482d3fe8fd988e0b7ea","modified":1312741868000},{"_id":"themes/hiker/source/css/_partial/article.styl","hash":"909c51f82d61a020d0cdafc80f8e5ea71646c9d1","modified":1502121406699},{"_id":"themes/hiker/source/css/_partial/comment.styl","hash":"f23dbf9c1224559314f7d10b7fee030a9ffab58a","modified":1502121406715},{"_id":"themes/hiker/source/css/_partial/header-post.styl","hash":"e95431443eb28d45390de733068f87134e5780da","modified":1502121406749},{"_id":"themes/hiker/source/css/_partial/footer.styl","hash":"ce9f600140d5cd246b59374f615c8a512bc5ecab","modified":1502121406730},{"_id":"themes/hiker/source/css/_partial/header.styl","hash":"4bbc6be125b55de743ad00a5ddf751eba1f617c4","modified":1502121406767},{"_id":"themes/hiker/source/css/_partial/highlight.styl","hash":"ae20f587f9905a684f60bee9e74570a413d4a6cb","modified":1502121406783},{"_id":"themes/hiker/source/css/_partial/mobile.styl","hash":"fcfbaf24634519063af46953e0eb733a8ada5556","modified":1502121406818},{"_id":"themes/hiker/node_modules/underscore.string/test/underscore.js","hash":"4291452b73960fbb7b83d181cd2fedbff1f386d1","modified":1373452312000},{"_id":"themes/hiker/source/css/_partial/sidebar-bottom.styl","hash":"36886d5436bfafbf980539be8dbc419631b8b6ee","modified":1502121406849},{"_id":"themes/hiker/source/css/_partial/sidebar-aside.styl","hash":"1b4caeb15892b2c34cc063065b9c408eb00216a6","modified":1502121406833},{"_id":"themes/hiker/source/css/_partial/sidebar.styl","hash":"e93ca6bb5b709accd667b939980ad39582fe062b","modified":1502121406866},{"_id":"themes/hiker/source/css/_partial/insight.styl","hash":"8cd23d8f0ce2d083dd7409a1a95315029070cbb8","modified":1502121406802},{"_id":"themes/hiker/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1502121406912},{"_id":"themes/hiker/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1502121406889},{"_id":"themes/hiker/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1502121406943},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1502121407083},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1502121406988},{"_id":"themes/hiker/source/css/images/mylogo1.jpg","hash":"0acf39dd4cf9a892281f8372d02d04373aeee62c","modified":1502121407143},{"_id":"themes/hiker/source/css/images/homelogo.jpg","hash":"4bfc9650c4fd6e60b09ae29f888a819cdf88e9fe","modified":1502121407126},{"_id":"themes/hiker/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1502121407178},{"_id":"themes/hiker/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1502121407407},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1502121407430},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1502121407521},{"_id":"source/_posts/VAET阅读稿/Visual-Encoding.png","hash":"5935dd958547fe68cb7a29d8d550cd42677b2906","modified":1507725898586},{"_id":"source/_posts/VAET阅读稿/TOS-map.png","hash":"108ea39d68d1e3cd045424a6cd52884875e1725a","modified":1506677643732},{"_id":"source/gallery/shoes.jpg","hash":"f589b44b91f582b1f279c1ac624645e08de75897","modified":1502123876534},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1502121407500},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1502121407467},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1502121407563},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/libpeerconnection.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1373470725000},{"_id":"themes/hiker/node_modules/findup-sync/test/fixtures/a.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1351803833000},{"_id":"themes/hiker/node_modules/findup-sync/test/fixtures/aaa.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1351803830000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/libpeerconnection.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1373532129000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/libpeerconnection.log","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1373532129000},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1502121407061},{"_id":"themes/hiker/source/js/d3.min.js","hash":"cd77ac7ae53a30b5d15be2cc9d32d2caff818087","modified":1500066194000},{"_id":"source/_posts/VAET阅读稿/VAET-overview.png","hash":"0a6d3b6d6f9d3b018ccd83e9faebf880f415d105","modified":1506677516061},{"_id":"source/_posts/VAET阅读稿/fig11.png","hash":"256cafcb0bc33def71b59e8e565f9890f29818b7","modified":1507795189292},{"_id":"themes/hiker/node_modules/argparse/lib/action/help.js","hash":"1e4b42c36b216cb0e3c79fb1e887a835e947355e","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/count.js","hash":"dcfbf45e6885e5bed742d231a14f8559ef353d33","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/append.js","hash":"2c0b080e3b955df141fe600f6e98551a5e05547c","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/argument/exclusive.js","hash":"c38a1586d7e145698239ccfd20c1645858d8ca6f","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/store.js","hash":"a2c72cb7a95cb97a4e83475ad29063a0ef322b3b","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/subparsers.js","hash":"e86f4e29ebc3ea3a1a705e9a229e8c98481ecd33","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/argument/group.js","hash":"ea26a609a1b4f0308b672c507880495689629ebd","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/version.js","hash":"9039a1f51c7c978f202b6302d6a61b0ce0b22145","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/help/added_formatters.js","hash":"096905e3eb47ba6addbe91cb339eecc753949e5c","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/argument/error.js","hash":"ebbd30aee8c24eca5643fa73dbf0963244d3bdb7","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/bower.json","hash":"e38a1cf256550770bed49a6324a2347386d276e4","modified":1416055370000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/.travis.yml","hash":"e9a0fd1f244a3b4a9b292714cd563bfac71e2aa4","modified":1416055370000},{"_id":"themes/hiker/node_modules/argparse/lib/help/formatter.js","hash":"4de986ab7f0255ead9b5d3f4c13060acf9f2eacd","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/component.json","hash":"be60b0b0df2fd2efc7f675082cfd4aa670ecb747","modified":1416055370000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/README.markdown","hash":"619fde05187f99b059fb15173db9a571ccb6f709","modified":1416055370000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/package.json","hash":"7fe3b7ee6622f7835691e8278640352b940b5b63","modified":1502121473298},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/gulpfile.js","hash":"32e37ce4b100f40c60adc9930c4903a7314f92f5","modified":1416055370000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/foo.js","hash":"0dfec71d7b188ace5590d9eef6aa34391295801e","modified":1373472169000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/.npmignore","hash":"66fb5c4102dee8a7952eb6fddf1699b7da8e1001","modified":1416055370000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/cake.js","hash":"192fec24c83ba2fe7fd2164916062b62aba28bcf","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/coffee-script.js","hash":"f9753fae5bd3491445fde95dad34ae1762091011","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/command.js","hash":"7d36e8cb75cb8914ef1e30059180e720bc367891","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/lexer.js","hash":"0254182f9b654cb3698b905aeb7a54e5b92f2c7a","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/browser.js","hash":"4423f640e2abc6084909684ed41fcd1ace7d9637","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/index.js","hash":"d23a352834a7a3ee247ea1fd26bfaac814bb8f3d","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/helpers.js","hash":"3426589fd8c47fd8f44ef88e3980973c6b0fb128","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/grammar.js","hash":"be5bd0ff0915b07f96d326ce2ea590b1a342cc83","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/repl.js","hash":"fc01ef7f75e6aaa052b992f2b5d2c637ecf5a77b","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/optparse.js","hash":"9d8f40a21ccbd9e811580887bbacb37ea3fe49b7","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/rewriter.js","hash":"cb1ea44353bdcf0c6360ce3f83fb0377f8b6995c","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/scope.js","hash":"2ead1098e199a7d4ad996bec05b2778eb7deebff","modified":1337099669000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/10-stderr.txt","hash":"09b203771aa78e22b0c59709a2f126aa8ab54114","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/10-stdout-stderr.txt","hash":"993088f87819e31b1ce2ea5ac71300955343d305","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/10-stdout.txt","hash":"c2d24f38ecae881032783bc2d45566b00bcd4bd0","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/100-stderr.txt","hash":"0231d229f37c3ac7a83b1efbdcfb3eab956ca64f","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/100-stdout-stderr.txt","hash":"ba4138ef0976213ac79172f9bc7f3ed840096922","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/100-stdout.txt","hash":"29c497636b27eb6bd92856adac923abbaa5f2c58","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/1000-stdout-stderr.txt","hash":"6c53beb52a1974cc3be94ff23391885d27a09e49","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/1000-stderr.txt","hash":"cad0c02e259a49bb1487aec3484cd23a77cd57f1","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/create-files.sh","hash":"a54259d548395ff90501a6ce5af14329128b36b8","modified":1385493531000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/.npmignore","hash":"8b894ec0b3bbc33011392ad9bafeb1df2634db45","modified":1372866257000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/1000-stdout.txt","hash":"862a205905c64a3b516d2cab0ca6dd2557046a83","modified":1385493531000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/log-broken.js","hash":"496a5ab7514d6bf689e20e999ace65595795e47e","modified":1385493531000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/LICENSE","hash":"4a1927e74796f06ac7e7a687ca6b44d39c65d8f4","modified":1311966493000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/package.json","hash":"a6bcc8d3b4677ade12be746e29faffb02ac6986e","modified":1502121473280},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/.npmignore","hash":"df0230e54e04f0f4739f4cdf671570dced4a1223","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/.travis.yml","hash":"b0e08ffb1a32bb17941785759a4154f995139ae8","modified":1393399375000},{"_id":"themes/hiker/node_modules/exit/test/fixtures/log.js","hash":"074a031032e9ea28c3e80195168e02be663f67e4","modified":1385493531000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/LICENSE","hash":"a042a6c4248c82d810b9b617958f222c0de0f6c2","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/README.md","hash":"db98f83f21fa7f9459e78270ed5457ffceeb67ee","modified":1399941882000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/minimatch.js","hash":"b1c4ad104b40c30dab77239ab61821d54bf14b18","modified":1399942015000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/LICENSE.txt","hash":"9c21585a158f39abcf1ae6e2c7f98cdd3a3d568e","modified":1430076638000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/README.md","hash":"af862ac74c2748081577030878c943e1ae9aeb64","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/package.json","hash":"fa9587527226a318bac4201a0f0d8bd242491f8e","modified":1502121473278},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/glob.js","hash":"6864fd02cb10c0a019afa98bb1f63f25f03851e4","modified":1393399612000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/package.json","hash":"e55c2abf8e6355fb26af149a6e0d818fc6496a49","modified":1502121473295},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/README.md","hash":"ce0f6ea6d448d8fdcf2832c3788821e857e2c550","modified":1430078503000},{"_id":"themes/hiker/node_modules/glob/node_modules/inherits/LICENSE","hash":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1440704194000},{"_id":"themes/hiker/node_modules/glob/node_modules/inherits/inherits.js","hash":"0e8b7c5a1e8020e3a93191c12bb0bd529dacfb6e","modified":1302136514000},{"_id":"themes/hiker/node_modules/glob/node_modules/inherits/README.md","hash":"baafb44348cace2d60b31a3663f43e856a7ba282","modified":1302136514000},{"_id":"themes/hiker/node_modules/glob/node_modules/inherits/package.json","hash":"022e2ab0ef88ef8777c8722f4a99e332ee658e22","modified":1502121473286},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/LICENSE.txt","hash":"1405d83ff498af3a9fc5bda1b076523e95c45904","modified":1427729364000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/package.json","hash":"826e7c8c8c4a20e9b45ecef0f3607afdcd0c1394","modified":1502121473290},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/cli.js","hash":"0131125f183bffc8f524f84b8a41903860b47729","modified":1399389581000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/README.md","hash":"dd442c502cd26ed6c47b83ab6fa0024c601ad346","modified":1427729993000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/config.js","hash":"b42171146d2e80591e882fcaaaabe87f9c4a1ca6","modified":1399904725000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/event.js","hash":"206d9794c9aac7b451b74f4851f7a936064af36b","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/fail.js","hash":"289a8f6592b94c6cc01a16612c483419db43e187","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/option.js","hash":"cd41f58261d42f1290614a1799f5e0ae59ff44b0","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/help.js","hash":"6f91747e4cbc7c0422ac7a1acb6027ad2f949257","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/file.js","hash":"5707d7bb25eae9b5f6d749da01a09163178b28ae","modified":1399664145000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/single.js","hash":"ae78d9691fd3c5cf6c14e0e6ad2bba3c09991545","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/task.js","hash":"a0a961413f5fe8491a7fa4a48f3590a1cff1f278","modified":1399664145000},{"_id":"themes/hiker/node_modules/grunt/lib/grunt/template.js","hash":"87b8e1aad9f328fe360649a17babbc77121980c0","modified":1399389581000},{"_id":"themes/hiker/node_modules/grunt/lib/util/task.js","hash":"0e2172bdecb4eb9a0d234d3ed8cac5e79282e290","modified":1399664396000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/fixtures/.hidden","hash":"bbc357cf5d8b12bc75cd6d697dc33db6d590ec43","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/fixtures/test.js","hash":"ae78d9691fd3c5cf6c14e0e6ad2bba3c09991545","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/Gemfile.lock","hash":"9236e4ffa7c8ca067369e9b77bd26bc850fd51ea","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/fixtures/test2.js","hash":"1097e0f6d57f485cca733b93e02903e1969f9e86","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/component.json","hash":"b929b12ac3a7bdf402fa87863621259a39a883c2","modified":1373890112000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/Gemfile","hash":"dab95a91b5a30ded482c35d9efbc00d33a9322aa","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/.travis.yml","hash":"e33e8d35cf94d67804af457d709d8db1d16f73ae","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/package.json","hash":"7ca3bbce201ee2ad49bdc49f48bc0aeafd8b05f9","modified":1502121473278},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/LICENSE.txt","hash":"9c21585a158f39abcf1ae6e2c7f98cdd3a3d568e","modified":1430076638000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/Rakefile","hash":"aebecba3b976b65bb74d63704f37d6f74d7419cf","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/README.markdown","hash":"d5862c720a95a582201ff26ff11bdf44911dde36","modified":1373890137000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/package.json","hash":"141a5fde68a5e17385a5976be5ad1329f1c178f3","modified":1502121473281},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/README.md","hash":"ce0f6ea6d448d8fdcf2832c3788821e857e2c550","modified":1430078503000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/LICENSE.txt","hash":"9c21585a158f39abcf1ae6e2c7f98cdd3a3d568e","modified":1430076638000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/.travis.yml","hash":"e33e8d35cf94d67804af457d709d8db1d16f73ae","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/Gemfile","hash":"dab95a91b5a30ded482c35d9efbc00d33a9322aa","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/README.md","hash":"ce0f6ea6d448d8fdcf2832c3788821e857e2c550","modified":1430078503000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/Gemfile.lock","hash":"9236e4ffa7c8ca067369e9b77bd26bc850fd51ea","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/package.json","hash":"5ce3ff465749dada2cc5e3b1f0261b77f80df6b9","modified":1502121473284},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/Rakefile","hash":"aebecba3b976b65bb74d63704f37d6f74d7419cf","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/component.json","hash":"b929b12ac3a7bdf402fa87863621259a39a883c2","modified":1373890112000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/package.json","hash":"567684653d5589685abf1467afb9587a7d567046","modified":1502121473286},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/README.markdown","hash":"d5862c720a95a582201ff26ff11bdf44911dde36","modified":1373890137000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/Gruntfile-execArgv-child.js","hash":"43e52894de367ccc3054bc5a12b1943283ba04c5","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/Gruntfile-print-text.js","hash":"ff78c7a71ec640d97a322ef16d44a5a4342bd080","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/exec.cmd","hash":"bd98738b7612db9ff9f8c689f1e7976e7ef6d663","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/Gruntfile-execArgv.js","hash":"98722db3df31a868c82e53cd73fd7d238df236ad","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/exec.sh","hash":"4d07d64d1c436b521d17794bd219e4fde651d325","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/spawn-multibyte.js","hash":"a9c874b79306cb4b16aaf33e0e74a425ca7c9987","modified":1397053407000},{"_id":"themes/hiker/node_modules/grunt-legacy-util/test/fixtures/spawn.js","hash":"6bb82176253c874a5a973330e9a7e77941f476c2","modified":1397053407000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/common.js","hash":"aa6880c2c2d4512cc3d1610a4f88771de0945265","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/exception.js","hash":"4b150c5aaa8d15c292c555eaa1c357cd24b2da07","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/mark.js","hash":"c31f189315110ac7e78ff37db1c3f4236a9dee73","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/loader.js","hash":"6e36b5b0809cc8aa141fe178c84bb8e9692846e2","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/dumper.js","hash":"a4007c42f40e70a8ba9cc0bba2fe598b4abcfe26","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/require.js","hash":"0810bf85ed6067da8140ee5467dfe96578f152c2","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type.js","hash":"d5b780ef4539d1ccdf9cc381e7ca5556a10b1c64","modified":1366987222000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/chaining.js","hash":"ce18270861bc5dc97fc6c3160a0887c7c32d46b6","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/arrays.js","hash":"af2673c3e10aeb96729a05027bcfbf4a4e6321f4","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/collections.js","hash":"9e9489886a3885fd17ec54eeef4c891be64deae7","modified":1373452312000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/schema.js","hash":"024b6c3898c7f52e1ac6f77d8e3e3c75b171d50b","modified":1366987222000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/speed.js","hash":"4ee4d8f743626528a6e4920332ccaa01c99ed661","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/temp_tests.html","hash":"c72202c306374de3297c50d3288c40d6cccfc863","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/test.html","hash":"d0a61570a14053d95422855c4454c9801de81722","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/functions.js","hash":"ec06bd7308e8a8dec38e94e16385c48da0285e71","modified":1373452312000},{"_id":"themes/hiker/source/css/images/sample.jpg","hash":"36b49a2f0183ac20207c44a8172e410e4d6865e6","modified":1502121407197},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/nodes.js","hash":"e3e62eb8fe829c0c76844cc77e9003d2339115e6","modified":1337099669000},{"_id":"themes/hiker/node_modules/coffee-script/lib/coffee-script/parser.js","hash":"ccae8ddbc6192bccb9a7600fde79f8d45fd97aff","modified":1337021135000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/temp.js","hash":"add234fcb75e4f1466a9676c3eacaceab43d4f36","modified":1373452312000},{"_id":"themes/hiker/node_modules/findup-sync/test/fixtures/a/foo.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1351803839000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/README.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1502121407027},{"_id":"source/_posts/JS函数式编程笔记1/范畴学.png","hash":"75c31a92a7cb1bf7d03ef36758e436fc40d8e6d2","modified":1512999713616},{"_id":"source/_posts/VAET阅读稿/VAET-system.png","hash":"ab5102ae7042052779658c7263f2343506a9aefb","modified":1506676289651},{"_id":"themes/hiker/node_modules/argparse/lib/action/store/constant.js","hash":"ee2f67ed3e7cd9474021add61f9f60bc80019a9d","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/append/constant.js","hash":"7fc947de30068badd953874f3f331705fa13cdaa","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/store/true.js","hash":"fb161bdcfab726b0fb8e8f806fd59cc5c9474224","modified":1417455549000},{"_id":"themes/hiker/node_modules/argparse/lib/action/store/false.js","hash":"2ce4c8417090063fe29d953b04b7c37ad52a1bc2","modified":1417455549000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/objects.js","hash":"c5e60f037b4e618e890def438bf60b19ca3ce6a6","modified":1373452312000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/test/brace-expand.js","hash":"a274bc9dea6fc8289ad997754bd58ee36bf47197","modified":1324537594000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/test/caching.js","hash":"310366ed1bb9228269562ca69f27534cfa611dcd","modified":1332887728000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/test/basic.js","hash":"91bf75896c5b86f7f8b312e2fab75fc38785371e","modified":1387171514000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/test/extglob-ending-with-state-char.js","hash":"bf57836fc4f7b64e8920baad6945880901a613c0","modified":1387223424000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/examples/g.js","hash":"c5e6ed35ba98b68b876256e9fa7b15fbac79aa27","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/examples/usr-local.js","hash":"a82d273b8acbbb0728d1d8ba541f406ecb91d612","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/00-setup.js","hash":"78da07aaaadb2b79467173cd94329dd64130de62","modified":1393399375000},{"_id":"themes/hiker/node_modules/argparse/node_modules/underscore.string/lib/underscore.string.js","hash":"a5739e6f03fb1a1955b0b3fda7e93c357e05d448","modified":1416055370000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/minimatch/test/defaults.js","hash":"4f30a9b91bcada2aad8a258a3e4abd25e6d7dfa1","modified":1399941975000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/bash-results.json","hash":"962f4955b403eeb5a3ef3870993a62c5df4cea90","modified":1393399375000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/utility.js","hash":"f58d2a42ecda0f6c29d94dcad63f21a456255f9e","modified":1373452312000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/cwd-test.js","hash":"3d7413c1706b868c4ee8730ecd58ebb87edcc137","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/bash-comparison.js","hash":"c7e27558c5870b5edc3bcd461c88f133fb22b1e2","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/mark.js","hash":"cee3e39b2ccf9795360074d5f6a87ecd62d00241","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/globstar-match.js","hash":"f6ec5cde93f347e296c634002a99e73780e4c48e","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/nocase-nomagic.js","hash":"cf9482221bae9e253da8262f159135cd13fbb19d","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/root-nomount.js","hash":"13bdc59237d69e3fe0bbdea9d14a55b5c3cdeea7","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/new-glob-optional-options.js","hash":"15b4092f72eb8237a73abaa69ddea1f9bcf686bd","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/root.js","hash":"4ea6f42a975120c5fd51613775174a8ab1ceeaad","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/readme-issue.js","hash":"7dfaf81e1592bfa3f05e53560af46093053dca33","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/zz-cleanup.js","hash":"cac3aa9dca8beaaffe9281f29ce2703a0211f345","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/pause-resume.js","hash":"2dfb282ca01b1c5187ec0aa8793560c89ef32d51","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/glob/test/stat.js","hash":"01545c380b4167f3bbc36a6bc8285d1158ded7de","modified":1393399375000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/dist/lodash.min.js","hash":"8d11f71e6c10af1baa47f42b06c229b372367985","modified":1430076022000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/dist/lodash.compat.min.js","hash":"1f42aff57795b266ad770029b34f9c91e910c910","modified":1430076089000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/dist/lodash.underscore.min.js","hash":"0422117b2293765b5497d3cf6ec88a2574d53216","modified":1430076000000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/dist/lodash.compat.min.js","hash":"c13a20ea314c9ac4ad3e1777e2e28005aad0b092","modified":1427729433000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_files/test.js","hash":"ae78d9691fd3c5cf6c14e0e6ad2bba3c09991545","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_files/test2.js","hash":"1097e0f6d57f485cca733b93e02903e1969f9e86","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_mix/test.js","hash":"ae78d9691fd3c5cf6c14e0e6ad2bba3c09991545","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_mix/test2.js","hash":"1097e0f6d57f485cca733b93e02903e1969f9e86","modified":1363299392000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/dist/lodash.min.js","hash":"3400d1295b3f94d65c3dd30f338298c22f50b817","modified":1427729433000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_flatten/test.js","hash":"ae78d9691fd3c5cf6c14e0e6ad2bba3c09991545","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_flatten/one.js","hash":"0c9b71f364d1b4a0da2037c8d663abb778b4b865","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_flatten/test2.js","hash":"1097e0f6d57f485cca733b93e02903e1969f9e86","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/fixtures/folder_one/one.js","hash":"0c9b71f364d1b4a0da2037c8d663abb778b4b865","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_flatten/two.js","hash":"9971ef6e49cf03ae10f142377dcf12e69a6d4063","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/test/fixtures/sample_short/short.txt","hash":"8b26a8dfbc8d252f3d74e996895d5f03e764e5eb","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-clean/test/fixtures/sample_long/long.txt","hash":"8b26a8dfbc8d252f3d74e996895d5f03e764e5eb","modified":1373659716000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/fixtures/folder_two/two.js","hash":"9971ef6e49cf03ae10f142377dcf12e69a6d4063","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/run-qunit.js","hash":"7a2f386db195670628c3d66d229327ebc02dab40","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/strings_standalone.js","hash":"d68f872a3522bf6898981a4a95cfaf2f709c66e1","modified":1373532016000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/dist/lodash.underscore.min.js","hash":"27c1f9f657ba13277ef48b5cb425c75ea69ff20b","modified":1427729433000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test.html","hash":"59ba8455b0abcbcecea5af7dc9daece4621b88d1","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/speed.js","hash":"1679135dec8aa60e5e8ef8a99c689eec1af61389","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/dist/underscore.string.min.js","hash":"d9d13d390cbc4422b16a519532491467d938f618","modified":1373889747000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_standalone.html","hash":"86605f225d9d22a42e9df65360ee95dbd7ac98db","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/strings.js","hash":"13f980b52f29d393d3dbc5e70aa4f6a7f31d72bd","modified":1373889747000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/underscore.js","hash":"934a4bcb13026508e16223cf9f00bb4a38c321f1","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/lib/underscore.string.js","hash":"78cd42aa76fc0aedf1d4c87acf5d0dc65df09af1","modified":1373890128000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.min.js","hash":"8d11f71e6c10af1baa47f42b06c229b372367985","modified":1430076022000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.compat.min.js","hash":"1f42aff57795b266ad770029b34f9c91e910c910","modified":1430076089000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/dist/lodash.compat.min.js","hash":"1f42aff57795b266ad770029b34f9c91e910c910","modified":1430076089000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.underscore.min.js","hash":"0422117b2293765b5497d3cf6ec88a2574d53216","modified":1430076000000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/dist/lodash.min.js","hash":"8d11f71e6c10af1baa47f42b06c229b372367985","modified":1430076022000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/run-qunit.js","hash":"7a2f386db195670628c3d66d229327ebc02dab40","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/lib/underscore.string.js","hash":"78cd42aa76fc0aedf1d4c87acf5d0dc65df09af1","modified":1373890128000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/dist/underscore.string.min.js","hash":"d9d13d390cbc4422b16a519532491467d938f618","modified":1373889747000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/speed.js","hash":"1679135dec8aa60e5e8ef8a99c689eec1af61389","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/strings_standalone.js","hash":"d68f872a3522bf6898981a4a95cfaf2f709c66e1","modified":1373532016000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_standalone.html","hash":"86605f225d9d22a42e9df65360ee95dbd7ac98db","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test.html","hash":"59ba8455b0abcbcecea5af7dc9daece4621b88d1","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/dist/lodash.underscore.min.js","hash":"0422117b2293765b5497d3cf6ec88a2574d53216","modified":1430076000000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/schema/minimal.js","hash":"805fb3d8cf67eab956b3ca7b9e6a6f0c5d307cf8","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/schema/default.js","hash":"8044658b9819a8ba6f9ce5d2dff92158b5ddd195","modified":1366987222000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/strings.js","hash":"13f980b52f29d393d3dbc5e70aa4f6a7f31d72bd","modified":1373889747000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/underscore.js","hash":"934a4bcb13026508e16223cf9f00bb4a38c321f1","modified":1373531985000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/schema/safe.js","hash":"078e46ef59d7560c819dd647bb0e1b5aa78359a8","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/binary.js","hash":"0f620a424c5eaa075e48a4c0699a0274c0e6f868","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/bool.js","hash":"950edff77d2fd89801136a177ba61636e840602b","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/float.js","hash":"79d53b075433d0712e7c25e68877adcbce8e3a9c","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/merge.js","hash":"7e46411bdaebc381a1100e8d52d9e7774ca0a680","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/map.js","hash":"06e8061824254235ec97c182555cf8368ab5db1c","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/int.js","hash":"1e5ade9ef96dda4d2b481d4559b82b7cc6a0ee9d","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/null.js","hash":"2b6764c4e0a6f5802a1c52a37915708d7b7fed97","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/seq.js","hash":"c887d46220e1eae2038e32f252aaa3f6c5790e1a","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/omap.js","hash":"d207a0273cce987105ce8ad3cfb1bf912c9ef02f","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/pairs.js","hash":"455e1d0a2306d026f082b632f5513ae3c830ded8","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/set.js","hash":"ae4bf4a01b9e308bb6d44eb25f57995fd058a472","modified":1366987222000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/vendor/jquery.js","hash":"3dc9f7c2642efff4482e68c9d9df874bf98f5bcb","modified":1373452312000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/vendor/qunit.css","hash":"408d35c1e8b7c2ae5e3fa631462864ecdce1719f","modified":1373452312000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/str.js","hash":"0ea939e7f2ba84e8a8a23a3202245f2f853fa73f","modified":1366987222000},{"_id":"themes/hiker/source/css/images/mylogo.jpg","hash":"aab98c76c4754d1f9b469a4139f9e0249e644c2c","modified":1501932277568},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/timestamp.js","hash":"75a00471994d193e70ecfa0b3d607e62f07f24a4","modified":1366987222000},{"_id":"themes/hiker/node_modules/findup-sync/test/fixtures/a/b/bar.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1351803848000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/css/baz.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/css/qux.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/js/bar.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/js/foo.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/deep/deep.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/lodash.js","hash":"16c0086b96a8445c20936b8053d7b8f62638af76","modified":1430076530000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/vendor/jslitmus.js","hash":"141af7191b0f8be947e616cab9816e68231230ca","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/lodash.js","hash":"16c0086b96a8445c20936b8053d7b8f62638af76","modified":1430076530000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/lodash.js","hash":"16c0086b96a8445c20936b8053d7b8f62638af76","modified":1430076530000},{"_id":"themes/hiker/source/preview/preview-mobile.png","hash":"7679a50aef93fc364cbcee4a52cd84604bf741b1","modified":1502121408041},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/dist/lodash.compat.js","hash":"41eb73dd63d0732df32e1a8483976c3abd973b29","modified":1427729642000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/dist/lodash.underscore.js","hash":"e9355375a05fbc20cec7de1f84e05c70485ddb91","modified":1430076558000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/dist/lodash.js","hash":"864d4955dce02ae26b48f8c0846e5c62d8c9bdb1","modified":1427729525000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_mix/folder_one/one.js","hash":"0c9b71f364d1b4a0da2037c8d663abb778b4b865","modified":1363299392000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_mix/folder_two/two.js","hash":"9971ef6e49cf03ae10f142377dcf12e69a6d4063","modified":1363299392000},{"_id":"themes/hiker/node_modules/globule/node_modules/lodash/dist/lodash.underscore.js","hash":"61d3db53b8b711131d87f5d74c2bdf4754e0e933","modified":1427729433000},{"_id":"themes/hiker/node_modules/grunt-contrib-copy/test/expected/copy_test_v0.1.0/folder_one/one.js","hash":"0c9b71f364d1b4a0da2037c8d663abb778b4b865","modified":1363299392000},{"_id":"themes/hiker/node_modules/underscore.string/test/test_underscore/vendor/qunit.js","hash":"9fdd85f6ac05336e7717802784dad8ef5ccadb9d","modified":1373452312000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/chaining.js","hash":"be55887afb5f05515fc969449c166e924965a0e9","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/arrays.js","hash":"7e65b546ec41d89756176cca0662bee605054f3a","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/collections.js","hash":"735c1cc88fc76df7c4a73c1735d29728404ffe4c","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/index.html","hash":"a39a08f5018ae1b231aedc06363ae08acc0b19bc","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/functions.js","hash":"51f27a367d732c718ad869b9ed2ab15bc7cadc0b","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.underscore.js","hash":"e9355375a05fbc20cec7de1f84e05c70485ddb91","modified":1430076558000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/dist/lodash.underscore.js","hash":"e9355375a05fbc20cec7de1f84e05c70485ddb91","modified":1430076558000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/speed.js","hash":"395b81dd34c9267a308c055547e28d8d02198e56","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/objects.js","hash":"ce9b3cc415da73c599fecfb63cb1359439fee3f8","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/chaining.js","hash":"be55887afb5f05515fc969449c166e924965a0e9","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/arrays.js","hash":"7e65b546ec41d89756176cca0662bee605054f3a","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/index.html","hash":"a39a08f5018ae1b231aedc06363ae08acc0b19bc","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/utility.js","hash":"39dc56c4a644fb09006b6d967109ab9f94466bd6","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/speed.js","hash":"395b81dd34c9267a308c055547e28d8d02198e56","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/collections.js","hash":"735c1cc88fc76df7c4a73c1735d29728404ffe4c","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/functions.js","hash":"51f27a367d732c718ad869b9ed2ab15bc7cadc0b","modified":1373531985000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/js/function.js","hash":"91b532771acaf28949c35373da64d107f95104d8","modified":1366987222000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/objects.js","hash":"ce9b3cc415da73c599fecfb63cb1359439fee3f8","modified":1373531985000},{"_id":"themes/hiker/node_modules/iconv-lite/encodings/table/big5.js","hash":"1ff76554de139c9bf8c22efbbc2fe67c0f3ede7e","modified":1373851113000},{"_id":"themes/hiker/node_modules/iconv-lite/encodings/table/gbk.js","hash":"4ce82c9c942a460dfdbcad5aa3a6e0ae12ae1525","modified":1322134156000},{"_id":"themes/hiker/source/css/images/pose.jpg","hash":"4d394a662e7d6d2de6a4598688c7cd3dba5c2fa3","modified":1502121407165},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/dist/lodash.compat.js","hash":"e78674568f46c8728bddac05a88790a997192b55","modified":1430076516000},{"_id":"themes/hiker/node_modules/findup-sync/node_modules/lodash/dist/lodash.js","hash":"1996aca565068a71066e2af03101a073f0cf12b6","modified":1430076546000},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/deep/deeper/deeper.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/utility.js","hash":"39dc56c4a644fb09006b6d967109ab9f94466bd6","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.compat.js","hash":"e78674568f46c8728bddac05a88790a997192b55","modified":1430076516000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.js","hash":"1996aca565068a71066e2af03101a073f0cf12b6","modified":1430076546000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/dist/lodash.compat.js","hash":"e78674568f46c8728bddac05a88790a997192b55","modified":1430076516000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/lodash/dist/lodash.js","hash":"1996aca565068a71066e2af03101a073f0cf12b6","modified":1430076546000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js","hash":"85a40561e34cf12dd05ba7dd3d1456cc02550d3b","modified":1366987222000},{"_id":"themes/hiker/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js","hash":"79965543010a6a1c935e8a0232035ca3750be2f3","modified":1366987222000},{"_id":"themes/hiker/source/css/images/home-bg.jpg","hash":"e8dcdb6e03bd02d831bae593feccb7028c9dc5e9","modified":1502121407112},{"_id":"themes/hiker/source/css/images/home-bg2.jpg","hash":"e01bb369fa9d3460d43056dbb249d94f9ae87b43","modified":1492828647112},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/qunit.css","hash":"1cf8b4bfff4b27bfdff531b3f51a34ba1bc7c236","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/jslitmus.js","hash":"141af7191b0f8be947e616cab9816e68231230ca","modified":1373449276000},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/qunit.js","hash":"0d8fdaeec180bcc70af77f58ca31d99f6bded201","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/vendor/qunit.css","hash":"1cf8b4bfff4b27bfdff531b3f51a34ba1bc7c236","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/vendor/jslitmus.js","hash":"141af7191b0f8be947e616cab9816e68231230ca","modified":1373449276000},{"_id":"themes/hiker/source/preview/code-theme.jpg","hash":"8c8512fd04e6106033656d10e92d51de76cca6d8","modified":1502121408009},{"_id":"themes/hiker/node_modules/globule/test/fixtures/expand/deep/deeper/deepest/deepest.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1363894196000},{"_id":"source/images/线性代数应该这样学1.jpg","hash":"37587ebb5e7b7c86ae81cc169dd641513de2ced6","modified":1504880053247},{"_id":"themes/hiker/node_modules/esprima/test/test.js","hash":"b77d6a46ae3f584d198a0e3c5092e4fa07cdb7f6","modified":1377750976000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/vendor/qunit.js","hash":"0d8fdaeec180bcc70af77f58ca31d99f6bded201","modified":1373531985000},{"_id":"themes/hiker/source/preview/preview-pc.png","hash":"2471e0697938721e4c5d7c66940e165c59a31a0f","modified":1502121408071},{"_id":"themes/hiker/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/jquery.js","hash":"0d7896e2bb23f88e26e52b22a075350b354df447","modified":1373531985000},{"_id":"themes/hiker/node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/vendor/jquery.js","hash":"0d7896e2bb23f88e26e52b22a075350b354df447","modified":1373531985000},{"_id":"public/content.json","hash":"8cf70676ed27a6230c09b25dc96dd4a93bef223c","modified":1521547618767},{"_id":"public/tags/study/index.html","hash":"c5f6655fa1645ee03ee1772fcd9ff7fd449e5be9","modified":1521547619152},{"_id":"public/tags/life/index.html","hash":"cddce264542cc32f058bfd009da39716c3ba7baa","modified":1521547619182},{"_id":"public/tags/network/index.html","hash":"5ae3a40eae65d23bf1c5574d7e5369b6477b1242","modified":1521547619183},{"_id":"public/tags/Database/index.html","hash":"b8949ec604c70a736581cb771ff450f6e140c0ed","modified":1521547619183},{"_id":"public/tags/ML/index.html","hash":"933aa87d2bbaa24d2fdf144156db38eb5dbbc375","modified":1521547619183},{"_id":"public/tags/JS/index.html","hash":"0235cc31118d9cfa2dd9a1ccaf80a2a15bef4f9e","modified":1521547619184},{"_id":"public/tags/FP/index.html","hash":"8cd7c49aa785b8f5ea454103deab638d5674e0a2","modified":1521547619184},{"_id":"public/tags/数据可视化/index.html","hash":"db09d9a6696dc277c8825ac750a4eec35ae7aee0","modified":1521547619184},{"_id":"public/tags/论文阅读/index.html","hash":"f7edd1e264986288d63f1571159e410010a88a04","modified":1521547619184},{"_id":"public/tags/summary/index.html","hash":"d158f63c284f652012db939d02a34adbbfccb831","modified":1521547619184},{"_id":"public/tags/web/index.html","hash":"fd53a51d53a0c04c760c7067304c742292fd9e2e","modified":1521547619184},{"_id":"public/tags/系统结构/index.html","hash":"cbd30ff3abfc17e491a6ff864263b6bd1525d2c9","modified":1521547619184},{"_id":"public/about/index.html","hash":"c4f850ddda0b81f71c98d615db7a3fdb4370ac0c","modified":1521547619184},{"_id":"public/archives/index.html","hash":"5d10e5a38c3f52f130cc2be93003c8d63d529bd3","modified":1521547619184},{"_id":"public/tags/index.html","hash":"a8681f1cc4ada5a7eb84c95e4d3b445c2c039eb3","modified":1521547619184},{"_id":"public/categories/index.html","hash":"45db51350a876cf7094ead96faaa2540f52713c7","modified":1521547619184},{"_id":"public/2018/02/07/JS函数式编程笔记2/index.html","hash":"485862fde2f4ad86534cb32c0d828ff8d942be72","modified":1521547619184},{"_id":"public/2018/03/07/2018新年与考研/index.html","hash":"6055df8673f319c485bea9172ed856cc56f4870f","modified":1521547619184},{"_id":"public/2017/12/26/IEEE802.11无线LANs概述/index.html","hash":"36c7831d45d7ed6e1555225bb96b45ad59d8dddf","modified":1521547619184},{"_id":"public/2017/12/11/JS函数式编程笔记1/index.html","hash":"a256b36da4b0047bfba0c1a3b0aa432547d1d7a0","modified":1521547619184},{"_id":"public/2017/11/11/计算机网络实验/index.html","hash":"f49be6c3250d1a24f953ed62317f205037e520ff","modified":1521547619184},{"_id":"public/2017/11/05/2017-11-5/index.html","hash":"cda801aeafd8757535ba6a5f609bacda88a90b78","modified":1521547619184},{"_id":"public/2017/10/26/Install-MySQL5-7/index.html","hash":"0fdf9228285607586f9db54082d30fe7e552943e","modified":1521547619185},{"_id":"public/2017/10/11/VAET阅读稿/index.html","hash":"2c844ce6a8e896ad678e877a125fade6189ae2eb","modified":1521547619185},{"_id":"public/2017/09/28/计算机系统结构/index.html","hash":"119981983943e8e1fcdca52e5e4c4fd67d1002e2","modified":1521547619185},{"_id":"public/2017/09/24/人工智能发展报告/index.html","hash":"d69ae0f0fb6d16e4a76e727436c929a24bb255af","modified":1521547619185},{"_id":"public/2017/08/20/最近一周总结/index.html","hash":"fabb0d3bb4d38683a7b5137aae6a1f9a41243513","modified":1521547619185},{"_id":"public/2017/09/08/从《线性代数应该这样学》到《Redis的设计与实现》/index.html","hash":"c452e6ba5583cde94de20c423ab50aaa94e366ab","modified":1521547619185},{"_id":"public/2017/08/11/关于未来方向学习的思考/index.html","hash":"d3854c0e9897081ec1e1dd466a94a10453fffe7a","modified":1521547619185},{"_id":"public/2017/09/13/暑假机器学习总结/index.html","hash":"21eff9ccef417fc48c580baa04496298c677fece","modified":1521547619186},{"_id":"public/2017/08/10/机器学习里的一些小概念/index.html","hash":"da30879db476b053d419fd51496967d2096afed0","modified":1521547619186},{"_id":"public/2017/08/08/k-means/index.html","hash":"9c973055b2a829cfdbaf5b9d9ff05574705723e1","modified":1521547619186},{"_id":"public/2017/08/08/欢迎，刚搭建好的博客/index.html","hash":"0550378daff682f050144db72b4b0e2e583e92fb","modified":1521547619186},{"_id":"public/archives/page/2/index.html","hash":"c9e93b92ce0bf39f9010958c5053746d6df798aa","modified":1521547619186},{"_id":"public/archives/2017/index.html","hash":"1f34c07abd3e895686df704bc952a2c353445102","modified":1521547619186},{"_id":"public/2017/08/08/《Web API的设计与开发》读书笔记/index.html","hash":"09ea605ad3d9b676c23c9277fb08a94378efc880","modified":1521547619186},{"_id":"public/archives/2017/08/index.html","hash":"67e093770633ad027f7c5317dbfcaea4c17910c4","modified":1521547619186},{"_id":"public/archives/2017/09/index.html","hash":"b785c43e80ed8b19f0527390eeacca731c176551","modified":1521547619186},{"_id":"public/archives/2017/page/2/index.html","hash":"b9a5be1fe7ec724c56de262e53da44e5735b9557","modified":1521547619186},{"_id":"public/archives/2017/10/index.html","hash":"73be46761fabd3de313d174ba2e9865e7d4fccbf","modified":1521547619186},{"_id":"public/archives/2017/11/index.html","hash":"d48ead5cd089a0182f5c5861379de426c8a6860f","modified":1521547619186},{"_id":"public/archives/2018/index.html","hash":"452877f722dfd346369570b3cae3f7bb1522ae89","modified":1521547619186},{"_id":"public/archives/2017/12/index.html","hash":"7b1ba0ed251f7cdfb98247bd3201c61b2c73fefa","modified":1521547619186},{"_id":"public/archives/2018/03/index.html","hash":"c060a20882a11aa180605a3a60b7d9ddb7cbe50e","modified":1521547619186},{"_id":"public/archives/2018/02/index.html","hash":"c52314335dcf4e36601c6b26c5c2bf9e3e4f2a42","modified":1521547619186},{"_id":"public/index.html","hash":"bde4aea37b052ce9fa5d9ffdb38b9b5c9a5b0a54","modified":1521547619187},{"_id":"public/page/2/index.html","hash":"bd21aa820b0add6e12412b60e46406fe4fd84e8a","modified":1521547619187},{"_id":"public/page/4/index.html","hash":"d5676388ad242546237d20307ee47709e8f62b4f","modified":1521547619187},{"_id":"public/page/3/index.html","hash":"0c146402a7f914326c107b4d707843b7a198d8e3","modified":1521547619187},{"_id":"public/categories/考研/index.html","hash":"50192097a10d7c6a5d35e9f68c899abb4f390701","modified":1521547619209},{"_id":"public/categories/life/index.html","hash":"c59880d43c13e194199067d3d1ded1c024fba372","modified":1521547619209},{"_id":"public/categories/考研/CS/index.html","hash":"b82adbf5555ef384c3cb4cee0452a4bde7533f6e","modified":1521547619209},{"_id":"public/2018/03/20/2018学习和复习/index.html","hash":"ec4b539c2ed98800cb18d577a2ca791ba9fd6989","modified":1521547619209},{"_id":"public/categories/study/index.html","hash":"9294f1493c07ad6a50a7b069e05b6a510d509bf0","modified":1521547619209},{"_id":"public/gallery/music1.jpg","hash":"b1e26e83b9d038e91c27f436997fc697b1680856","modified":1521547619222},{"_id":"public/gallery/little-girl.jpg","hash":"d73f0122778c1625a141f2537759e80a23ea3f84","modified":1521547619222},{"_id":"public/gallery/music2.jpg","hash":"33d498bbad9a3350f35fc2df7207936bd0f8bf49","modified":1521547619222},{"_id":"public/gallery/niagara.jpg","hash":"ef5ed9bcc839cfdabaa596086fbbc89dc2337684","modified":1521547619222},{"_id":"public/gallery/code-highlight.png","hash":"80e0318ffb139ffb0d960ed10613161854c65aa5","modified":1521547619222},{"_id":"public/gallery/smartphone.jpg","hash":"d03ea985e9550dcdc7a2729f975f82baeedf99bd","modified":1521547619223},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1521547619223},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1521547619223},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1521547619223},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1521547619223},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1521547619223},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1521547619223},{"_id":"public/preview/browser-support.png","hash":"a6d8498553550c6b18a8f22bcd2f53c993c7d677","modified":1521547619223},{"_id":"public/preview/donation-btn.png","hash":"ad78b1605b162e2399a1cdc5232f6a44298dba6c","modified":1521547619223},{"_id":"public/preview/theme-color.png","hash":"725130ceea5e41bb2cc60b31e45275b4b0cc77b3","modified":1521547619223},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1521547619223},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1521547619223},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1521547619224},{"_id":"public/css/images/mylogo1.jpg","hash":"0acf39dd4cf9a892281f8372d02d04373aeee62c","modified":1521547619224},{"_id":"public/css/images/homelogo.jpg","hash":"4bfc9650c4fd6e60b09ae29f888a819cdf88e9fe","modified":1521547619224},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1521547619224},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1521547619224},{"_id":"public/2017/12/26/IEEE802.11无线LANs概述/BBS.jpg","hash":"47473d70e9aa1d824e744ba2801ce6ccfda5df7b","modified":1521547619224},{"_id":"public/2017/12/26/IEEE802.11无线LANs概述/中央基站.jpg","hash":"d62dc25402e8f1ef2c0c36387d3e3f0f38eb36c1","modified":1521547619224},{"_id":"public/2018/02/07/JS函数式编程笔记2/functor映射2.png","hash":"8a02e555182eb65c4683d7d8e984d385ee3b43f6","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/Navicat使用期限.png","hash":"44a9c588fbb1ab98c051b6a1594111320bd83670","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/Navicat使用界面.png","hash":"b0ec26c42dc7073171ecb0f8167dc5f4667ac072","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/mysql启动.png","hash":"c831dd980eeaef21c46443487390f8686597a1bc","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/mysql安装.png","hash":"e72d16b4db2137c49cf965a292b54dbbc23c700e","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/mysql安装路径.png","hash":"7ace4992962207ad64f3a67a1c6fa0db6c42fd19","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/mysql目录结构.png","hash":"7266aa139e47bc21e10a632149181cdaa1c36076","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/mysql配置完成.png","hash":"910ed89a5169eab6a6c076e515c29b60492bdd5c","modified":1521547619224},{"_id":"public/2017/10/26/Install-MySQL5-7/操作界面.png","hash":"c7fb104144c22084fe85eb2d24106952d2f293e8","modified":1521547619225},{"_id":"public/2017/10/26/Install-MySQL5-7/查看mysql字符编码.png","hash":"845976a25ef31e3b0dbf4c725e2a58cbdef32cec","modified":1521547619225},{"_id":"public/2017/09/28/计算机系统结构/3-11.jpg","hash":"d4a80d52141d6fe35acac9107b677d2c1bf4daf2","modified":1521547619225},{"_id":"public/2017/11/11/计算机网络实验/DNS-request.png","hash":"40612c4a20494d0cd5f83d58173f74cbc2a2eebf","modified":1521547619225},{"_id":"public/2017/10/11/VAET阅读稿/fig12.png","hash":"f3db366a3ba03846dfe43c5601d9dbd9fdafb3e0","modified":1521547619225},{"_id":"public/gallery/markdown.jpg","hash":"5f2921d97b4c68ec029cbaea17bdc106108cd857","modified":1521547621705},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1521547621705},{"_id":"public/2017/12/26/IEEE802.11无线LANs概述/802.11.jpg","hash":"77ce7c6d972aaf0aa89ea05bf8bc260bc6ae33c0","modified":1521547621711},{"_id":"public/2018/02/07/JS函数式编程笔记2/functor映射.png","hash":"8a28f15f63fbfa5e42414a2653e9ecf84d7a0040","modified":1521547621711},{"_id":"public/2018/02/07/JS函数式编程笔记2/functor映射实例.png","hash":"4e8963a1ec55d4ff4d8fa72705d97717e919315d","modified":1521547621711},{"_id":"public/2017/11/11/计算机网络实验/DNS-header.png","hash":"1e4cd5492288fff80818e4778dc46ed55e412cb4","modified":1521547621711},{"_id":"public/2017/11/11/计算机网络实验/DNS-response.png","hash":"d411ad4d2eae1adcb330a8c5e5a7cb3f08f94793","modified":1521547621711},{"_id":"public/2017/10/11/VAET阅读稿/confusion-matrix.png","hash":"d4dee8a74d7f1b07f25f81419fbe663279590f48","modified":1521547621711},{"_id":"public/2017/10/11/VAET阅读稿/decision-tree.png","hash":"5887331291434165ce3cb425f7480caecb4d05b4","modified":1521547621712},{"_id":"public/2017/10/11/VAET阅读稿/hierarchical-tree.png","hash":"3926154838b6bc365eaed603988e5d5d7c5eabce","modified":1521547621712},{"_id":"public/2017/10/11/VAET阅读稿/salient-transactions.png","hash":"4e95061dcf9e8af1319ddc233c52c677487177d3","modified":1521547621712},{"_id":"public/css/archive.css","hash":"17cc72203cad1b0be66008d662c7494507aaee8b","modified":1521547621809},{"_id":"public/css/header-post.css","hash":"3f6d1f5593a353b4b05a67ee14e04ec9c986db21","modified":1521547621809},{"_id":"public/css/home.css","hash":"2a7bfef438468b5b8be3f84ea6818156d371077d","modified":1521547621810},{"_id":"public/css/vdonate.css","hash":"bca2d291a71e7358654c51f23e8bfb467b2bc8b2","modified":1521547621810},{"_id":"public/css/dialog.css","hash":"5e0333adf3f496e0d443767fe228a1d4b1a2bafc","modified":1521547621810},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1521547621810},{"_id":"public/js/home.js","hash":"e403c3290d76c5f58571cbfe4414236e41a7ac94","modified":1521547621810},{"_id":"public/js/dialog.js","hash":"01e8b337c1721e0486fd5044f98b233e84ba1985","modified":1521547621810},{"_id":"public/js/insight.js","hash":"f79ab175d1c8c4fb59328ee4fd9eb95808eb0be5","modified":1521547621810},{"_id":"public/js/scripts.js","hash":"e06a8948375df71cbf77abf8617db438ece811b3","modified":1521547621811},{"_id":"public/js/totop.js","hash":"29bb40144ac238d22b25d59df465aff8dc38bfd0","modified":1521547621811},{"_id":"public/js/vdonate.js","hash":"5738414c642d30e43943a69287b3d25a0b6be135","modified":1521547621811},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1521547621811},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1521547621811},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1521547621811},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1521547621811},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1521547621811},{"_id":"public/css/style.css","hash":"2c66ac247ae795191290fb986024919b4399fd14","modified":1521547621811},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1521547621811},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1521547621811},{"_id":"public/js/bootstrap.js","hash":"3b965a36a6b08854ad6eddedf85c5319fd392b4a","modified":1521547621812},{"_id":"public/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1521547621812},{"_id":"public/css/bootstrap.css","hash":"64fdc2e7c3f8a164d21c5632b5adbbb9990ea802","modified":1521547621812},{"_id":"public/js/d3.min.js","hash":"cd77ac7ae53a30b5d15be2cc9d32d2caff818087","modified":1521547621812},{"_id":"public/gallery/guitarist.jpg","hash":"36b49a2f0183ac20207c44a8172e410e4d6865e6","modified":1521547621812},{"_id":"public/gallery/salt-lake.jpg","hash":"75f95771de904d94b675e967f2f07114641bcdc2","modified":1521547621812},{"_id":"public/css/images/sample.jpg","hash":"36b49a2f0183ac20207c44a8172e410e4d6865e6","modified":1521547621812},{"_id":"public/2017/10/11/VAET阅读稿/visual-organization.png","hash":"ddf63d5386f71c56e0edc34d0e0df5f28adce15f","modified":1521547621812},{"_id":"public/2017/10/11/VAET阅读稿/feature-extraction.png","hash":"beb8fec07cab227deb28c4ea842213432ad78f8c","modified":1521547621813},{"_id":"public/2017/12/11/JS函数式编程笔记1/compose.png","hash":"ae1f8436e43c0ed5fb257359921b853d48a2d2c8","modified":1521547621813},{"_id":"public/2017/11/11/计算机网络实验/DNS-format.png","hash":"ef1510ecbcde8f46d75a97802dbb64b77a62b84a","modified":1521547621813},{"_id":"public/2017/11/11/计算机网络实验/DNS-not-such-name.png","hash":"178429e7f2241286cc0e4b5358939f39e1cdfe04","modified":1521547621813},{"_id":"public/2017/10/11/VAET阅读稿/Knotlines.png","hash":"7a52d62f0e22ae43c40d7ba1a71f6a7dbd1c54fb","modified":1521547621813},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1521547621823},{"_id":"public/2017/10/11/VAET阅读稿/Visual-Encoding.png","hash":"5935dd958547fe68cb7a29d8d550cd42677b2906","modified":1521547621823},{"_id":"public/2017/10/11/VAET阅读稿/TOS-map.png","hash":"108ea39d68d1e3cd045424a6cd52884875e1725a","modified":1521547621823},{"_id":"public/css/images/mylogo.jpg","hash":"aab98c76c4754d1f9b469a4139f9e0249e644c2c","modified":1521547621828},{"_id":"public/2017/10/11/VAET阅读稿/VAET-overview.png","hash":"0a6d3b6d6f9d3b018ccd83e9faebf880f415d105","modified":1521547621828},{"_id":"public/2017/10/11/VAET阅读稿/fig11.png","hash":"256cafcb0bc33def71b59e8e565f9890f29818b7","modified":1521547621828},{"_id":"public/gallery/shoes.jpg","hash":"f589b44b91f582b1f279c1ac624645e08de75897","modified":1521547621933},{"_id":"public/preview/preview-mobile.png","hash":"7679a50aef93fc364cbcee4a52cd84604bf741b1","modified":1521547621981},{"_id":"public/css/images/pose.jpg","hash":"4d394a662e7d6d2de6a4598688c7cd3dba5c2fa3","modified":1521547621982},{"_id":"public/2017/10/11/VAET阅读稿/VAET-system.png","hash":"ab5102ae7042052779658c7263f2343506a9aefb","modified":1521547621982},{"_id":"public/2017/12/11/JS函数式编程笔记1/范畴学.png","hash":"75c31a92a7cb1bf7d03ef36758e436fc40d8e6d2","modified":1521547621983},{"_id":"public/css/images/home-bg.jpg","hash":"e8dcdb6e03bd02d831bae593feccb7028c9dc5e9","modified":1521547622157},{"_id":"public/css/images/home-bg2.jpg","hash":"e01bb369fa9d3460d43056dbb249d94f9ae87b43","modified":1521547622157},{"_id":"public/preview/code-theme.jpg","hash":"8c8512fd04e6106033656d10e92d51de76cca6d8","modified":1521547622175},{"_id":"public/images/线性代数应该这样学1.jpg","hash":"37587ebb5e7b7c86ae81cc169dd641513de2ced6","modified":1521547622206},{"_id":"public/preview/preview-pc.png","hash":"2471e0697938721e4c5d7c66940e165c59a31a0f","modified":1521547622206}],"Category":[{"name":"考研","_id":"cjezm5y6h00046svsgkggh0d4"},{"name":"life","_id":"cjezm5y7f000b6svs8pa2pgpw"},{"name":"study","_id":"cjezm5y8e000l6svs791mvnui"},{"name":"CS","parent":"cjezm5y6h00046svsgkggh0d4","_id":"cjezm5y90000r6svsypfuoepy"}],"Data":[],"Page":[{"date":"2017-08-07T06:58:08.000Z","comments":1,"_content":"\n# Hiker\n\n[![Build Status](https://travis-ci.org/iTimeTraveler/hexo-theme-hiker.svg?branch=master)](https://travis-ci.org/iTimeTraveler/hexo-theme-hiker)   [![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/LICENSE)\n\n\nAn attractive, exquisite theme for [Hexo]. named \"Hiker\", short for \"HikerNews\".  \n\n[**☞ Live Preview**](https://itimetraveler.github.io/hexo-theme-hiker/)  |  [**✎ Hiker 中文版使用文档**](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/README.cn.md)\n\n\n![Desktop Preview](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png)\n![Post Preview](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/article-chrome.png)\n![Mobile Preview](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/preview-mobile.png?raw=true)\n\n<!--more-->\n\n## Installation\n\n 1. Get it from GitHub\n\n ```shell\n $ git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker\n ```\n 2. Enable\n\n Modify `theme` setting in `_config.yml` to `hiker`.\n ```\n # Extensions\n ## Plugins: http://hexo.io/plugins/\n ## Themes: http://hexo.io/themes/\n theme: hiker\n ```\n 3. Update\n\n ```shell\n $ cd themes/Hiker\n $ git pull\n ```\n\n## Configuration\n\n### Theme configuration example\n\n``` yml\n# ---------------------------------------------------------------\n# Site Information Settings\n# ---------------------------------------------------------------\n\n# Header Menu\nmenu:\n  Home: /\n  Archives: archives\n  Categories: categories\n  Tags: tags\n  About: about\nrss: /atom.xml\n\nsince: 2013\n\n# Set default keywords (Use a comma to separate)\nkeywords: \"\"\n\n# Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.\navatar: css/images/mylogo.jpg\n\n\n# Homepage\n# eg. home_background_image: css/images/home-bg.jpg\nhome_background_image: css/images/home-bg.jpg\nhome_logo_image:\n  enable: false\n  border: false\n  url: css/images/homelogo.jpg\n\n\n# AboutPage background\nabout_big_image: css/images/pose.jpg\n\n\n# Content\nexcerpt_link: Read More\nfancybox: true\n\n\n# Sidebar\nsidebar: right\nwidgets:\n- category\n- tag\n- tagcloud\n- archive\n- recent_posts\n\n\n# comment ShortName, you can choose only ONE to display.\nduoshuo_shortname: iTimeTraveler\ndisqus_shortname:\n\n\n# Code Highlight theme\n# Available value:\n#    default | normal | night | night eighties | night blue | night bright\n# https://github.com/chriskempson/tomorrow-theme\nhighlight_theme: default\n\n\n# Article theme color\n# Available value:\n#    random | orange | blue | red | green | black\ntheme_color: random\n\n\n# display widgets at the bottom of index pages (pagination == 2)\nindex_widgets:\n# - category\n# - tagcloud\n# - archive\n\n\n# widget behavior\narchive_type: 'monthly'\nshow_count: true\n\n# Google Webmaster tools verification setting\n# See: https://www.google.com/webmasters/\ngoogle_site_verification:\nbaidu_site_verification:\nqihu_site_verification:\n\n# Miscellaneous\ngoogle_analytics:\ngauges_analytics:\ntwitter:\ngoogle_plus:\nfb_admins:\nfb_app_id:\n```\n\n- **menu** - Navigation menu\n- **rss** - RSS link\n- **excerpt_link** - \"Read More\" link at the bottom of excerpted articles. `false` to hide the link.\n- **fancybox** - Enable [Fancybox]\n- **sidebar** - Sidebar style. You can choose `left`, `right`, `bottom` or `false`.\n- **widgets** - Widgets displaying in sidebar\n- **google_analytics** - Google Analytics ID\n- **favicon** - Favicon path\n- **twitter** - Twiiter ID\n- **google_plus** - Google+ ID\n\n## Features\n\n### Homepage background\n\nYou could place the image file in `YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images` directory. and modify `home_background_image` in hiker/_config.yml. \n\n```yml\n# Homepage\n# eg. home_background_image: css/images/home-bg.jpg\nhome_background_image: css/images/home-bg.jpg\n```\n\nIf you DON'T want any image as your homepage background, just set `home_background_image` empty in hiker/_config.yml, then you have an default homepage with **random decorative pattern**.\n\n![](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/home-no-background1.png)\n\n\n### Code Highlight Theme\n\nHiker use [Tomorrow Theme](https://github.com/chriskempson/tomorrow-theme) for your code block. We have six options in total: `default`, `normal`, `night`, `night blue`, `night bright`, `night eighties`\n\n![code `default` theme Preview](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/code-theme-default.png)\n\nAbove preview picture is default theme. the image below show other five Highlight themes.\n\n![code themes](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/code-theme.jpg?raw=true)\n\nModify `highlight_theme` in hiker/_config.yml.\n\n```yml\n# Code Highlight theme\n# Available value:\n#    default | normal | night | night eighties | night blue | night bright\n# https://github.com/chriskempson/tomorrow-theme\nhighlight_theme: default\n```\n\n### Blog Theme Color\n\nHiker provide five color themes for your blog.\n\n![theme colors](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/theme-color.png?raw=true)\n\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #fb6d19; border-radius: 3px; vertical-align: middle;\"></span> orange\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #00aced; border-radius: 3px; vertical-align: middle;\"></span> blue\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #f03838; border-radius: 3px; vertical-align: middle;\"></span> red\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #39aa56; border-radius: 3px; vertical-align: middle;\"></span> green\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #404040; border-radius: 3px; vertical-align: middle;\"></span> black\n\nYou can modify `theme_color` in hiker/_config.yml.\n\n```yml\n# Article theme color\n# Available value:\n#    random | orange | blue | red | green | black\ntheme_color: random\n```\n\n### Night mode\n\nJust for article reading. In article page, you can click the **logo image of header** to switch to Night mode.\n\n![](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/night-mode.gif)\n\n\n### Search\n\nHiker use `Insight Search` to help you search anything inside your site without any third-party plugin.\n\n```yml\n# Search\nsearch:\n    insight: true # you need to install `hexo-generator-json-content` before using Insight Search\n    swiftype: # enter swiftype install key here\n    baidu: false # you need to disable other search engines to use Baidu search, options: true, false\n```\n\n> Attention: You need to install `hexo-generator-json-content` before using Insight Search.\n\n```bash\n$ npm install -S hexo-generator-json-content\n```\n\n### Fancybox\n\nHiker uses [Fancybox] to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos.\n\n```\n![img caption](img url)\n\n{% fancybox img_url [img_thumbnail] [img_caption] %}\n```\n\n### Sidebar\n\nYou can put your sidebar in left side, right side or bottom of your site by editing `sidebar` setting.\nHiker provides 5 built-in widgets:\n\n- category\n- tag\n- tagcloud\n- archives\n- recent_posts\n\nAll of them are enabled by default. You can edit them in `widget` setting.\n\n### Comment support\n\nHiker has native support for DuoShuo & Disqus comment systems. Modify the following snippets to hiker `hiker/_config.yml`:\n\n```yml\n# comment ShortName, you can choose only ONE to display.\nduoshuo_shortname: iTimeTraveler\ndisqus_shortname: \n```\n\n## Browser support\n\n![](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/browser-support.png?raw=true)\n\n\n## Contributing\n\nAll kinds of contributions (enhancements, new features, documentation & code improvements, issues & bugs reporting) are welcome.\n\nLooking forward to your pull request.\n\n[Hexo]: https://hexo.io/\n[Fancybox]: http://fancyapps.com/fancybox/\n[Font Awesome]: http://fontawesome.io/","source":"about/index.md","raw":"---\ndate: 2017-08-07 14:58:08\ncomments: true\n---\n\n# Hiker\n\n[![Build Status](https://travis-ci.org/iTimeTraveler/hexo-theme-hiker.svg?branch=master)](https://travis-ci.org/iTimeTraveler/hexo-theme-hiker)   [![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/LICENSE)\n\n\nAn attractive, exquisite theme for [Hexo]. named \"Hiker\", short for \"HikerNews\".  \n\n[**☞ Live Preview**](https://itimetraveler.github.io/hexo-theme-hiker/)  |  [**✎ Hiker 中文版使用文档**](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/README.cn.md)\n\n\n![Desktop Preview](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png)\n![Post Preview](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/article-chrome.png)\n![Mobile Preview](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/preview-mobile.png?raw=true)\n\n<!--more-->\n\n## Installation\n\n 1. Get it from GitHub\n\n ```shell\n $ git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker\n ```\n 2. Enable\n\n Modify `theme` setting in `_config.yml` to `hiker`.\n ```\n # Extensions\n ## Plugins: http://hexo.io/plugins/\n ## Themes: http://hexo.io/themes/\n theme: hiker\n ```\n 3. Update\n\n ```shell\n $ cd themes/Hiker\n $ git pull\n ```\n\n## Configuration\n\n### Theme configuration example\n\n``` yml\n# ---------------------------------------------------------------\n# Site Information Settings\n# ---------------------------------------------------------------\n\n# Header Menu\nmenu:\n  Home: /\n  Archives: archives\n  Categories: categories\n  Tags: tags\n  About: about\nrss: /atom.xml\n\nsince: 2013\n\n# Set default keywords (Use a comma to separate)\nkeywords: \"\"\n\n# Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.\navatar: css/images/mylogo.jpg\n\n\n# Homepage\n# eg. home_background_image: css/images/home-bg.jpg\nhome_background_image: css/images/home-bg.jpg\nhome_logo_image:\n  enable: false\n  border: false\n  url: css/images/homelogo.jpg\n\n\n# AboutPage background\nabout_big_image: css/images/pose.jpg\n\n\n# Content\nexcerpt_link: Read More\nfancybox: true\n\n\n# Sidebar\nsidebar: right\nwidgets:\n- category\n- tag\n- tagcloud\n- archive\n- recent_posts\n\n\n# comment ShortName, you can choose only ONE to display.\nduoshuo_shortname: iTimeTraveler\ndisqus_shortname:\n\n\n# Code Highlight theme\n# Available value:\n#    default | normal | night | night eighties | night blue | night bright\n# https://github.com/chriskempson/tomorrow-theme\nhighlight_theme: default\n\n\n# Article theme color\n# Available value:\n#    random | orange | blue | red | green | black\ntheme_color: random\n\n\n# display widgets at the bottom of index pages (pagination == 2)\nindex_widgets:\n# - category\n# - tagcloud\n# - archive\n\n\n# widget behavior\narchive_type: 'monthly'\nshow_count: true\n\n# Google Webmaster tools verification setting\n# See: https://www.google.com/webmasters/\ngoogle_site_verification:\nbaidu_site_verification:\nqihu_site_verification:\n\n# Miscellaneous\ngoogle_analytics:\ngauges_analytics:\ntwitter:\ngoogle_plus:\nfb_admins:\nfb_app_id:\n```\n\n- **menu** - Navigation menu\n- **rss** - RSS link\n- **excerpt_link** - \"Read More\" link at the bottom of excerpted articles. `false` to hide the link.\n- **fancybox** - Enable [Fancybox]\n- **sidebar** - Sidebar style. You can choose `left`, `right`, `bottom` or `false`.\n- **widgets** - Widgets displaying in sidebar\n- **google_analytics** - Google Analytics ID\n- **favicon** - Favicon path\n- **twitter** - Twiiter ID\n- **google_plus** - Google+ ID\n\n## Features\n\n### Homepage background\n\nYou could place the image file in `YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images` directory. and modify `home_background_image` in hiker/_config.yml. \n\n```yml\n# Homepage\n# eg. home_background_image: css/images/home-bg.jpg\nhome_background_image: css/images/home-bg.jpg\n```\n\nIf you DON'T want any image as your homepage background, just set `home_background_image` empty in hiker/_config.yml, then you have an default homepage with **random decorative pattern**.\n\n![](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/home-no-background1.png)\n\n\n### Code Highlight Theme\n\nHiker use [Tomorrow Theme](https://github.com/chriskempson/tomorrow-theme) for your code block. We have six options in total: `default`, `normal`, `night`, `night blue`, `night bright`, `night eighties`\n\n![code `default` theme Preview](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/code-theme-default.png)\n\nAbove preview picture is default theme. the image below show other five Highlight themes.\n\n![code themes](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/code-theme.jpg?raw=true)\n\nModify `highlight_theme` in hiker/_config.yml.\n\n```yml\n# Code Highlight theme\n# Available value:\n#    default | normal | night | night eighties | night blue | night bright\n# https://github.com/chriskempson/tomorrow-theme\nhighlight_theme: default\n```\n\n### Blog Theme Color\n\nHiker provide five color themes for your blog.\n\n![theme colors](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/theme-color.png?raw=true)\n\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #fb6d19; border-radius: 3px; vertical-align: middle;\"></span> orange\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #00aced; border-radius: 3px; vertical-align: middle;\"></span> blue\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #f03838; border-radius: 3px; vertical-align: middle;\"></span> red\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #39aa56; border-radius: 3px; vertical-align: middle;\"></span> green\n- <span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #404040; border-radius: 3px; vertical-align: middle;\"></span> black\n\nYou can modify `theme_color` in hiker/_config.yml.\n\n```yml\n# Article theme color\n# Available value:\n#    random | orange | blue | red | green | black\ntheme_color: random\n```\n\n### Night mode\n\nJust for article reading. In article page, you can click the **logo image of header** to switch to Night mode.\n\n![](https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/night-mode.gif)\n\n\n### Search\n\nHiker use `Insight Search` to help you search anything inside your site without any third-party plugin.\n\n```yml\n# Search\nsearch:\n    insight: true # you need to install `hexo-generator-json-content` before using Insight Search\n    swiftype: # enter swiftype install key here\n    baidu: false # you need to disable other search engines to use Baidu search, options: true, false\n```\n\n> Attention: You need to install `hexo-generator-json-content` before using Insight Search.\n\n```bash\n$ npm install -S hexo-generator-json-content\n```\n\n### Fancybox\n\nHiker uses [Fancybox] to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos.\n\n```\n![img caption](img url)\n\n{% fancybox img_url [img_thumbnail] [img_caption] %}\n```\n\n### Sidebar\n\nYou can put your sidebar in left side, right side or bottom of your site by editing `sidebar` setting.\nHiker provides 5 built-in widgets:\n\n- category\n- tag\n- tagcloud\n- archives\n- recent_posts\n\nAll of them are enabled by default. You can edit them in `widget` setting.\n\n### Comment support\n\nHiker has native support for DuoShuo & Disqus comment systems. Modify the following snippets to hiker `hiker/_config.yml`:\n\n```yml\n# comment ShortName, you can choose only ONE to display.\nduoshuo_shortname: iTimeTraveler\ndisqus_shortname: \n```\n\n## Browser support\n\n![](https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/browser-support.png?raw=true)\n\n\n## Contributing\n\nAll kinds of contributions (enhancements, new features, documentation & code improvements, issues & bugs reporting) are welcome.\n\nLooking forward to your pull request.\n\n[Hexo]: https://hexo.io/\n[Fancybox]: http://fancyapps.com/fancybox/\n[Font Awesome]: http://fontawesome.io/","updated":"2017-08-08T03:13:49.514Z","path":"about/index.html","title":"","layout":"page","_id":"cjezm5y6a00016svsj3mnw6la","content":"<h1 id=\"Hiker\"><a href=\"#Hiker\" class=\"headerlink\" title=\"Hiker\"></a>Hiker</h1><p><a href=\"https://travis-ci.org/iTimeTraveler/hexo-theme-hiker\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/iTimeTraveler/hexo-theme-hiker.svg?branch=master\" alt=\"Build Status\"></a>   <a href=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/LICENSE\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/license-MIT-blue.svg\" alt=\"GitHub license\"></a></p>\n<p>An attractive, exquisite theme for <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>. named “Hiker”, short for “HikerNews”.  </p>\n<p><a href=\"https://itimetraveler.github.io/hexo-theme-hiker/\" target=\"_blank\" rel=\"noopener\"><strong>☞ Live Preview</strong></a>  |  <a href=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\"><strong>✎ Hiker 中文版使用文档</strong></a></p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png\" alt=\"Desktop Preview\"><br><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/article-chrome.png\" alt=\"Post Preview\"><br><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/preview-mobile.png?raw=true\" alt=\"Mobile Preview\"></p>\n<a id=\"more\"></a>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><ol>\n<li><p>Get it from GitHub</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker</div></pre></td></tr></table></figure>\n</li>\n<li><p>Enable</p>\n<p>Modify <code>theme</code> setting in <code>_config.yml</code> to <code>hiker</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: http://hexo.io/plugins/</div><div class=\"line\">## Themes: http://hexo.io/themes/</div><div class=\"line\">theme: hiker</div></pre></td></tr></table></figure>\n</li>\n<li><p>Update</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> cd themes/Hiker</div><div class=\"line\"><span class=\"meta\">$</span> git pull</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h2><h3 id=\"Theme-configuration-example\"><a href=\"#Theme-configuration-example\" class=\"headerlink\" title=\"Theme configuration example\"></a>Theme configuration example</h3><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></div><div class=\"line\"><span class=\"comment\"># Site Information Settings</span></div><div class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Header Menu</span></div><div class=\"line\"><span class=\"attr\">menu:</span></div><div class=\"line\"><span class=\"attr\">  Home:</span> <span class=\"string\">/</span></div><div class=\"line\"><span class=\"attr\">  Archives:</span> <span class=\"string\">archives</span></div><div class=\"line\"><span class=\"attr\">  Categories:</span> <span class=\"string\">categories</span></div><div class=\"line\"><span class=\"attr\">  Tags:</span> <span class=\"string\">tags</span></div><div class=\"line\"><span class=\"attr\">  About:</span> <span class=\"string\">about</span></div><div class=\"line\"><span class=\"attr\">rss:</span> <span class=\"string\">/atom.xml</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">since:</span> <span class=\"number\">2013</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Set default keywords (Use a comma to separate)</span></div><div class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.</span></div><div class=\"line\"><span class=\"attr\">avatar:</span> <span class=\"string\">css/images/mylogo.jpg</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Homepage</span></div><div class=\"line\"><span class=\"comment\"># eg. home_background_image: css/images/home-bg.jpg</span></div><div class=\"line\"><span class=\"attr\">home_background_image:</span> <span class=\"string\">css/images/home-bg.jpg</span></div><div class=\"line\"><span class=\"attr\">home_logo_image:</span></div><div class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">false</span></div><div class=\"line\"><span class=\"attr\">  border:</span> <span class=\"literal\">false</span></div><div class=\"line\"><span class=\"attr\">  url:</span> <span class=\"string\">css/images/homelogo.jpg</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># AboutPage background</span></div><div class=\"line\"><span class=\"attr\">about_big_image:</span> <span class=\"string\">css/images/pose.jpg</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Content</span></div><div class=\"line\"><span class=\"attr\">excerpt_link:</span> <span class=\"string\">Read</span> <span class=\"string\">More</span></div><div class=\"line\"><span class=\"attr\">fancybox:</span> <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Sidebar</span></div><div class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"string\">right</span></div><div class=\"line\"><span class=\"attr\">widgets:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">tag</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">tagcloud</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent_posts</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># comment ShortName, you can choose only ONE to display.</span></div><div class=\"line\"><span class=\"attr\">duoshuo_shortname:</span> <span class=\"string\">iTimeTraveler</span></div><div class=\"line\"><span class=\"attr\">disqus_shortname:</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Code Highlight theme</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    default | normal | night | night eighties | night blue | night bright</span></div><div class=\"line\"><span class=\"comment\"># https://github.com/chriskempson/tomorrow-theme</span></div><div class=\"line\"><span class=\"attr\">highlight_theme:</span> <span class=\"string\">default</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Article theme color</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    random | orange | blue | red | green | black</span></div><div class=\"line\"><span class=\"attr\">theme_color:</span> <span class=\"string\">random</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># display widgets at the bottom of index pages (pagination == 2)</span></div><div class=\"line\"><span class=\"attr\">index_widgets:</span></div><div class=\"line\"><span class=\"comment\"># - category</span></div><div class=\"line\"><span class=\"comment\"># - tagcloud</span></div><div class=\"line\"><span class=\"comment\"># - archive</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># widget behavior</span></div><div class=\"line\"><span class=\"attr\">archive_type:</span> <span class=\"string\">'monthly'</span></div><div class=\"line\"><span class=\"attr\">show_count:</span> <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Google Webmaster tools verification setting</span></div><div class=\"line\"><span class=\"comment\"># See: https://www.google.com/webmasters/</span></div><div class=\"line\"><span class=\"attr\">google_site_verification:</span></div><div class=\"line\"><span class=\"attr\">baidu_site_verification:</span></div><div class=\"line\"><span class=\"attr\">qihu_site_verification:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Miscellaneous</span></div><div class=\"line\"><span class=\"attr\">google_analytics:</span></div><div class=\"line\"><span class=\"attr\">gauges_analytics:</span></div><div class=\"line\"><span class=\"attr\">twitter:</span></div><div class=\"line\"><span class=\"attr\">google_plus:</span></div><div class=\"line\"><span class=\"attr\">fb_admins:</span></div><div class=\"line\"><span class=\"attr\">fb_app_id:</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>menu</strong> - Navigation menu</li>\n<li><strong>rss</strong> - RSS link</li>\n<li><strong>excerpt_link</strong> - “Read More” link at the bottom of excerpted articles. <code>false</code> to hide the link.</li>\n<li><strong>fancybox</strong> - Enable <a href=\"http://fancyapps.com/fancybox/\" target=\"_blank\" rel=\"noopener\">Fancybox</a></li>\n<li><strong>sidebar</strong> - Sidebar style. You can choose <code>left</code>, <code>right</code>, <code>bottom</code> or <code>false</code>.</li>\n<li><strong>widgets</strong> - Widgets displaying in sidebar</li>\n<li><strong>google_analytics</strong> - Google Analytics ID</li>\n<li><strong>favicon</strong> - Favicon path</li>\n<li><strong>twitter</strong> - Twiiter ID</li>\n<li><strong>google_plus</strong> - Google+ ID</li>\n</ul>\n<h2 id=\"Features\"><a href=\"#Features\" class=\"headerlink\" title=\"Features\"></a>Features</h2><h3 id=\"Homepage-background\"><a href=\"#Homepage-background\" class=\"headerlink\" title=\"Homepage background\"></a>Homepage background</h3><p>You could place the image file in <code>YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images</code> directory. and modify <code>home_background_image</code> in hiker/_config.yml. </p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Homepage</span></div><div class=\"line\"><span class=\"comment\"># eg. home_background_image: css/images/home-bg.jpg</span></div><div class=\"line\"><span class=\"attr\">home_background_image:</span> <span class=\"string\">css/images/home-bg.jpg</span></div></pre></td></tr></table></figure>\n<p>If you DON’T want any image as your homepage background, just set <code>home_background_image</code> empty in hiker/_config.yml, then you have an default homepage with <strong>random decorative pattern</strong>.</p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/home-no-background1.png\" alt=\"\"></p>\n<h3 id=\"Code-Highlight-Theme\"><a href=\"#Code-Highlight-Theme\" class=\"headerlink\" title=\"Code Highlight Theme\"></a>Code Highlight Theme</h3><p>Hiker use <a href=\"https://github.com/chriskempson/tomorrow-theme\" target=\"_blank\" rel=\"noopener\">Tomorrow Theme</a> for your code block. We have six options in total: <code>default</code>, <code>normal</code>, <code>night</code>, <code>night blue</code>, <code>night bright</code>, <code>night eighties</code></p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/code-theme-default.png\" alt=\"code `default` theme Preview\"></p>\n<p>Above preview picture is default theme. the image below show other five Highlight themes.</p>\n<p><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/code-theme.jpg?raw=true\" alt=\"code themes\"></p>\n<p>Modify <code>highlight_theme</code> in hiker/_config.yml.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Code Highlight theme</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    default | normal | night | night eighties | night blue | night bright</span></div><div class=\"line\"><span class=\"comment\"># https://github.com/chriskempson/tomorrow-theme</span></div><div class=\"line\"><span class=\"attr\">highlight_theme:</span> <span class=\"string\">default</span></div></pre></td></tr></table></figure>\n<h3 id=\"Blog-Theme-Color\"><a href=\"#Blog-Theme-Color\" class=\"headerlink\" title=\"Blog Theme Color\"></a>Blog Theme Color</h3><p>Hiker provide five color themes for your blog.</p>\n<p><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/theme-color.png?raw=true\" alt=\"theme colors\"></p>\n<ul>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #fb6d19; border-radius: 3px; vertical-align: middle;\"></span> orange</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #00aced; border-radius: 3px; vertical-align: middle;\"></span> blue</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #f03838; border-radius: 3px; vertical-align: middle;\"></span> red</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #39aa56; border-radius: 3px; vertical-align: middle;\"></span> green</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #404040; border-radius: 3px; vertical-align: middle;\"></span> black</li>\n</ul>\n<p>You can modify <code>theme_color</code> in hiker/_config.yml.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Article theme color</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    random | orange | blue | red | green | black</span></div><div class=\"line\"><span class=\"attr\">theme_color:</span> <span class=\"string\">random</span></div></pre></td></tr></table></figure>\n<h3 id=\"Night-mode\"><a href=\"#Night-mode\" class=\"headerlink\" title=\"Night mode\"></a>Night mode</h3><p>Just for article reading. In article page, you can click the <strong>logo image of header</strong> to switch to Night mode.</p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/night-mode.gif\" alt=\"\"></p>\n<h3 id=\"Search\"><a href=\"#Search\" class=\"headerlink\" title=\"Search\"></a>Search</h3><p>Hiker use <code>Insight Search</code> to help you search anything inside your site without any third-party plugin.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Search</span></div><div class=\"line\"><span class=\"attr\">search:</span></div><div class=\"line\"><span class=\"attr\">    insight:</span> <span class=\"literal\">true</span> <span class=\"comment\"># you need to install `hexo-generator-json-content` before using Insight Search</span></div><div class=\"line\"><span class=\"attr\">    swiftype:</span> <span class=\"comment\"># enter swiftype install key here</span></div><div class=\"line\"><span class=\"attr\">    baidu:</span> <span class=\"literal\">false</span> <span class=\"comment\"># you need to disable other search engines to use Baidu search, options: true, false</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>Attention: You need to install <code>hexo-generator-json-content</code> before using Insight Search.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -S hexo-generator-json-content</div></pre></td></tr></table></figure>\n<h3 id=\"Fancybox\"><a href=\"#Fancybox\" class=\"headerlink\" title=\"Fancybox\"></a>Fancybox</h3><p>Hiker uses <a href=\"http://fancyapps.com/fancybox/\" target=\"_blank\" rel=\"noopener\">Fancybox</a> to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">![img caption](img url)</div><div class=\"line\"></div><div class=\"line\">&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Sidebar\"><a href=\"#Sidebar\" class=\"headerlink\" title=\"Sidebar\"></a>Sidebar</h3><p>You can put your sidebar in left side, right side or bottom of your site by editing <code>sidebar</code> setting.<br>Hiker provides 5 built-in widgets:</p>\n<ul>\n<li>category</li>\n<li>tag</li>\n<li>tagcloud</li>\n<li>archives</li>\n<li>recent_posts</li>\n</ul>\n<p>All of them are enabled by default. You can edit them in <code>widget</code> setting.</p>\n<h3 id=\"Comment-support\"><a href=\"#Comment-support\" class=\"headerlink\" title=\"Comment support\"></a>Comment support</h3><p>Hiker has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to hiker <code>hiker/_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># comment ShortName, you can choose only ONE to display.</span></div><div class=\"line\"><span class=\"attr\">duoshuo_shortname:</span> <span class=\"string\">iTimeTraveler</span></div><div class=\"line\"><span class=\"attr\">disqus_shortname:</span></div></pre></td></tr></table></figure>\n<h2 id=\"Browser-support\"><a href=\"#Browser-support\" class=\"headerlink\" title=\"Browser support\"></a>Browser support</h2><p><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/browser-support.png?raw=true\" alt=\"\"></p>\n<h2 id=\"Contributing\"><a href=\"#Contributing\" class=\"headerlink\" title=\"Contributing\"></a>Contributing</h2><p>All kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome.</p>\n<p>Looking forward to your pull request.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Hiker\"><a href=\"#Hiker\" class=\"headerlink\" title=\"Hiker\"></a>Hiker</h1><p><a href=\"https://travis-ci.org/iTimeTraveler/hexo-theme-hiker\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/iTimeTraveler/hexo-theme-hiker.svg?branch=master\" alt=\"Build Status\"></a>   <a href=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/LICENSE\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/license-MIT-blue.svg\" alt=\"GitHub license\"></a></p>\n<p>An attractive, exquisite theme for <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>. named “Hiker”, short for “HikerNews”.  </p>\n<p><a href=\"https://itimetraveler.github.io/hexo-theme-hiker/\" target=\"_blank\" rel=\"noopener\"><strong>☞ Live Preview</strong></a>  |  <a href=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/README.cn.md\" target=\"_blank\" rel=\"noopener\"><strong>✎ Hiker 中文版使用文档</strong></a></p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/homepage-index.png\" alt=\"Desktop Preview\"><br><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/article-chrome.png\" alt=\"Post Preview\"><br><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/preview-mobile.png?raw=true\" alt=\"Mobile Preview\"></p>","more":"<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><ol>\n<li><p>Get it from GitHub</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker</div></pre></td></tr></table></figure>\n</li>\n<li><p>Enable</p>\n<p>Modify <code>theme</code> setting in <code>_config.yml</code> to <code>hiker</code>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: http://hexo.io/plugins/</div><div class=\"line\">## Themes: http://hexo.io/themes/</div><div class=\"line\">theme: hiker</div></pre></td></tr></table></figure>\n</li>\n<li><p>Update</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span> cd themes/Hiker</div><div class=\"line\"><span class=\"meta\">$</span> git pull</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h2><h3 id=\"Theme-configuration-example\"><a href=\"#Theme-configuration-example\" class=\"headerlink\" title=\"Theme configuration example\"></a>Theme configuration example</h3><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></div><div class=\"line\"><span class=\"comment\"># Site Information Settings</span></div><div class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Header Menu</span></div><div class=\"line\"><span class=\"attr\">menu:</span></div><div class=\"line\"><span class=\"attr\">  Home:</span> <span class=\"string\">/</span></div><div class=\"line\"><span class=\"attr\">  Archives:</span> <span class=\"string\">archives</span></div><div class=\"line\"><span class=\"attr\">  Categories:</span> <span class=\"string\">categories</span></div><div class=\"line\"><span class=\"attr\">  Tags:</span> <span class=\"string\">tags</span></div><div class=\"line\"><span class=\"attr\">  About:</span> <span class=\"string\">about</span></div><div class=\"line\"><span class=\"attr\">rss:</span> <span class=\"string\">/atom.xml</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">since:</span> <span class=\"number\">2013</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Set default keywords (Use a comma to separate)</span></div><div class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Put your favicon.ico into `hexo-site/themes/hiker/source/` directory.</span></div><div class=\"line\"><span class=\"attr\">avatar:</span> <span class=\"string\">css/images/mylogo.jpg</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Homepage</span></div><div class=\"line\"><span class=\"comment\"># eg. home_background_image: css/images/home-bg.jpg</span></div><div class=\"line\"><span class=\"attr\">home_background_image:</span> <span class=\"string\">css/images/home-bg.jpg</span></div><div class=\"line\"><span class=\"attr\">home_logo_image:</span></div><div class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">false</span></div><div class=\"line\"><span class=\"attr\">  border:</span> <span class=\"literal\">false</span></div><div class=\"line\"><span class=\"attr\">  url:</span> <span class=\"string\">css/images/homelogo.jpg</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># AboutPage background</span></div><div class=\"line\"><span class=\"attr\">about_big_image:</span> <span class=\"string\">css/images/pose.jpg</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Content</span></div><div class=\"line\"><span class=\"attr\">excerpt_link:</span> <span class=\"string\">Read</span> <span class=\"string\">More</span></div><div class=\"line\"><span class=\"attr\">fancybox:</span> <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Sidebar</span></div><div class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"string\">right</span></div><div class=\"line\"><span class=\"attr\">widgets:</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">tag</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">tagcloud</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></div><div class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent_posts</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># comment ShortName, you can choose only ONE to display.</span></div><div class=\"line\"><span class=\"attr\">duoshuo_shortname:</span> <span class=\"string\">iTimeTraveler</span></div><div class=\"line\"><span class=\"attr\">disqus_shortname:</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Code Highlight theme</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    default | normal | night | night eighties | night blue | night bright</span></div><div class=\"line\"><span class=\"comment\"># https://github.com/chriskempson/tomorrow-theme</span></div><div class=\"line\"><span class=\"attr\">highlight_theme:</span> <span class=\"string\">default</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Article theme color</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    random | orange | blue | red | green | black</span></div><div class=\"line\"><span class=\"attr\">theme_color:</span> <span class=\"string\">random</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># display widgets at the bottom of index pages (pagination == 2)</span></div><div class=\"line\"><span class=\"attr\">index_widgets:</span></div><div class=\"line\"><span class=\"comment\"># - category</span></div><div class=\"line\"><span class=\"comment\"># - tagcloud</span></div><div class=\"line\"><span class=\"comment\"># - archive</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># widget behavior</span></div><div class=\"line\"><span class=\"attr\">archive_type:</span> <span class=\"string\">'monthly'</span></div><div class=\"line\"><span class=\"attr\">show_count:</span> <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Google Webmaster tools verification setting</span></div><div class=\"line\"><span class=\"comment\"># See: https://www.google.com/webmasters/</span></div><div class=\"line\"><span class=\"attr\">google_site_verification:</span></div><div class=\"line\"><span class=\"attr\">baidu_site_verification:</span></div><div class=\"line\"><span class=\"attr\">qihu_site_verification:</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Miscellaneous</span></div><div class=\"line\"><span class=\"attr\">google_analytics:</span></div><div class=\"line\"><span class=\"attr\">gauges_analytics:</span></div><div class=\"line\"><span class=\"attr\">twitter:</span></div><div class=\"line\"><span class=\"attr\">google_plus:</span></div><div class=\"line\"><span class=\"attr\">fb_admins:</span></div><div class=\"line\"><span class=\"attr\">fb_app_id:</span></div></pre></td></tr></table></figure>\n<ul>\n<li><strong>menu</strong> - Navigation menu</li>\n<li><strong>rss</strong> - RSS link</li>\n<li><strong>excerpt_link</strong> - “Read More” link at the bottom of excerpted articles. <code>false</code> to hide the link.</li>\n<li><strong>fancybox</strong> - Enable <a href=\"http://fancyapps.com/fancybox/\" target=\"_blank\" rel=\"noopener\">Fancybox</a></li>\n<li><strong>sidebar</strong> - Sidebar style. You can choose <code>left</code>, <code>right</code>, <code>bottom</code> or <code>false</code>.</li>\n<li><strong>widgets</strong> - Widgets displaying in sidebar</li>\n<li><strong>google_analytics</strong> - Google Analytics ID</li>\n<li><strong>favicon</strong> - Favicon path</li>\n<li><strong>twitter</strong> - Twiiter ID</li>\n<li><strong>google_plus</strong> - Google+ ID</li>\n</ul>\n<h2 id=\"Features\"><a href=\"#Features\" class=\"headerlink\" title=\"Features\"></a>Features</h2><h3 id=\"Homepage-background\"><a href=\"#Homepage-background\" class=\"headerlink\" title=\"Homepage background\"></a>Homepage background</h3><p>You could place the image file in <code>YOUR_HEXO_SITE\\themes\\hiker\\source\\css\\images</code> directory. and modify <code>home_background_image</code> in hiker/_config.yml. </p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Homepage</span></div><div class=\"line\"><span class=\"comment\"># eg. home_background_image: css/images/home-bg.jpg</span></div><div class=\"line\"><span class=\"attr\">home_background_image:</span> <span class=\"string\">css/images/home-bg.jpg</span></div></pre></td></tr></table></figure>\n<p>If you DON’T want any image as your homepage background, just set <code>home_background_image</code> empty in hiker/_config.yml, then you have an default homepage with <strong>random decorative pattern</strong>.</p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/home-no-background1.png\" alt=\"\"></p>\n<h3 id=\"Code-Highlight-Theme\"><a href=\"#Code-Highlight-Theme\" class=\"headerlink\" title=\"Code Highlight Theme\"></a>Code Highlight Theme</h3><p>Hiker use <a href=\"https://github.com/chriskempson/tomorrow-theme\" target=\"_blank\" rel=\"noopener\">Tomorrow Theme</a> for your code block. We have six options in total: <code>default</code>, <code>normal</code>, <code>night</code>, <code>night blue</code>, <code>night bright</code>, <code>night eighties</code></p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/code-theme-default.png\" alt=\"code `default` theme Preview\"></p>\n<p>Above preview picture is default theme. the image below show other five Highlight themes.</p>\n<p><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/code-theme.jpg?raw=true\" alt=\"code themes\"></p>\n<p>Modify <code>highlight_theme</code> in hiker/_config.yml.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Code Highlight theme</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    default | normal | night | night eighties | night blue | night bright</span></div><div class=\"line\"><span class=\"comment\"># https://github.com/chriskempson/tomorrow-theme</span></div><div class=\"line\"><span class=\"attr\">highlight_theme:</span> <span class=\"string\">default</span></div></pre></td></tr></table></figure>\n<h3 id=\"Blog-Theme-Color\"><a href=\"#Blog-Theme-Color\" class=\"headerlink\" title=\"Blog Theme Color\"></a>Blog Theme Color</h3><p>Hiker provide five color themes for your blog.</p>\n<p><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/theme-color.png?raw=true\" alt=\"theme colors\"></p>\n<ul>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #fb6d19; border-radius: 3px; vertical-align: middle;\"></span> orange</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #00aced; border-radius: 3px; vertical-align: middle;\"></span> blue</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #f03838; border-radius: 3px; vertical-align: middle;\"></span> red</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #39aa56; border-radius: 3px; vertical-align: middle;\"></span> green</li>\n<li><span style=\"display: inline-block; width: 18px; height: 18px; margin: 0 4px; background-color: #404040; border-radius: 3px; vertical-align: middle;\"></span> black</li>\n</ul>\n<p>You can modify <code>theme_color</code> in hiker/_config.yml.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Article theme color</span></div><div class=\"line\"><span class=\"comment\"># Available value:</span></div><div class=\"line\"><span class=\"comment\">#    random | orange | blue | red | green | black</span></div><div class=\"line\"><span class=\"attr\">theme_color:</span> <span class=\"string\">random</span></div></pre></td></tr></table></figure>\n<h3 id=\"Night-mode\"><a href=\"#Night-mode\" class=\"headerlink\" title=\"Night mode\"></a>Night mode</h3><p>Just for article reading. In article page, you can click the <strong>logo image of header</strong> to switch to Night mode.</p>\n<p><img src=\"https://itimetraveler.github.io/hexo-theme-hiker/2016/10/24/Hiker%E4%B8%BB%E9%A2%98%E9%A2%84%E8%A7%88/night-mode.gif\" alt=\"\"></p>\n<h3 id=\"Search\"><a href=\"#Search\" class=\"headerlink\" title=\"Search\"></a>Search</h3><p>Hiker use <code>Insight Search</code> to help you search anything inside your site without any third-party plugin.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># Search</span></div><div class=\"line\"><span class=\"attr\">search:</span></div><div class=\"line\"><span class=\"attr\">    insight:</span> <span class=\"literal\">true</span> <span class=\"comment\"># you need to install `hexo-generator-json-content` before using Insight Search</span></div><div class=\"line\"><span class=\"attr\">    swiftype:</span> <span class=\"comment\"># enter swiftype install key here</span></div><div class=\"line\"><span class=\"attr\">    baidu:</span> <span class=\"literal\">false</span> <span class=\"comment\"># you need to disable other search engines to use Baidu search, options: true, false</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>Attention: You need to install <code>hexo-generator-json-content</code> before using Insight Search.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -S hexo-generator-json-content</div></pre></td></tr></table></figure>\n<h3 id=\"Fancybox\"><a href=\"#Fancybox\" class=\"headerlink\" title=\"Fancybox\"></a>Fancybox</h3><p>Hiker uses <a href=\"http://fancyapps.com/fancybox/\" target=\"_blank\" rel=\"noopener\">Fancybox</a> to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">![img caption](img url)</div><div class=\"line\"></div><div class=\"line\">&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Sidebar\"><a href=\"#Sidebar\" class=\"headerlink\" title=\"Sidebar\"></a>Sidebar</h3><p>You can put your sidebar in left side, right side or bottom of your site by editing <code>sidebar</code> setting.<br>Hiker provides 5 built-in widgets:</p>\n<ul>\n<li>category</li>\n<li>tag</li>\n<li>tagcloud</li>\n<li>archives</li>\n<li>recent_posts</li>\n</ul>\n<p>All of them are enabled by default. You can edit them in <code>widget</code> setting.</p>\n<h3 id=\"Comment-support\"><a href=\"#Comment-support\" class=\"headerlink\" title=\"Comment support\"></a>Comment support</h3><p>Hiker has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to hiker <code>hiker/_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># comment ShortName, you can choose only ONE to display.</span></div><div class=\"line\"><span class=\"attr\">duoshuo_shortname:</span> <span class=\"string\">iTimeTraveler</span></div><div class=\"line\"><span class=\"attr\">disqus_shortname:</span></div></pre></td></tr></table></figure>\n<h2 id=\"Browser-support\"><a href=\"#Browser-support\" class=\"headerlink\" title=\"Browser support\"></a>Browser support</h2><p><img src=\"https://github.com/iTimeTraveler/hexo-theme-hiker/blob/master/source/preview/browser-support.png?raw=true\" alt=\"\"></p>\n<h2 id=\"Contributing\"><a href=\"#Contributing\" class=\"headerlink\" title=\"Contributing\"></a>Contributing</h2><p>All kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome.</p>\n<p>Looking forward to your pull request.</p>"},{"title":"Archives","date":"2017-08-07T07:00:24.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: Archives\ndate: 2017-08-07 15:00:24\n---\n","updated":"2017-08-08T03:13:40.729Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cjezm5y6f00036svsc4t8mvqw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-08-08T02:57:40.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-08-08 10:57:40\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2017-08-08T03:27:20.355Z","path":"categories/index.html","comments":1,"_id":"cjezm5y7500076svsygnscoa5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","date":"2017-08-08T04:12:45.000Z","layout":"tags","type":"tags","comments":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2017-08-08 12:12:45\nlayout: \"tags\"\ntype: \"tags\"\ncomments: true\n---\n","updated":"2017-08-08T03:14:08.256Z","path":"tags/index.html","_id":"cjezm5y7a00096svst3fh9chl","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018学习和复习","date":"2018-03-20T11:21:06.000Z","_content":"\n# 2018学习和复习\n\n大学做过无数次计划，似乎少有完全达成，这样看来，其实是自己的问题。所以特此再做一次计划，计划不会特别具体，但要让自己严格执行。\n\n## 学习\n\n把学习和复习分开来计划其实是很明智的。复习计划是与考研强相关的，学习计划则是与专业强相关，与考研弱相关的。当然介于考研其实是场持久战，而且如果要考408的话，复习时间其实是很紧的，所以复习期间看考研不相关的东西其实是不太明智的，除非能提早开始准备。\n当然，我这个人就这样，不喜欢总是做一些课内的或者合时宜的事情，偶尔会在课外捣鼓一些其他东西。这次准备看一些感兴趣的又能对考研的复习有一定作用的书籍。\n首先是最近已经在看了的，《Scala函数式编程》。因为课内可能需要捣鼓`大数据`，`分布式`什么的，这本书可以学习到一些Scala编程，其实有一定帮助。但对考研帮助不大，可能里面涉及到的少部分`函数式数据结构`，是对复习数据结构有帮助，但是其实应该不明显的。这本书习题蛮多的，后面还特别吃力。所以最近可能会缓一缓，基本上一个月看一章足矣。记得寒假看了点《JS函数式编程》和《Haskell趣学指南》，其实已经学到了不少函数式知识了。Scala这本也基本没超出之前所看的，唯一区别的是这本难度更大，而且有大量习题。\n第二本是《算法新解》，这本也开始看了，不过没有前者看深刻。这本除了`图`数据结构以外，基本囊括了`数据结构`这门课的知识点并且还有许多高级数据结构，除此之外还增加了近一半函数式数据结构和算法。这本应该不会全看完，视情况而定。前期数据结构复习以此为准，毕竟要对自己更高要求嘛。\n未来几个月打算看的书有《深入理解JVM》，《Effective Modern C++》，《C++性能优化指南》。这几本书只打算在这个学期和暑假的时候看下，3本通读半本内容后，就作为参考了。\n接下来说说我为什么选这3本。\n《深入理解JVM》早就想看了，因为以前厌恶Java的原因导致我也不想了解JVM。许多Java实习生，其实应该看这本书，因为对他们面试和工作都有用处。不过对我而已，这本书其实在讲虚拟机的体系结构罢了，它其实就只是在计算机系统结构上又抽象出了一层体系结构。这样说来，了解过JVM的体系结构以后，其实对计算机体系结构甚至操作系统也有比较大的帮助。考虑到考研可能要考组成原理，而组成原理与系统结构其实知识点很相近，所以说这本书对组成原理复习是有一定帮助的。\n《Effective Modern C++》，这本是在大一学C++的时候就想要读了。然而，那时候功底不够，后来大二的时候接触C++比较少了，而且有对C++一些历史原因和特性的无奈与恐惧，还有英文功底不好等原因，没有看。最近开始拿C++刷题了，又扫过几眼C++的书，觉得对STL掌握更好了，最后是因为`Rust`，导致我挺想看的。\n《C++性能优化指南》，这本我其实一点也不了解，单纯看目录，感觉对自己的底层编程有帮助，姑且作为参考吧。\n\n## 复习\n\n身边人都陆陆续续开始复习了，而我课程其实不少，始终只是在记单词和刷点题。当数学复习开始的时候，大概就是正式进入复习状态吧。网上查说`数学`复习开始时间是3-6月，而`专业课`复习开始是6-7月。所以我计划5月一定要开始数学复习，而专业目前只看数据结构并且刷题。专业课7月正式开始。其实这样真的蛮紧张的，所以英语复习是每天都不能松懈的，并且争取这次过6级。\n关于复习资料，目前还没收集全，每周会查阅一些信息来补充复习计划。\n\n关于PAT刷题计划：\n- 3月，前一百题，刷完20分的题。\n- 4月，前一百题，刷完25分的题。\n- 5月，前一百题，刷完30分的题。\n- 暑假，刷完最后的题。\n\n整体上复习大纲就是这样，坚持下来，就会收获。","source":"_posts/2018学习和复习.md","raw":"---\ntitle: 2018学习和复习\ndate: 2018-03-20 19:21:06\ntags: study\ncategory: [考研, CS]\n---\n\n# 2018学习和复习\n\n大学做过无数次计划，似乎少有完全达成，这样看来，其实是自己的问题。所以特此再做一次计划，计划不会特别具体，但要让自己严格执行。\n\n## 学习\n\n把学习和复习分开来计划其实是很明智的。复习计划是与考研强相关的，学习计划则是与专业强相关，与考研弱相关的。当然介于考研其实是场持久战，而且如果要考408的话，复习时间其实是很紧的，所以复习期间看考研不相关的东西其实是不太明智的，除非能提早开始准备。\n当然，我这个人就这样，不喜欢总是做一些课内的或者合时宜的事情，偶尔会在课外捣鼓一些其他东西。这次准备看一些感兴趣的又能对考研的复习有一定作用的书籍。\n首先是最近已经在看了的，《Scala函数式编程》。因为课内可能需要捣鼓`大数据`，`分布式`什么的，这本书可以学习到一些Scala编程，其实有一定帮助。但对考研帮助不大，可能里面涉及到的少部分`函数式数据结构`，是对复习数据结构有帮助，但是其实应该不明显的。这本书习题蛮多的，后面还特别吃力。所以最近可能会缓一缓，基本上一个月看一章足矣。记得寒假看了点《JS函数式编程》和《Haskell趣学指南》，其实已经学到了不少函数式知识了。Scala这本也基本没超出之前所看的，唯一区别的是这本难度更大，而且有大量习题。\n第二本是《算法新解》，这本也开始看了，不过没有前者看深刻。这本除了`图`数据结构以外，基本囊括了`数据结构`这门课的知识点并且还有许多高级数据结构，除此之外还增加了近一半函数式数据结构和算法。这本应该不会全看完，视情况而定。前期数据结构复习以此为准，毕竟要对自己更高要求嘛。\n未来几个月打算看的书有《深入理解JVM》，《Effective Modern C++》，《C++性能优化指南》。这几本书只打算在这个学期和暑假的时候看下，3本通读半本内容后，就作为参考了。\n接下来说说我为什么选这3本。\n《深入理解JVM》早就想看了，因为以前厌恶Java的原因导致我也不想了解JVM。许多Java实习生，其实应该看这本书，因为对他们面试和工作都有用处。不过对我而已，这本书其实在讲虚拟机的体系结构罢了，它其实就只是在计算机系统结构上又抽象出了一层体系结构。这样说来，了解过JVM的体系结构以后，其实对计算机体系结构甚至操作系统也有比较大的帮助。考虑到考研可能要考组成原理，而组成原理与系统结构其实知识点很相近，所以说这本书对组成原理复习是有一定帮助的。\n《Effective Modern C++》，这本是在大一学C++的时候就想要读了。然而，那时候功底不够，后来大二的时候接触C++比较少了，而且有对C++一些历史原因和特性的无奈与恐惧，还有英文功底不好等原因，没有看。最近开始拿C++刷题了，又扫过几眼C++的书，觉得对STL掌握更好了，最后是因为`Rust`，导致我挺想看的。\n《C++性能优化指南》，这本我其实一点也不了解，单纯看目录，感觉对自己的底层编程有帮助，姑且作为参考吧。\n\n## 复习\n\n身边人都陆陆续续开始复习了，而我课程其实不少，始终只是在记单词和刷点题。当数学复习开始的时候，大概就是正式进入复习状态吧。网上查说`数学`复习开始时间是3-6月，而`专业课`复习开始是6-7月。所以我计划5月一定要开始数学复习，而专业目前只看数据结构并且刷题。专业课7月正式开始。其实这样真的蛮紧张的，所以英语复习是每天都不能松懈的，并且争取这次过6级。\n关于复习资料，目前还没收集全，每周会查阅一些信息来补充复习计划。\n\n关于PAT刷题计划：\n- 3月，前一百题，刷完20分的题。\n- 4月，前一百题，刷完25分的题。\n- 5月，前一百题，刷完30分的题。\n- 暑假，刷完最后的题。\n\n整体上复习大纲就是这样，坚持下来，就会收获。","slug":"2018学习和复习","published":1,"updated":"2018-03-20T12:06:21.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y5z00006svsubfzlqm9","content":"<h1 id=\"2018学习和复习\"><a href=\"#2018学习和复习\" class=\"headerlink\" title=\"2018学习和复习\"></a>2018学习和复习</h1><p>大学做过无数次计划，似乎少有完全达成，这样看来，其实是自己的问题。所以特此再做一次计划，计划不会特别具体，但要让自己严格执行。</p>\n<h2 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h2><p>把学习和复习分开来计划其实是很明智的。复习计划是与考研强相关的，学习计划则是与专业强相关，与考研弱相关的。当然介于考研其实是场持久战，而且如果要考408的话，复习时间其实是很紧的，所以复习期间看考研不相关的东西其实是不太明智的，除非能提早开始准备。<br>当然，我这个人就这样，不喜欢总是做一些课内的或者合时宜的事情，偶尔会在课外捣鼓一些其他东西。这次准备看一些感兴趣的又能对考研的复习有一定作用的书籍。<br>首先是最近已经在看了的，《Scala函数式编程》。因为课内可能需要捣鼓<code>大数据</code>，<code>分布式</code>什么的，这本书可以学习到一些Scala编程，其实有一定帮助。但对考研帮助不大，可能里面涉及到的少部分<code>函数式数据结构</code>，是对复习数据结构有帮助，但是其实应该不明显的。这本书习题蛮多的，后面还特别吃力。所以最近可能会缓一缓，基本上一个月看一章足矣。记得寒假看了点《JS函数式编程》和《Haskell趣学指南》，其实已经学到了不少函数式知识了。Scala这本也基本没超出之前所看的，唯一区别的是这本难度更大，而且有大量习题。<br>第二本是《算法新解》，这本也开始看了，不过没有前者看深刻。这本除了<code>图</code>数据结构以外，基本囊括了<code>数据结构</code>这门课的知识点并且还有许多高级数据结构，除此之外还增加了近一半函数式数据结构和算法。这本应该不会全看完，视情况而定。前期数据结构复习以此为准，毕竟要对自己更高要求嘛。<br>未来几个月打算看的书有《深入理解JVM》，《Effective Modern C++》，《C++性能优化指南》。这几本书只打算在这个学期和暑假的时候看下，3本通读半本内容后，就作为参考了。<br>接下来说说我为什么选这3本。<br>《深入理解JVM》早就想看了，因为以前厌恶Java的原因导致我也不想了解JVM。许多Java实习生，其实应该看这本书，因为对他们面试和工作都有用处。不过对我而已，这本书其实在讲虚拟机的体系结构罢了，它其实就只是在计算机系统结构上又抽象出了一层体系结构。这样说来，了解过JVM的体系结构以后，其实对计算机体系结构甚至操作系统也有比较大的帮助。考虑到考研可能要考组成原理，而组成原理与系统结构其实知识点很相近，所以说这本书对组成原理复习是有一定帮助的。<br>《Effective Modern C++》，这本是在大一学C++的时候就想要读了。然而，那时候功底不够，后来大二的时候接触C++比较少了，而且有对C++一些历史原因和特性的无奈与恐惧，还有英文功底不好等原因，没有看。最近开始拿C++刷题了，又扫过几眼C++的书，觉得对STL掌握更好了，最后是因为<code>Rust</code>，导致我挺想看的。<br>《C++性能优化指南》，这本我其实一点也不了解，单纯看目录，感觉对自己的底层编程有帮助，姑且作为参考吧。</p>\n<h2 id=\"复习\"><a href=\"#复习\" class=\"headerlink\" title=\"复习\"></a>复习</h2><p>身边人都陆陆续续开始复习了，而我课程其实不少，始终只是在记单词和刷点题。当数学复习开始的时候，大概就是正式进入复习状态吧。网上查说<code>数学</code>复习开始时间是3-6月，而<code>专业课</code>复习开始是6-7月。所以我计划5月一定要开始数学复习，而专业目前只看数据结构并且刷题。专业课7月正式开始。其实这样真的蛮紧张的，所以英语复习是每天都不能松懈的，并且争取这次过6级。<br>关于复习资料，目前还没收集全，每周会查阅一些信息来补充复习计划。</p>\n<p>关于PAT刷题计划：</p>\n<ul>\n<li>3月，前一百题，刷完20分的题。</li>\n<li>4月，前一百题，刷完25分的题。</li>\n<li>5月，前一百题，刷完30分的题。</li>\n<li>暑假，刷完最后的题。</li>\n</ul>\n<p>整体上复习大纲就是这样，坚持下来，就会收获。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"2018学习和复习\"><a href=\"#2018学习和复习\" class=\"headerlink\" title=\"2018学习和复习\"></a>2018学习和复习</h1><p>大学做过无数次计划，似乎少有完全达成，这样看来，其实是自己的问题。所以特此再做一次计划，计划不会特别具体，但要让自己严格执行。</p>\n<h2 id=\"学习\"><a href=\"#学习\" class=\"headerlink\" title=\"学习\"></a>学习</h2><p>把学习和复习分开来计划其实是很明智的。复习计划是与考研强相关的，学习计划则是与专业强相关，与考研弱相关的。当然介于考研其实是场持久战，而且如果要考408的话，复习时间其实是很紧的，所以复习期间看考研不相关的东西其实是不太明智的，除非能提早开始准备。<br>当然，我这个人就这样，不喜欢总是做一些课内的或者合时宜的事情，偶尔会在课外捣鼓一些其他东西。这次准备看一些感兴趣的又能对考研的复习有一定作用的书籍。<br>首先是最近已经在看了的，《Scala函数式编程》。因为课内可能需要捣鼓<code>大数据</code>，<code>分布式</code>什么的，这本书可以学习到一些Scala编程，其实有一定帮助。但对考研帮助不大，可能里面涉及到的少部分<code>函数式数据结构</code>，是对复习数据结构有帮助，但是其实应该不明显的。这本书习题蛮多的，后面还特别吃力。所以最近可能会缓一缓，基本上一个月看一章足矣。记得寒假看了点《JS函数式编程》和《Haskell趣学指南》，其实已经学到了不少函数式知识了。Scala这本也基本没超出之前所看的，唯一区别的是这本难度更大，而且有大量习题。<br>第二本是《算法新解》，这本也开始看了，不过没有前者看深刻。这本除了<code>图</code>数据结构以外，基本囊括了<code>数据结构</code>这门课的知识点并且还有许多高级数据结构，除此之外还增加了近一半函数式数据结构和算法。这本应该不会全看完，视情况而定。前期数据结构复习以此为准，毕竟要对自己更高要求嘛。<br>未来几个月打算看的书有《深入理解JVM》，《Effective Modern C++》，《C++性能优化指南》。这几本书只打算在这个学期和暑假的时候看下，3本通读半本内容后，就作为参考了。<br>接下来说说我为什么选这3本。<br>《深入理解JVM》早就想看了，因为以前厌恶Java的原因导致我也不想了解JVM。许多Java实习生，其实应该看这本书，因为对他们面试和工作都有用处。不过对我而已，这本书其实在讲虚拟机的体系结构罢了，它其实就只是在计算机系统结构上又抽象出了一层体系结构。这样说来，了解过JVM的体系结构以后，其实对计算机体系结构甚至操作系统也有比较大的帮助。考虑到考研可能要考组成原理，而组成原理与系统结构其实知识点很相近，所以说这本书对组成原理复习是有一定帮助的。<br>《Effective Modern C++》，这本是在大一学C++的时候就想要读了。然而，那时候功底不够，后来大二的时候接触C++比较少了，而且有对C++一些历史原因和特性的无奈与恐惧，还有英文功底不好等原因，没有看。最近开始拿C++刷题了，又扫过几眼C++的书，觉得对STL掌握更好了，最后是因为<code>Rust</code>，导致我挺想看的。<br>《C++性能优化指南》，这本我其实一点也不了解，单纯看目录，感觉对自己的底层编程有帮助，姑且作为参考吧。</p>\n<h2 id=\"复习\"><a href=\"#复习\" class=\"headerlink\" title=\"复习\"></a>复习</h2><p>身边人都陆陆续续开始复习了，而我课程其实不少，始终只是在记单词和刷点题。当数学复习开始的时候，大概就是正式进入复习状态吧。网上查说<code>数学</code>复习开始时间是3-6月，而<code>专业课</code>复习开始是6-7月。所以我计划5月一定要开始数学复习，而专业目前只看数据结构并且刷题。专业课7月正式开始。其实这样真的蛮紧张的，所以英语复习是每天都不能松懈的，并且争取这次过6级。<br>关于复习资料，目前还没收集全，每周会查阅一些信息来补充复习计划。</p>\n<p>关于PAT刷题计划：</p>\n<ul>\n<li>3月，前一百题，刷完20分的题。</li>\n<li>4月，前一百题，刷完25分的题。</li>\n<li>5月，前一百题，刷完30分的题。</li>\n<li>暑假，刷完最后的题。</li>\n</ul>\n<p>整体上复习大纲就是这样，坚持下来，就会收获。</p>\n"},{"title":"2017-11-5","date":"2017-11-05T12:17:06.000Z","_content":"\n# 10月\n\n10月就这样过去了。当我觉得这样的10月是多么繁忙的时候，11月时候的我告诉自己，其实大部分时间是自己折腾自己罢了，而且毫无意义。\n\n<!-- more -->\n\n10月的作业债11月总是要还的。现在回想起来，好像是各个方面都在学习，但如蜗牛一般，于是乎，忘记自己走到了哪里。唯一欣喜的是，我开始接受其他书籍的洗礼了。之前从同学那儿借来了东野圭吾的《解忧杂货店》，每天熄灯后一小时都在咀嚼此书。跟计算机书籍比起来，这样的书确实容易读很多，不费太多的时间就能通读一遍，而且相当的有收获。当然，如果一本书没有从思想层面影响你，或者没有改变你的某个观念，或者没有改变你的一个习惯，或者没有引起你一点儿的思考，这样的书大概是不值得去读的。如某些读者所述，这本书确实在某方面治愈了我，让我感觉到人间一些温情，人与人之间不可思议的联系，很多无意义之事其实蕴含意义，不论好坏。其实我极力追求做一个足够纯粹的人，而我理解的纯粹是指一个的品质而不是性格。这本书里的人有些已经达到了我想追求的纯粹了。而我对纯粹的一些理解就是看淡大部分事情，对人的追求做到坦实真诚，对事的追求做到实事求是，对物的追求做到己所不欲。当然这里的追求比较广义。可能思想更接近于道家，当然我完全不懂这些思想家的大道理。讽刺的是，我一直没有做好，不然可能也不会写这些了。\n\n刚刚提到走着走着忘记走到了哪里。其实就是没有把握本心的缘故吧。原因无外乎就是意志力的不坚定，间接性情绪调节不良。10月份做了什么自己满意的事情？有把该完成的都及时正确地完成吗？除了课内，课外又扩展了多少？写到这里，能回答上的也就是10月份开始的跑步吧，频率还是挺高的，1周能跑4，5次。作业能提早完成的后来质量都出了问题……没有提早完成的基本拖到deadline。满意的事情，还真没有，我这个人不容易对事情感到满足，因为很容易就松懈下来，但实际上大部分时候我松懈的原因是因为失去了耐性或者热情，在这点上，还不如中学时代的自己，中学的我虽然在各方面的都很平庸（虽然现在依然），但做什么事情都饱含热情，是真的喜欢生活，喜欢与人交流。\n\n# 11月\n\n11月的第一周，基本宣告了学期过半。有什么收获自己心里清楚，没有完成什么自己心里清楚，还想做什么自己心里也清楚。人啊，总是会把生活中大部分事情当作理所当然，所以才不容易改变。我极力改变这样的思维，如何看待周围是一件非常严肃，非常需要思考，却被人忽略的事情啊。许多时候不能总保持着“我现在的这样状态真的很好啊”的想法，于是乎还想证明给其他人看。可能还有一种思考角度，我尝试往一个可能更好的习惯学习，如果反而没有帮助，再退回来。前者是以不变应万变，后者是以变应万变。最近开始尝试读一些文学作品，也是从此角度出发。一直读专业相关的作品或资料，当然对学习有很大帮助，但是人很难再脱离自己给自己建造的围墙了，它们既是梯子也是围墙啊。再谈到待人之事，摈弃过去看人优缺点的角度，而尝试以对方的角度看待对方自己，才能做到了解他人吧。\n\n然后是想反思一下一直以来的一些学习缺陷。看比较费理解的书，还是容易倾向于不去深思，原因嘛，就是怕麻烦，觉得这是一场时间黑洞的无意义之旅，然后是有点急于求成，过分看轻一些基本之理。不过还是要承认下自己的记忆力不行，对经历的事情还算有正常的记忆力，但对文字和视频的记忆力特别差，目前感觉原因尚不明朗。\n\n昨天把从同学那里借到了《独唱团》读了半本，今天才查了一下，原来是只出过一期，这个期刊本身还颇有一些故事。当然本身的内容也是不错，作者大多是80后70后吧？聚焦于上个世纪的中国，讲述各种经历，每篇都能透入一些观点，或批判或赞扬。\n\n而我已经好久没有看过这样的散文、诗句、问答、半小说半叙事的文章了。看来我还是不排斥文学作品的，高中每周也会去买杂志跟期刊，看看感兴趣的内容，喜欢看里面待人处事的观点。我敢说我现在的思想跟性格被高中时代接触的内容严重影响了，即使现在我已经几乎想不起那些内容。只记得，他们在谈论生活，他们在谈论文化，透露着思想…… 里面的图片也总是能触动许多，有时候能盯着图片一分钟，思考着什么我早已经忘记了，大概在思考着他们所思考的事情。我想这本书，我应该也会尝试读完吧，感觉把过去的习惯捡起来，就好像在跟老朋友拥抱一般，非常的踏实。\n\n发现写到这里，已经过去整整一小时了。大概我的脑子里又本能的计算着花一小时做这些事情的利弊了。看过的许多作品，我发现我都不能很好地把他们表达出来，或者借用一下，我想有机会写写探讨某些作品本身的博客，目前来说可能还不合适，阅历可能还不够。\n\n已经九点半了，面对着书架上近百本的书，其实心里滋味很难描述。","source":"_posts/2017-11-5.md","raw":"---\ntitle: 2017-11-5\ndate: 2017-11-05 20:17:06\ntags: life\ncategory: life\n---\n\n# 10月\n\n10月就这样过去了。当我觉得这样的10月是多么繁忙的时候，11月时候的我告诉自己，其实大部分时间是自己折腾自己罢了，而且毫无意义。\n\n<!-- more -->\n\n10月的作业债11月总是要还的。现在回想起来，好像是各个方面都在学习，但如蜗牛一般，于是乎，忘记自己走到了哪里。唯一欣喜的是，我开始接受其他书籍的洗礼了。之前从同学那儿借来了东野圭吾的《解忧杂货店》，每天熄灯后一小时都在咀嚼此书。跟计算机书籍比起来，这样的书确实容易读很多，不费太多的时间就能通读一遍，而且相当的有收获。当然，如果一本书没有从思想层面影响你，或者没有改变你的某个观念，或者没有改变你的一个习惯，或者没有引起你一点儿的思考，这样的书大概是不值得去读的。如某些读者所述，这本书确实在某方面治愈了我，让我感觉到人间一些温情，人与人之间不可思议的联系，很多无意义之事其实蕴含意义，不论好坏。其实我极力追求做一个足够纯粹的人，而我理解的纯粹是指一个的品质而不是性格。这本书里的人有些已经达到了我想追求的纯粹了。而我对纯粹的一些理解就是看淡大部分事情，对人的追求做到坦实真诚，对事的追求做到实事求是，对物的追求做到己所不欲。当然这里的追求比较广义。可能思想更接近于道家，当然我完全不懂这些思想家的大道理。讽刺的是，我一直没有做好，不然可能也不会写这些了。\n\n刚刚提到走着走着忘记走到了哪里。其实就是没有把握本心的缘故吧。原因无外乎就是意志力的不坚定，间接性情绪调节不良。10月份做了什么自己满意的事情？有把该完成的都及时正确地完成吗？除了课内，课外又扩展了多少？写到这里，能回答上的也就是10月份开始的跑步吧，频率还是挺高的，1周能跑4，5次。作业能提早完成的后来质量都出了问题……没有提早完成的基本拖到deadline。满意的事情，还真没有，我这个人不容易对事情感到满足，因为很容易就松懈下来，但实际上大部分时候我松懈的原因是因为失去了耐性或者热情，在这点上，还不如中学时代的自己，中学的我虽然在各方面的都很平庸（虽然现在依然），但做什么事情都饱含热情，是真的喜欢生活，喜欢与人交流。\n\n# 11月\n\n11月的第一周，基本宣告了学期过半。有什么收获自己心里清楚，没有完成什么自己心里清楚，还想做什么自己心里也清楚。人啊，总是会把生活中大部分事情当作理所当然，所以才不容易改变。我极力改变这样的思维，如何看待周围是一件非常严肃，非常需要思考，却被人忽略的事情啊。许多时候不能总保持着“我现在的这样状态真的很好啊”的想法，于是乎还想证明给其他人看。可能还有一种思考角度，我尝试往一个可能更好的习惯学习，如果反而没有帮助，再退回来。前者是以不变应万变，后者是以变应万变。最近开始尝试读一些文学作品，也是从此角度出发。一直读专业相关的作品或资料，当然对学习有很大帮助，但是人很难再脱离自己给自己建造的围墙了，它们既是梯子也是围墙啊。再谈到待人之事，摈弃过去看人优缺点的角度，而尝试以对方的角度看待对方自己，才能做到了解他人吧。\n\n然后是想反思一下一直以来的一些学习缺陷。看比较费理解的书，还是容易倾向于不去深思，原因嘛，就是怕麻烦，觉得这是一场时间黑洞的无意义之旅，然后是有点急于求成，过分看轻一些基本之理。不过还是要承认下自己的记忆力不行，对经历的事情还算有正常的记忆力，但对文字和视频的记忆力特别差，目前感觉原因尚不明朗。\n\n昨天把从同学那里借到了《独唱团》读了半本，今天才查了一下，原来是只出过一期，这个期刊本身还颇有一些故事。当然本身的内容也是不错，作者大多是80后70后吧？聚焦于上个世纪的中国，讲述各种经历，每篇都能透入一些观点，或批判或赞扬。\n\n而我已经好久没有看过这样的散文、诗句、问答、半小说半叙事的文章了。看来我还是不排斥文学作品的，高中每周也会去买杂志跟期刊，看看感兴趣的内容，喜欢看里面待人处事的观点。我敢说我现在的思想跟性格被高中时代接触的内容严重影响了，即使现在我已经几乎想不起那些内容。只记得，他们在谈论生活，他们在谈论文化，透露着思想…… 里面的图片也总是能触动许多，有时候能盯着图片一分钟，思考着什么我早已经忘记了，大概在思考着他们所思考的事情。我想这本书，我应该也会尝试读完吧，感觉把过去的习惯捡起来，就好像在跟老朋友拥抱一般，非常的踏实。\n\n发现写到这里，已经过去整整一小时了。大概我的脑子里又本能的计算着花一小时做这些事情的利弊了。看过的许多作品，我发现我都不能很好地把他们表达出来，或者借用一下，我想有机会写写探讨某些作品本身的博客，目前来说可能还不合适，阅历可能还不够。\n\n已经九点半了，面对着书架上近百本的书，其实心里滋味很难描述。","slug":"2017-11-5","published":1,"updated":"2017-11-05T13:44:44.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y6c00026svsgmwrvc19","content":"<h1 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h1><p>10月就这样过去了。当我觉得这样的10月是多么繁忙的时候，11月时候的我告诉自己，其实大部分时间是自己折腾自己罢了，而且毫无意义。</p>\n<a id=\"more\"></a>\n<p>10月的作业债11月总是要还的。现在回想起来，好像是各个方面都在学习，但如蜗牛一般，于是乎，忘记自己走到了哪里。唯一欣喜的是，我开始接受其他书籍的洗礼了。之前从同学那儿借来了东野圭吾的《解忧杂货店》，每天熄灯后一小时都在咀嚼此书。跟计算机书籍比起来，这样的书确实容易读很多，不费太多的时间就能通读一遍，而且相当的有收获。当然，如果一本书没有从思想层面影响你，或者没有改变你的某个观念，或者没有改变你的一个习惯，或者没有引起你一点儿的思考，这样的书大概是不值得去读的。如某些读者所述，这本书确实在某方面治愈了我，让我感觉到人间一些温情，人与人之间不可思议的联系，很多无意义之事其实蕴含意义，不论好坏。其实我极力追求做一个足够纯粹的人，而我理解的纯粹是指一个的品质而不是性格。这本书里的人有些已经达到了我想追求的纯粹了。而我对纯粹的一些理解就是看淡大部分事情，对人的追求做到坦实真诚，对事的追求做到实事求是，对物的追求做到己所不欲。当然这里的追求比较广义。可能思想更接近于道家，当然我完全不懂这些思想家的大道理。讽刺的是，我一直没有做好，不然可能也不会写这些了。</p>\n<p>刚刚提到走着走着忘记走到了哪里。其实就是没有把握本心的缘故吧。原因无外乎就是意志力的不坚定，间接性情绪调节不良。10月份做了什么自己满意的事情？有把该完成的都及时正确地完成吗？除了课内，课外又扩展了多少？写到这里，能回答上的也就是10月份开始的跑步吧，频率还是挺高的，1周能跑4，5次。作业能提早完成的后来质量都出了问题……没有提早完成的基本拖到deadline。满意的事情，还真没有，我这个人不容易对事情感到满足，因为很容易就松懈下来，但实际上大部分时候我松懈的原因是因为失去了耐性或者热情，在这点上，还不如中学时代的自己，中学的我虽然在各方面的都很平庸（虽然现在依然），但做什么事情都饱含热情，是真的喜欢生活，喜欢与人交流。</p>\n<h1 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h1><p>11月的第一周，基本宣告了学期过半。有什么收获自己心里清楚，没有完成什么自己心里清楚，还想做什么自己心里也清楚。人啊，总是会把生活中大部分事情当作理所当然，所以才不容易改变。我极力改变这样的思维，如何看待周围是一件非常严肃，非常需要思考，却被人忽略的事情啊。许多时候不能总保持着“我现在的这样状态真的很好啊”的想法，于是乎还想证明给其他人看。可能还有一种思考角度，我尝试往一个可能更好的习惯学习，如果反而没有帮助，再退回来。前者是以不变应万变，后者是以变应万变。最近开始尝试读一些文学作品，也是从此角度出发。一直读专业相关的作品或资料，当然对学习有很大帮助，但是人很难再脱离自己给自己建造的围墙了，它们既是梯子也是围墙啊。再谈到待人之事，摈弃过去看人优缺点的角度，而尝试以对方的角度看待对方自己，才能做到了解他人吧。</p>\n<p>然后是想反思一下一直以来的一些学习缺陷。看比较费理解的书，还是容易倾向于不去深思，原因嘛，就是怕麻烦，觉得这是一场时间黑洞的无意义之旅，然后是有点急于求成，过分看轻一些基本之理。不过还是要承认下自己的记忆力不行，对经历的事情还算有正常的记忆力，但对文字和视频的记忆力特别差，目前感觉原因尚不明朗。</p>\n<p>昨天把从同学那里借到了《独唱团》读了半本，今天才查了一下，原来是只出过一期，这个期刊本身还颇有一些故事。当然本身的内容也是不错，作者大多是80后70后吧？聚焦于上个世纪的中国，讲述各种经历，每篇都能透入一些观点，或批判或赞扬。</p>\n<p>而我已经好久没有看过这样的散文、诗句、问答、半小说半叙事的文章了。看来我还是不排斥文学作品的，高中每周也会去买杂志跟期刊，看看感兴趣的内容，喜欢看里面待人处事的观点。我敢说我现在的思想跟性格被高中时代接触的内容严重影响了，即使现在我已经几乎想不起那些内容。只记得，他们在谈论生活，他们在谈论文化，透露着思想…… 里面的图片也总是能触动许多，有时候能盯着图片一分钟，思考着什么我早已经忘记了，大概在思考着他们所思考的事情。我想这本书，我应该也会尝试读完吧，感觉把过去的习惯捡起来，就好像在跟老朋友拥抱一般，非常的踏实。</p>\n<p>发现写到这里，已经过去整整一小时了。大概我的脑子里又本能的计算着花一小时做这些事情的利弊了。看过的许多作品，我发现我都不能很好地把他们表达出来，或者借用一下，我想有机会写写探讨某些作品本身的博客，目前来说可能还不合适，阅历可能还不够。</p>\n<p>已经九点半了，面对着书架上近百本的书，其实心里滋味很难描述。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"10月\"><a href=\"#10月\" class=\"headerlink\" title=\"10月\"></a>10月</h1><p>10月就这样过去了。当我觉得这样的10月是多么繁忙的时候，11月时候的我告诉自己，其实大部分时间是自己折腾自己罢了，而且毫无意义。</p>","more":"<p>10月的作业债11月总是要还的。现在回想起来，好像是各个方面都在学习，但如蜗牛一般，于是乎，忘记自己走到了哪里。唯一欣喜的是，我开始接受其他书籍的洗礼了。之前从同学那儿借来了东野圭吾的《解忧杂货店》，每天熄灯后一小时都在咀嚼此书。跟计算机书籍比起来，这样的书确实容易读很多，不费太多的时间就能通读一遍，而且相当的有收获。当然，如果一本书没有从思想层面影响你，或者没有改变你的某个观念，或者没有改变你的一个习惯，或者没有引起你一点儿的思考，这样的书大概是不值得去读的。如某些读者所述，这本书确实在某方面治愈了我，让我感觉到人间一些温情，人与人之间不可思议的联系，很多无意义之事其实蕴含意义，不论好坏。其实我极力追求做一个足够纯粹的人，而我理解的纯粹是指一个的品质而不是性格。这本书里的人有些已经达到了我想追求的纯粹了。而我对纯粹的一些理解就是看淡大部分事情，对人的追求做到坦实真诚，对事的追求做到实事求是，对物的追求做到己所不欲。当然这里的追求比较广义。可能思想更接近于道家，当然我完全不懂这些思想家的大道理。讽刺的是，我一直没有做好，不然可能也不会写这些了。</p>\n<p>刚刚提到走着走着忘记走到了哪里。其实就是没有把握本心的缘故吧。原因无外乎就是意志力的不坚定，间接性情绪调节不良。10月份做了什么自己满意的事情？有把该完成的都及时正确地完成吗？除了课内，课外又扩展了多少？写到这里，能回答上的也就是10月份开始的跑步吧，频率还是挺高的，1周能跑4，5次。作业能提早完成的后来质量都出了问题……没有提早完成的基本拖到deadline。满意的事情，还真没有，我这个人不容易对事情感到满足，因为很容易就松懈下来，但实际上大部分时候我松懈的原因是因为失去了耐性或者热情，在这点上，还不如中学时代的自己，中学的我虽然在各方面的都很平庸（虽然现在依然），但做什么事情都饱含热情，是真的喜欢生活，喜欢与人交流。</p>\n<h1 id=\"11月\"><a href=\"#11月\" class=\"headerlink\" title=\"11月\"></a>11月</h1><p>11月的第一周，基本宣告了学期过半。有什么收获自己心里清楚，没有完成什么自己心里清楚，还想做什么自己心里也清楚。人啊，总是会把生活中大部分事情当作理所当然，所以才不容易改变。我极力改变这样的思维，如何看待周围是一件非常严肃，非常需要思考，却被人忽略的事情啊。许多时候不能总保持着“我现在的这样状态真的很好啊”的想法，于是乎还想证明给其他人看。可能还有一种思考角度，我尝试往一个可能更好的习惯学习，如果反而没有帮助，再退回来。前者是以不变应万变，后者是以变应万变。最近开始尝试读一些文学作品，也是从此角度出发。一直读专业相关的作品或资料，当然对学习有很大帮助，但是人很难再脱离自己给自己建造的围墙了，它们既是梯子也是围墙啊。再谈到待人之事，摈弃过去看人优缺点的角度，而尝试以对方的角度看待对方自己，才能做到了解他人吧。</p>\n<p>然后是想反思一下一直以来的一些学习缺陷。看比较费理解的书，还是容易倾向于不去深思，原因嘛，就是怕麻烦，觉得这是一场时间黑洞的无意义之旅，然后是有点急于求成，过分看轻一些基本之理。不过还是要承认下自己的记忆力不行，对经历的事情还算有正常的记忆力，但对文字和视频的记忆力特别差，目前感觉原因尚不明朗。</p>\n<p>昨天把从同学那里借到了《独唱团》读了半本，今天才查了一下，原来是只出过一期，这个期刊本身还颇有一些故事。当然本身的内容也是不错，作者大多是80后70后吧？聚焦于上个世纪的中国，讲述各种经历，每篇都能透入一些观点，或批判或赞扬。</p>\n<p>而我已经好久没有看过这样的散文、诗句、问答、半小说半叙事的文章了。看来我还是不排斥文学作品的，高中每周也会去买杂志跟期刊，看看感兴趣的内容，喜欢看里面待人处事的观点。我敢说我现在的思想跟性格被高中时代接触的内容严重影响了，即使现在我已经几乎想不起那些内容。只记得，他们在谈论生活，他们在谈论文化，透露着思想…… 里面的图片也总是能触动许多，有时候能盯着图片一分钟，思考着什么我早已经忘记了，大概在思考着他们所思考的事情。我想这本书，我应该也会尝试读完吧，感觉把过去的习惯捡起来，就好像在跟老朋友拥抱一般，非常的踏实。</p>\n<p>发现写到这里，已经过去整整一小时了。大概我的脑子里又本能的计算着花一小时做这些事情的利弊了。看过的许多作品，我发现我都不能很好地把他们表达出来，或者借用一下，我想有机会写写探讨某些作品本身的博客，目前来说可能还不合适，阅历可能还不够。</p>\n<p>已经九点半了，面对着书架上近百本的书，其实心里滋味很难描述。</p>"},{"title":"2018新年与考研","date":"2018-03-07T05:57:37.000Z","_content":"\n# 2018新年与考研\n\n## 新年\n\n新的2018年到来了，还没用文章对自己过去一年做一个总结。寒假的时候参加美赛，奈何自己太菜，估计只能获得一个`参赛奖`吧，好像也没什么好说的。\n\n寒假的后半段基本是自学一些感兴趣的东西，比如`Haskell`、`Rust`、`Scala`，主要是学习函数式编程吧，不过其实也就才刚入门的水平而已。除此之外，还在查阅一些考研相关的资料与信息，因为一直以来都有考研的打算，毕竟GPA不理想，没有机会保研嘛。\n\n<!-- more -->\n\n## 现状与打算\n\n到了大三下，大部分同学的课表就比较空了，但我可能还是蛮多的，跟大一上的时候差不多吧，不过幸好很多是选修课，不过这些选修课也都挺严格的。而创新实践课老师这个学期给了很多方向，让我们自己选择感兴趣的去学习，只要能真得学到东西就好了。我觉得这样挺不错的，之前的数据可视化我就不太感冒，自己的几何知识真的不太好。虽然现在也是数据可视化相关的，但是细分下来，可以有很多具体的不同方向的知识。比如做数据处理相关的，大数据方向。具体点就是学习分布式处理框架比如hadoop、spark、storm之类。如果硬要说兴趣的话，对这些还是有一点点兴趣的。至于可视化还有一些其他的工作，就交给其他组员做吧。当然我不满足于只是用用这些框架，虽然会应用是很重要，但是我打算学一些分布式系统的知识，这样学习也更深刻。比如CMU和MIT的分布式课，都有公开的，不过好像都是研究生级的课，而且资料不太全，可能很麻烦，这个具体看情况吧。\n\n其实要学的东西还真不少，再加上考研的复习，可能每天都很忙碌。我其实不清楚自己的计划可不可行，但是每天不接触点新知识总是不自在，而复习老知识相对比较枯燥，即使我没有掌握好。\n\n除此之外，在mooc大学平台上，还参加1，2门网络课，跟考研知识比较紧密，但不是为考研而开设的课程，其实也就是`CSAPP`（我其实基本看完了，课后练习大部分也做了，当然家庭作业都没有做，不过对上个学期操作系统的考试并没有什么帮助。。。）吧，相当于把编译加载，组成原理，操作系统结合的课程，当然不可能讲到那么细，只是学习它们很紧密的地方。这样也能大概巩固操作系统和计组的知识吧。如果我要考浙大的话，就是考`408`了。需要计网，操作系统，组成原理，数据结构四门核心课的复习。这样能确实有不少的复习作用，而且是从不同角度学习的，因此也有许多新知识，不会枯燥。\n\n数据结构我打算刷PAT，下次考试好像是8月左右，因此时间还蛮充裕的，配套练习有139题，争取全刷了。还有自己准备的一本《算法新解》，比考研难度要高，但是可以作为复习。还有一本《Scala函数式编程》，其实这本跟数据结构和算法关系不大，但是里面少部分还是对数据结构和算法有一定要求和锻炼的。\n\n除了计算机知识，还有英语和数学是这个学期就要开始了，先不考虑政治。数学我打算可能要晚一点再开始，英语现在每天记单词吧，偶尔可能刷刷其他知识点。姑且先这样吧，可能先适应1，2周并且打听打听其他人的学习情况。所以这个月重点在数据结构和英语了吧。\n\n当然还有课内要规划下，重点在分布式系统这块吧。网络编程这门课感觉有点水，打算退了选择云计算，这样也跟创新实践比较紧密些，可以减少负担。\n还有一门日语课也是重点，虽然跟考研完全无关，也没有帮助。但是既然自己已经选择了，那就好好学习。这门课一周4节，我估计学完了也就N5的水平了吧，听说N3,N4,N5都没什么用。所以路还长吧，N2好像至少要学2年。如果非要说点希望的话，希望自己本科可以把日语学到N3吧，当然英语更不必说了。\n\n姑且先写到这里吧。","source":"_posts/2018新年与考研.md","raw":"---\ntitle: 2018新年与考研\ndate: 2018-03-07 13:57:37\ntags: study\ncategory: [考研, CS]\n---\n\n# 2018新年与考研\n\n## 新年\n\n新的2018年到来了，还没用文章对自己过去一年做一个总结。寒假的时候参加美赛，奈何自己太菜，估计只能获得一个`参赛奖`吧，好像也没什么好说的。\n\n寒假的后半段基本是自学一些感兴趣的东西，比如`Haskell`、`Rust`、`Scala`，主要是学习函数式编程吧，不过其实也就才刚入门的水平而已。除此之外，还在查阅一些考研相关的资料与信息，因为一直以来都有考研的打算，毕竟GPA不理想，没有机会保研嘛。\n\n<!-- more -->\n\n## 现状与打算\n\n到了大三下，大部分同学的课表就比较空了，但我可能还是蛮多的，跟大一上的时候差不多吧，不过幸好很多是选修课，不过这些选修课也都挺严格的。而创新实践课老师这个学期给了很多方向，让我们自己选择感兴趣的去学习，只要能真得学到东西就好了。我觉得这样挺不错的，之前的数据可视化我就不太感冒，自己的几何知识真的不太好。虽然现在也是数据可视化相关的，但是细分下来，可以有很多具体的不同方向的知识。比如做数据处理相关的，大数据方向。具体点就是学习分布式处理框架比如hadoop、spark、storm之类。如果硬要说兴趣的话，对这些还是有一点点兴趣的。至于可视化还有一些其他的工作，就交给其他组员做吧。当然我不满足于只是用用这些框架，虽然会应用是很重要，但是我打算学一些分布式系统的知识，这样学习也更深刻。比如CMU和MIT的分布式课，都有公开的，不过好像都是研究生级的课，而且资料不太全，可能很麻烦，这个具体看情况吧。\n\n其实要学的东西还真不少，再加上考研的复习，可能每天都很忙碌。我其实不清楚自己的计划可不可行，但是每天不接触点新知识总是不自在，而复习老知识相对比较枯燥，即使我没有掌握好。\n\n除此之外，在mooc大学平台上，还参加1，2门网络课，跟考研知识比较紧密，但不是为考研而开设的课程，其实也就是`CSAPP`（我其实基本看完了，课后练习大部分也做了，当然家庭作业都没有做，不过对上个学期操作系统的考试并没有什么帮助。。。）吧，相当于把编译加载，组成原理，操作系统结合的课程，当然不可能讲到那么细，只是学习它们很紧密的地方。这样也能大概巩固操作系统和计组的知识吧。如果我要考浙大的话，就是考`408`了。需要计网，操作系统，组成原理，数据结构四门核心课的复习。这样能确实有不少的复习作用，而且是从不同角度学习的，因此也有许多新知识，不会枯燥。\n\n数据结构我打算刷PAT，下次考试好像是8月左右，因此时间还蛮充裕的，配套练习有139题，争取全刷了。还有自己准备的一本《算法新解》，比考研难度要高，但是可以作为复习。还有一本《Scala函数式编程》，其实这本跟数据结构和算法关系不大，但是里面少部分还是对数据结构和算法有一定要求和锻炼的。\n\n除了计算机知识，还有英语和数学是这个学期就要开始了，先不考虑政治。数学我打算可能要晚一点再开始，英语现在每天记单词吧，偶尔可能刷刷其他知识点。姑且先这样吧，可能先适应1，2周并且打听打听其他人的学习情况。所以这个月重点在数据结构和英语了吧。\n\n当然还有课内要规划下，重点在分布式系统这块吧。网络编程这门课感觉有点水，打算退了选择云计算，这样也跟创新实践比较紧密些，可以减少负担。\n还有一门日语课也是重点，虽然跟考研完全无关，也没有帮助。但是既然自己已经选择了，那就好好学习。这门课一周4节，我估计学完了也就N5的水平了吧，听说N3,N4,N5都没什么用。所以路还长吧，N2好像至少要学2年。如果非要说点希望的话，希望自己本科可以把日语学到N3吧，当然英语更不必说了。\n\n姑且先写到这里吧。","slug":"2018新年与考研","published":1,"updated":"2018-03-07T06:33:12.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y7200066svsgflhar4a","content":"<h1 id=\"2018新年与考研\"><a href=\"#2018新年与考研\" class=\"headerlink\" title=\"2018新年与考研\"></a>2018新年与考研</h1><h2 id=\"新年\"><a href=\"#新年\" class=\"headerlink\" title=\"新年\"></a>新年</h2><p>新的2018年到来了，还没用文章对自己过去一年做一个总结。寒假的时候参加美赛，奈何自己太菜，估计只能获得一个<code>参赛奖</code>吧，好像也没什么好说的。</p>\n<p>寒假的后半段基本是自学一些感兴趣的东西，比如<code>Haskell</code>、<code>Rust</code>、<code>Scala</code>，主要是学习函数式编程吧，不过其实也就才刚入门的水平而已。除此之外，还在查阅一些考研相关的资料与信息，因为一直以来都有考研的打算，毕竟GPA不理想，没有机会保研嘛。</p>\n<a id=\"more\"></a>\n<h2 id=\"现状与打算\"><a href=\"#现状与打算\" class=\"headerlink\" title=\"现状与打算\"></a>现状与打算</h2><p>到了大三下，大部分同学的课表就比较空了，但我可能还是蛮多的，跟大一上的时候差不多吧，不过幸好很多是选修课，不过这些选修课也都挺严格的。而创新实践课老师这个学期给了很多方向，让我们自己选择感兴趣的去学习，只要能真得学到东西就好了。我觉得这样挺不错的，之前的数据可视化我就不太感冒，自己的几何知识真的不太好。虽然现在也是数据可视化相关的，但是细分下来，可以有很多具体的不同方向的知识。比如做数据处理相关的，大数据方向。具体点就是学习分布式处理框架比如hadoop、spark、storm之类。如果硬要说兴趣的话，对这些还是有一点点兴趣的。至于可视化还有一些其他的工作，就交给其他组员做吧。当然我不满足于只是用用这些框架，虽然会应用是很重要，但是我打算学一些分布式系统的知识，这样学习也更深刻。比如CMU和MIT的分布式课，都有公开的，不过好像都是研究生级的课，而且资料不太全，可能很麻烦，这个具体看情况吧。</p>\n<p>其实要学的东西还真不少，再加上考研的复习，可能每天都很忙碌。我其实不清楚自己的计划可不可行，但是每天不接触点新知识总是不自在，而复习老知识相对比较枯燥，即使我没有掌握好。</p>\n<p>除此之外，在mooc大学平台上，还参加1，2门网络课，跟考研知识比较紧密，但不是为考研而开设的课程，其实也就是<code>CSAPP</code>（我其实基本看完了，课后练习大部分也做了，当然家庭作业都没有做，不过对上个学期操作系统的考试并没有什么帮助。。。）吧，相当于把编译加载，组成原理，操作系统结合的课程，当然不可能讲到那么细，只是学习它们很紧密的地方。这样也能大概巩固操作系统和计组的知识吧。如果我要考浙大的话，就是考<code>408</code>了。需要计网，操作系统，组成原理，数据结构四门核心课的复习。这样能确实有不少的复习作用，而且是从不同角度学习的，因此也有许多新知识，不会枯燥。</p>\n<p>数据结构我打算刷PAT，下次考试好像是8月左右，因此时间还蛮充裕的，配套练习有139题，争取全刷了。还有自己准备的一本《算法新解》，比考研难度要高，但是可以作为复习。还有一本《Scala函数式编程》，其实这本跟数据结构和算法关系不大，但是里面少部分还是对数据结构和算法有一定要求和锻炼的。</p>\n<p>除了计算机知识，还有英语和数学是这个学期就要开始了，先不考虑政治。数学我打算可能要晚一点再开始，英语现在每天记单词吧，偶尔可能刷刷其他知识点。姑且先这样吧，可能先适应1，2周并且打听打听其他人的学习情况。所以这个月重点在数据结构和英语了吧。</p>\n<p>当然还有课内要规划下，重点在分布式系统这块吧。网络编程这门课感觉有点水，打算退了选择云计算，这样也跟创新实践比较紧密些，可以减少负担。<br>还有一门日语课也是重点，虽然跟考研完全无关，也没有帮助。但是既然自己已经选择了，那就好好学习。这门课一周4节，我估计学完了也就N5的水平了吧，听说N3,N4,N5都没什么用。所以路还长吧，N2好像至少要学2年。如果非要说点希望的话，希望自己本科可以把日语学到N3吧，当然英语更不必说了。</p>\n<p>姑且先写到这里吧。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"2018新年与考研\"><a href=\"#2018新年与考研\" class=\"headerlink\" title=\"2018新年与考研\"></a>2018新年与考研</h1><h2 id=\"新年\"><a href=\"#新年\" class=\"headerlink\" title=\"新年\"></a>新年</h2><p>新的2018年到来了，还没用文章对自己过去一年做一个总结。寒假的时候参加美赛，奈何自己太菜，估计只能获得一个<code>参赛奖</code>吧，好像也没什么好说的。</p>\n<p>寒假的后半段基本是自学一些感兴趣的东西，比如<code>Haskell</code>、<code>Rust</code>、<code>Scala</code>，主要是学习函数式编程吧，不过其实也就才刚入门的水平而已。除此之外，还在查阅一些考研相关的资料与信息，因为一直以来都有考研的打算，毕竟GPA不理想，没有机会保研嘛。</p>","more":"<h2 id=\"现状与打算\"><a href=\"#现状与打算\" class=\"headerlink\" title=\"现状与打算\"></a>现状与打算</h2><p>到了大三下，大部分同学的课表就比较空了，但我可能还是蛮多的，跟大一上的时候差不多吧，不过幸好很多是选修课，不过这些选修课也都挺严格的。而创新实践课老师这个学期给了很多方向，让我们自己选择感兴趣的去学习，只要能真得学到东西就好了。我觉得这样挺不错的，之前的数据可视化我就不太感冒，自己的几何知识真的不太好。虽然现在也是数据可视化相关的，但是细分下来，可以有很多具体的不同方向的知识。比如做数据处理相关的，大数据方向。具体点就是学习分布式处理框架比如hadoop、spark、storm之类。如果硬要说兴趣的话，对这些还是有一点点兴趣的。至于可视化还有一些其他的工作，就交给其他组员做吧。当然我不满足于只是用用这些框架，虽然会应用是很重要，但是我打算学一些分布式系统的知识，这样学习也更深刻。比如CMU和MIT的分布式课，都有公开的，不过好像都是研究生级的课，而且资料不太全，可能很麻烦，这个具体看情况吧。</p>\n<p>其实要学的东西还真不少，再加上考研的复习，可能每天都很忙碌。我其实不清楚自己的计划可不可行，但是每天不接触点新知识总是不自在，而复习老知识相对比较枯燥，即使我没有掌握好。</p>\n<p>除此之外，在mooc大学平台上，还参加1，2门网络课，跟考研知识比较紧密，但不是为考研而开设的课程，其实也就是<code>CSAPP</code>（我其实基本看完了，课后练习大部分也做了，当然家庭作业都没有做，不过对上个学期操作系统的考试并没有什么帮助。。。）吧，相当于把编译加载，组成原理，操作系统结合的课程，当然不可能讲到那么细，只是学习它们很紧密的地方。这样也能大概巩固操作系统和计组的知识吧。如果我要考浙大的话，就是考<code>408</code>了。需要计网，操作系统，组成原理，数据结构四门核心课的复习。这样能确实有不少的复习作用，而且是从不同角度学习的，因此也有许多新知识，不会枯燥。</p>\n<p>数据结构我打算刷PAT，下次考试好像是8月左右，因此时间还蛮充裕的，配套练习有139题，争取全刷了。还有自己准备的一本《算法新解》，比考研难度要高，但是可以作为复习。还有一本《Scala函数式编程》，其实这本跟数据结构和算法关系不大，但是里面少部分还是对数据结构和算法有一定要求和锻炼的。</p>\n<p>除了计算机知识，还有英语和数学是这个学期就要开始了，先不考虑政治。数学我打算可能要晚一点再开始，英语现在每天记单词吧，偶尔可能刷刷其他知识点。姑且先这样吧，可能先适应1，2周并且打听打听其他人的学习情况。所以这个月重点在数据结构和英语了吧。</p>\n<p>当然还有课内要规划下，重点在分布式系统这块吧。网络编程这门课感觉有点水，打算退了选择云计算，这样也跟创新实践比较紧密些，可以减少负担。<br>还有一门日语课也是重点，虽然跟考研完全无关，也没有帮助。但是既然自己已经选择了，那就好好学习。这门课一周4节，我估计学完了也就N5的水平了吧，听说N3,N4,N5都没什么用。所以路还长吧，N2好像至少要学2年。如果非要说点希望的话，希望自己本科可以把日语学到N3吧，当然英语更不必说了。</p>\n<p>姑且先写到这里吧。</p>"},{"title":"IEEE802.11概述","date":"2017-12-26T14:03:46.000Z","_content":"\n# IEEE 802.11无线 LANs 概述\n\n## 无线链路和网络特征\n\n802.11协议簇是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。虽然WI-FI使用了802.11的媒体访问数据链路层（DLL）和物理层（PHY），但是两者并不完全一致。\n\n这里主要概述了 802.11无线LAN的特征。不过首先应该关注的是无线网络与有线网络的区别。\n\n当我们寻找有线和无线网络的重要区别时，应该重点关注链路层，我们确实可以发现有线链路和无线链路有许多重要区别：\n\n* 递减的信号强度。信号强度受到发送方和接收方距离的增加而递减。\n* 来自其他源的干扰。在同一个频段发送信号的电波源会互相干扰。\n* 多径传播（multipath propagation）。当电磁波受到反射，会在发送方和接收方之间走过多条不同长度的路径，此时出现多径传播，这使得接受的信号变得模糊。\n\n<!-- more -->\n\n## IEEE 802.11 标准\n\n常见的关于LAN的802.11标准包括 802.11b、802.11a、802.11g等。\n它们使用相同的媒体访问协议CSMA/CA，并且使用相同的链路层帧格式。\n\n![常见协议](802.11.jpg)\n\n## 802.11 体系结构\n\n802.11 体系结构的基本构建模块是`基本服务集（Basic Service Set BSS）`，一个BBS包含`若干个无线站点`和一个被称为接入点（AP）的中央基站。与以太网设备类似，每个802.11无线站点都具有6字节的MAC地址。每个AP的无线接口也具有一个MAC地址。这些MAC地址也由IEEE管理，理论上全球唯一。\n\n![中央基站实物图](中央基站.jpg)\n\n![BBS](BBS.jpg)\n\n### 信道与关联\n\n在802.11中，每个无线站点在发送或者接受网络层数据前，必须与一个AP相关联。而安装一个AP时，需要为其分配单字或者双字的服务集标识（SSID）。除了SSID，还需要分配一个信道号。\n\n信道：\n\n802.11定义了`11个部分重叠的信道`，当且仅当2个信道由4个或更多的信道隔开时，它们才不重叠。比如 1、6、11是唯一的3个非重叠信道集合。这样就可以在同一个物理网络安装3个AP。\n\n关联：\n\n为了获得互联网接入，你的无线站点需要加入其中一个子网并需要与其中一个AP相关联（associate）。关联意味着该无线站点在自身与该AP之间创建了一个虚拟线路。\n\n然而，首先得回答：你的无线站点如何与某个特定的AP相关联？或者你的无线站点如何知道当前位置哪个AP可以使用？\n\n802.11标准要求每个AP周期性地发送`信标帧（beacon frame）`，每个信标帧包括该AP的SSID和MAC地址。\n你的无线站点为了得知正在发送信标帧的AP，扫描11个信道，找到可能来着可能位于该区域的AP所发出的信标帧。\n\n不过，802.11标准没有指定选择哪个可用的AP进行关联的算法，这个由802.11固件和无线主机的软件设计者来设计。\n比如，主机选择接收到的具有最高信号强度的信标帧，但可能过载。\n\n这里扫描分两种：\n\n* 被动扫描（passive scanning），自AP发送信标帧，无线站点*扫描信道*和*监听信标帧*，然后向选择的AP发送*关联请求帧*，最后AP响应*关联响应帧*\n* 主动扫描（active scanning），无线站点广播*探测请求帧*，AP发送*探测响应*，然后无线站点选择AP发送*关联请求帧*，最后AP响应*关联响应帧*\n\n\n### 鉴别与接入\n\n为了与特定的AP创建关联，某无线站点可能需要向该AP鉴别它自身。\n\n802.11 提供了几种不同的鉴别和接入方法\n\n* 基于站点的MAC地址允许其接入网络\n* 基于用户名和口令\n\n上述两种情况下，可能使用的RADIUS（基于UDP）和DIAMETER（最初作为RADIUS的改良）这样的协议。\n\n\n","source":"_posts/IEEE802.11无线LANs概述.md","raw":"---\ntitle: IEEE802.11概述\ndate: 2017-12-26 22:03:46\ntags: network\ncategory: study\n---\n\n# IEEE 802.11无线 LANs 概述\n\n## 无线链路和网络特征\n\n802.11协议簇是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。虽然WI-FI使用了802.11的媒体访问数据链路层（DLL）和物理层（PHY），但是两者并不完全一致。\n\n这里主要概述了 802.11无线LAN的特征。不过首先应该关注的是无线网络与有线网络的区别。\n\n当我们寻找有线和无线网络的重要区别时，应该重点关注链路层，我们确实可以发现有线链路和无线链路有许多重要区别：\n\n* 递减的信号强度。信号强度受到发送方和接收方距离的增加而递减。\n* 来自其他源的干扰。在同一个频段发送信号的电波源会互相干扰。\n* 多径传播（multipath propagation）。当电磁波受到反射，会在发送方和接收方之间走过多条不同长度的路径，此时出现多径传播，这使得接受的信号变得模糊。\n\n<!-- more -->\n\n## IEEE 802.11 标准\n\n常见的关于LAN的802.11标准包括 802.11b、802.11a、802.11g等。\n它们使用相同的媒体访问协议CSMA/CA，并且使用相同的链路层帧格式。\n\n![常见协议](802.11.jpg)\n\n## 802.11 体系结构\n\n802.11 体系结构的基本构建模块是`基本服务集（Basic Service Set BSS）`，一个BBS包含`若干个无线站点`和一个被称为接入点（AP）的中央基站。与以太网设备类似，每个802.11无线站点都具有6字节的MAC地址。每个AP的无线接口也具有一个MAC地址。这些MAC地址也由IEEE管理，理论上全球唯一。\n\n![中央基站实物图](中央基站.jpg)\n\n![BBS](BBS.jpg)\n\n### 信道与关联\n\n在802.11中，每个无线站点在发送或者接受网络层数据前，必须与一个AP相关联。而安装一个AP时，需要为其分配单字或者双字的服务集标识（SSID）。除了SSID，还需要分配一个信道号。\n\n信道：\n\n802.11定义了`11个部分重叠的信道`，当且仅当2个信道由4个或更多的信道隔开时，它们才不重叠。比如 1、6、11是唯一的3个非重叠信道集合。这样就可以在同一个物理网络安装3个AP。\n\n关联：\n\n为了获得互联网接入，你的无线站点需要加入其中一个子网并需要与其中一个AP相关联（associate）。关联意味着该无线站点在自身与该AP之间创建了一个虚拟线路。\n\n然而，首先得回答：你的无线站点如何与某个特定的AP相关联？或者你的无线站点如何知道当前位置哪个AP可以使用？\n\n802.11标准要求每个AP周期性地发送`信标帧（beacon frame）`，每个信标帧包括该AP的SSID和MAC地址。\n你的无线站点为了得知正在发送信标帧的AP，扫描11个信道，找到可能来着可能位于该区域的AP所发出的信标帧。\n\n不过，802.11标准没有指定选择哪个可用的AP进行关联的算法，这个由802.11固件和无线主机的软件设计者来设计。\n比如，主机选择接收到的具有最高信号强度的信标帧，但可能过载。\n\n这里扫描分两种：\n\n* 被动扫描（passive scanning），自AP发送信标帧，无线站点*扫描信道*和*监听信标帧*，然后向选择的AP发送*关联请求帧*，最后AP响应*关联响应帧*\n* 主动扫描（active scanning），无线站点广播*探测请求帧*，AP发送*探测响应*，然后无线站点选择AP发送*关联请求帧*，最后AP响应*关联响应帧*\n\n\n### 鉴别与接入\n\n为了与特定的AP创建关联，某无线站点可能需要向该AP鉴别它自身。\n\n802.11 提供了几种不同的鉴别和接入方法\n\n* 基于站点的MAC地址允许其接入网络\n* 基于用户名和口令\n\n上述两种情况下，可能使用的RADIUS（基于UDP）和DIAMETER（最初作为RADIUS的改良）这样的协议。\n\n\n","slug":"IEEE802.11无线LANs概述","published":1,"updated":"2017-12-31T11:35:00.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y7800086svs60m92sar","content":"<h1 id=\"IEEE-802-11无线-LANs-概述\"><a href=\"#IEEE-802-11无线-LANs-概述\" class=\"headerlink\" title=\"IEEE 802.11无线 LANs 概述\"></a>IEEE 802.11无线 LANs 概述</h1><h2 id=\"无线链路和网络特征\"><a href=\"#无线链路和网络特征\" class=\"headerlink\" title=\"无线链路和网络特征\"></a>无线链路和网络特征</h2><p>802.11协议簇是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。虽然WI-FI使用了802.11的媒体访问数据链路层（DLL）和物理层（PHY），但是两者并不完全一致。</p>\n<p>这里主要概述了 802.11无线LAN的特征。不过首先应该关注的是无线网络与有线网络的区别。</p>\n<p>当我们寻找有线和无线网络的重要区别时，应该重点关注链路层，我们确实可以发现有线链路和无线链路有许多重要区别：</p>\n<ul>\n<li>递减的信号强度。信号强度受到发送方和接收方距离的增加而递减。</li>\n<li>来自其他源的干扰。在同一个频段发送信号的电波源会互相干扰。</li>\n<li>多径传播（multipath propagation）。当电磁波受到反射，会在发送方和接收方之间走过多条不同长度的路径，此时出现多径传播，这使得接受的信号变得模糊。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"IEEE-802-11-标准\"><a href=\"#IEEE-802-11-标准\" class=\"headerlink\" title=\"IEEE 802.11 标准\"></a>IEEE 802.11 标准</h2><p>常见的关于LAN的802.11标准包括 802.11b、802.11a、802.11g等。<br>它们使用相同的媒体访问协议CSMA/CA，并且使用相同的链路层帧格式。</p>\n<p><img src=\"802.11.jpg\" alt=\"常见协议\"></p>\n<h2 id=\"802-11-体系结构\"><a href=\"#802-11-体系结构\" class=\"headerlink\" title=\"802.11 体系结构\"></a>802.11 体系结构</h2><p>802.11 体系结构的基本构建模块是<code>基本服务集（Basic Service Set BSS）</code>，一个BBS包含<code>若干个无线站点</code>和一个被称为接入点（AP）的中央基站。与以太网设备类似，每个802.11无线站点都具有6字节的MAC地址。每个AP的无线接口也具有一个MAC地址。这些MAC地址也由IEEE管理，理论上全球唯一。</p>\n<p><img src=\"中央基站.jpg\" alt=\"中央基站实物图\"></p>\n<p><img src=\"BBS.jpg\" alt=\"BBS\"></p>\n<h3 id=\"信道与关联\"><a href=\"#信道与关联\" class=\"headerlink\" title=\"信道与关联\"></a>信道与关联</h3><p>在802.11中，每个无线站点在发送或者接受网络层数据前，必须与一个AP相关联。而安装一个AP时，需要为其分配单字或者双字的服务集标识（SSID）。除了SSID，还需要分配一个信道号。</p>\n<p>信道：</p>\n<p>802.11定义了<code>11个部分重叠的信道</code>，当且仅当2个信道由4个或更多的信道隔开时，它们才不重叠。比如 1、6、11是唯一的3个非重叠信道集合。这样就可以在同一个物理网络安装3个AP。</p>\n<p>关联：</p>\n<p>为了获得互联网接入，你的无线站点需要加入其中一个子网并需要与其中一个AP相关联（associate）。关联意味着该无线站点在自身与该AP之间创建了一个虚拟线路。</p>\n<p>然而，首先得回答：你的无线站点如何与某个特定的AP相关联？或者你的无线站点如何知道当前位置哪个AP可以使用？</p>\n<p>802.11标准要求每个AP周期性地发送<code>信标帧（beacon frame）</code>，每个信标帧包括该AP的SSID和MAC地址。<br>你的无线站点为了得知正在发送信标帧的AP，扫描11个信道，找到可能来着可能位于该区域的AP所发出的信标帧。</p>\n<p>不过，802.11标准没有指定选择哪个可用的AP进行关联的算法，这个由802.11固件和无线主机的软件设计者来设计。<br>比如，主机选择接收到的具有最高信号强度的信标帧，但可能过载。</p>\n<p>这里扫描分两种：</p>\n<ul>\n<li>被动扫描（passive scanning），自AP发送信标帧，无线站点<em>扫描信道</em>和<em>监听信标帧</em>，然后向选择的AP发送<em>关联请求帧</em>，最后AP响应<em>关联响应帧</em></li>\n<li>主动扫描（active scanning），无线站点广播<em>探测请求帧</em>，AP发送<em>探测响应</em>，然后无线站点选择AP发送<em>关联请求帧</em>，最后AP响应<em>关联响应帧</em></li>\n</ul>\n<h3 id=\"鉴别与接入\"><a href=\"#鉴别与接入\" class=\"headerlink\" title=\"鉴别与接入\"></a>鉴别与接入</h3><p>为了与特定的AP创建关联，某无线站点可能需要向该AP鉴别它自身。</p>\n<p>802.11 提供了几种不同的鉴别和接入方法</p>\n<ul>\n<li>基于站点的MAC地址允许其接入网络</li>\n<li>基于用户名和口令</li>\n</ul>\n<p>上述两种情况下，可能使用的RADIUS（基于UDP）和DIAMETER（最初作为RADIUS的改良）这样的协议。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"IEEE-802-11无线-LANs-概述\"><a href=\"#IEEE-802-11无线-LANs-概述\" class=\"headerlink\" title=\"IEEE 802.11无线 LANs 概述\"></a>IEEE 802.11无线 LANs 概述</h1><h2 id=\"无线链路和网络特征\"><a href=\"#无线链路和网络特征\" class=\"headerlink\" title=\"无线链路和网络特征\"></a>无线链路和网络特征</h2><p>802.11协议簇是国际电工电子工程学会（IEEE）为无线局域网络制定的标准。虽然WI-FI使用了802.11的媒体访问数据链路层（DLL）和物理层（PHY），但是两者并不完全一致。</p>\n<p>这里主要概述了 802.11无线LAN的特征。不过首先应该关注的是无线网络与有线网络的区别。</p>\n<p>当我们寻找有线和无线网络的重要区别时，应该重点关注链路层，我们确实可以发现有线链路和无线链路有许多重要区别：</p>\n<ul>\n<li>递减的信号强度。信号强度受到发送方和接收方距离的增加而递减。</li>\n<li>来自其他源的干扰。在同一个频段发送信号的电波源会互相干扰。</li>\n<li>多径传播（multipath propagation）。当电磁波受到反射，会在发送方和接收方之间走过多条不同长度的路径，此时出现多径传播，这使得接受的信号变得模糊。</li>\n</ul>","more":"<h2 id=\"IEEE-802-11-标准\"><a href=\"#IEEE-802-11-标准\" class=\"headerlink\" title=\"IEEE 802.11 标准\"></a>IEEE 802.11 标准</h2><p>常见的关于LAN的802.11标准包括 802.11b、802.11a、802.11g等。<br>它们使用相同的媒体访问协议CSMA/CA，并且使用相同的链路层帧格式。</p>\n<p><img src=\"802.11.jpg\" alt=\"常见协议\"></p>\n<h2 id=\"802-11-体系结构\"><a href=\"#802-11-体系结构\" class=\"headerlink\" title=\"802.11 体系结构\"></a>802.11 体系结构</h2><p>802.11 体系结构的基本构建模块是<code>基本服务集（Basic Service Set BSS）</code>，一个BBS包含<code>若干个无线站点</code>和一个被称为接入点（AP）的中央基站。与以太网设备类似，每个802.11无线站点都具有6字节的MAC地址。每个AP的无线接口也具有一个MAC地址。这些MAC地址也由IEEE管理，理论上全球唯一。</p>\n<p><img src=\"中央基站.jpg\" alt=\"中央基站实物图\"></p>\n<p><img src=\"BBS.jpg\" alt=\"BBS\"></p>\n<h3 id=\"信道与关联\"><a href=\"#信道与关联\" class=\"headerlink\" title=\"信道与关联\"></a>信道与关联</h3><p>在802.11中，每个无线站点在发送或者接受网络层数据前，必须与一个AP相关联。而安装一个AP时，需要为其分配单字或者双字的服务集标识（SSID）。除了SSID，还需要分配一个信道号。</p>\n<p>信道：</p>\n<p>802.11定义了<code>11个部分重叠的信道</code>，当且仅当2个信道由4个或更多的信道隔开时，它们才不重叠。比如 1、6、11是唯一的3个非重叠信道集合。这样就可以在同一个物理网络安装3个AP。</p>\n<p>关联：</p>\n<p>为了获得互联网接入，你的无线站点需要加入其中一个子网并需要与其中一个AP相关联（associate）。关联意味着该无线站点在自身与该AP之间创建了一个虚拟线路。</p>\n<p>然而，首先得回答：你的无线站点如何与某个特定的AP相关联？或者你的无线站点如何知道当前位置哪个AP可以使用？</p>\n<p>802.11标准要求每个AP周期性地发送<code>信标帧（beacon frame）</code>，每个信标帧包括该AP的SSID和MAC地址。<br>你的无线站点为了得知正在发送信标帧的AP，扫描11个信道，找到可能来着可能位于该区域的AP所发出的信标帧。</p>\n<p>不过，802.11标准没有指定选择哪个可用的AP进行关联的算法，这个由802.11固件和无线主机的软件设计者来设计。<br>比如，主机选择接收到的具有最高信号强度的信标帧，但可能过载。</p>\n<p>这里扫描分两种：</p>\n<ul>\n<li>被动扫描（passive scanning），自AP发送信标帧，无线站点<em>扫描信道</em>和<em>监听信标帧</em>，然后向选择的AP发送<em>关联请求帧</em>，最后AP响应<em>关联响应帧</em></li>\n<li>主动扫描（active scanning），无线站点广播<em>探测请求帧</em>，AP发送<em>探测响应</em>，然后无线站点选择AP发送<em>关联请求帧</em>，最后AP响应<em>关联响应帧</em></li>\n</ul>\n<h3 id=\"鉴别与接入\"><a href=\"#鉴别与接入\" class=\"headerlink\" title=\"鉴别与接入\"></a>鉴别与接入</h3><p>为了与特定的AP创建关联，某无线站点可能需要向该AP鉴别它自身。</p>\n<p>802.11 提供了几种不同的鉴别和接入方法</p>\n<ul>\n<li>基于站点的MAC地址允许其接入网络</li>\n<li>基于用户名和口令</li>\n</ul>\n<p>上述两种情况下，可能使用的RADIUS（基于UDP）和DIAMETER（最初作为RADIUS的改良）这样的协议。</p>"},{"title":"Install MySQL5.7","date":"2017-10-26T05:30:18.000Z","_content":"\n大二数据库原理的作业，发现还存在电脑里，于是稍微整理下放到博客里。\n\n<!-- more -->\n\n# windows下mysql安装\n\n我下载的是zip压缩包，假设解压到`D:\\software`目录下，官网下载的只有服务端和简单的`shell`，可以去搜索`Navicat`客户端，支持多种数据库管理系统，下载`MySQL`客户端，也支持`MariaDB`使用。\n\n注意：Navicat是收费的，免费使用14天。你还可以使用其他客户端，比如phpAdminMySQL。\n\n## mysql的简单配置\n\nmysql的目录结构如下\n\n![](mysql目录结构.png)\n\n环境变量需要配置bin目录，mysql的程序都在bin目录下，所以环境变量是在PATH变量上新增`D:\\software\\mysql\\bin`。\n\n各个版本目录可能不同，data目录存放系统数据，一开始应该没有，需要自己新建。\n\n另一个重要的是my.ini文件(或my-default.ini)，需要进行一些简单的配置才能使用。\n\n```ini\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set = utf8\n\n[mysqld]\n#skip_grant_tables  这个先不要，这是忽略权限。\n#设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir = \"D:/software/mysql-5.7.16-winx64\"\n# 设置mysql数据库的数据的存放目录\ndatadir = \"D:/software/mysql-5.7.16-winx64/data\"\n# 允许最大连接数\nmax_connections = 200\n# 服务端使用的字符集默认为8比特编码的latin1字符集，我们改为通用的utf8\ncharacter-set-server = utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine = INNODB\n```\n\n常用的2个程序是`mysql`和`mysqld`，需要给服务端设置一些配置，如上，语法跟作用一目了然。\n\nwindows下运行mysql需要使用`cmd管理员权限`，使用`net start mysql` 启动mysql服务，`net stop mysql` 关闭服务。\n\n一开始需要使用`root`帐号登录，不需要密码，在命令行下使用`mysql -u root -p`登录，进入shell后可以使用`help`命令查看简单的用法。\n\n具体其他使用方法请查看文档手册或者搜索引擎。\n\n## Navicat 客户端简单使用\n\n按照安装包的引导安装即可。\n\n![](Navicat使用期限.png)\n\n注意使用期限是14天。\n\n![](Navicat使用界面.png)\n\nNavicat界面比较简洁，也只提供基本的功能，如需要使用强大的功能可能需要购买或使用其他客户端。\n\nNavicat窗口帮助下可以打开本地中文文档，可以查看各种数据库的使用。\n\n在文件下建立数据库连接写好帐号密码即可连接（不要忘记先在cmd管理员权限下启动mysql服务）。\n\n然后可以简单的开始操作DBMS了。\n\n![](操作界面.png)\n\n# linux ubuntu 命令行下mysql安装\n\n我选择最简单的安装方式\n\n![](pic/mysql安装.png)\n\n如上，用`sudo apt install mysql-server-5.7`下载\n\n当然你可以先用图形界面找到需要的版本的包或者路径，用wget等工具下载，这里不详细说明，总体思路跟windows下是一致的。\n\n![](mysql安装路径.png)\n\n用 `whereis mysql` 命令查看mysql等命令已经添加到环境变量中。\n\n![](mysql启动.png)\n\n如图，用`sudo service mysql start` 启动，即使远程连接断开也在后台运行，`mysql -u root -p`登录root用户连接mysql，可以用`ps -ef | grep mysql` 来查看。\n\n![](查看mysql字符编码.png)\n\n登录以后，在mysql下用`show variables like 'character%` 可以查看一些字符相关的环境配置，发现很多是latin1编码，我们需要改为utf8编码\n\n我们来到/etc/mysql目录下，这里存放许多mysql的配置。我们修改一些配置`sudo vim mysql.conf.d/mysqld.cnf`，在`[mysqld]`下配置`character-set-server = utf8`，当然在这里你还可以修改一些其他配置。\n\n继续修改另外一个配置`sudo vim conf.d/mysql.cnf`，在`[mysql]`下配置`default-character-set = utf8`，这样重启mysql后字符编码就改变了如下：\n\n![](mysql配置完成.png)\n\n---\n以上，最基本的配置就完成了，大概作为学习用途已经足够了，再复杂的配置得参考相应的资料了。","source":"_posts/Install-MySQL5-7.md","raw":"---\ntitle: Install MySQL5.7\ndate: 2017-10-26 13:30:18\ntags: Database\ncategory: study\n---\n\n大二数据库原理的作业，发现还存在电脑里，于是稍微整理下放到博客里。\n\n<!-- more -->\n\n# windows下mysql安装\n\n我下载的是zip压缩包，假设解压到`D:\\software`目录下，官网下载的只有服务端和简单的`shell`，可以去搜索`Navicat`客户端，支持多种数据库管理系统，下载`MySQL`客户端，也支持`MariaDB`使用。\n\n注意：Navicat是收费的，免费使用14天。你还可以使用其他客户端，比如phpAdminMySQL。\n\n## mysql的简单配置\n\nmysql的目录结构如下\n\n![](mysql目录结构.png)\n\n环境变量需要配置bin目录，mysql的程序都在bin目录下，所以环境变量是在PATH变量上新增`D:\\software\\mysql\\bin`。\n\n各个版本目录可能不同，data目录存放系统数据，一开始应该没有，需要自己新建。\n\n另一个重要的是my.ini文件(或my-default.ini)，需要进行一些简单的配置才能使用。\n\n```ini\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set = utf8\n\n[mysqld]\n#skip_grant_tables  这个先不要，这是忽略权限。\n#设置3306端口\nport = 3306\n# 设置mysql的安装目录\nbasedir = \"D:/software/mysql-5.7.16-winx64\"\n# 设置mysql数据库的数据的存放目录\ndatadir = \"D:/software/mysql-5.7.16-winx64/data\"\n# 允许最大连接数\nmax_connections = 200\n# 服务端使用的字符集默认为8比特编码的latin1字符集，我们改为通用的utf8\ncharacter-set-server = utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine = INNODB\n```\n\n常用的2个程序是`mysql`和`mysqld`，需要给服务端设置一些配置，如上，语法跟作用一目了然。\n\nwindows下运行mysql需要使用`cmd管理员权限`，使用`net start mysql` 启动mysql服务，`net stop mysql` 关闭服务。\n\n一开始需要使用`root`帐号登录，不需要密码，在命令行下使用`mysql -u root -p`登录，进入shell后可以使用`help`命令查看简单的用法。\n\n具体其他使用方法请查看文档手册或者搜索引擎。\n\n## Navicat 客户端简单使用\n\n按照安装包的引导安装即可。\n\n![](Navicat使用期限.png)\n\n注意使用期限是14天。\n\n![](Navicat使用界面.png)\n\nNavicat界面比较简洁，也只提供基本的功能，如需要使用强大的功能可能需要购买或使用其他客户端。\n\nNavicat窗口帮助下可以打开本地中文文档，可以查看各种数据库的使用。\n\n在文件下建立数据库连接写好帐号密码即可连接（不要忘记先在cmd管理员权限下启动mysql服务）。\n\n然后可以简单的开始操作DBMS了。\n\n![](操作界面.png)\n\n# linux ubuntu 命令行下mysql安装\n\n我选择最简单的安装方式\n\n![](pic/mysql安装.png)\n\n如上，用`sudo apt install mysql-server-5.7`下载\n\n当然你可以先用图形界面找到需要的版本的包或者路径，用wget等工具下载，这里不详细说明，总体思路跟windows下是一致的。\n\n![](mysql安装路径.png)\n\n用 `whereis mysql` 命令查看mysql等命令已经添加到环境变量中。\n\n![](mysql启动.png)\n\n如图，用`sudo service mysql start` 启动，即使远程连接断开也在后台运行，`mysql -u root -p`登录root用户连接mysql，可以用`ps -ef | grep mysql` 来查看。\n\n![](查看mysql字符编码.png)\n\n登录以后，在mysql下用`show variables like 'character%` 可以查看一些字符相关的环境配置，发现很多是latin1编码，我们需要改为utf8编码\n\n我们来到/etc/mysql目录下，这里存放许多mysql的配置。我们修改一些配置`sudo vim mysql.conf.d/mysqld.cnf`，在`[mysqld]`下配置`character-set-server = utf8`，当然在这里你还可以修改一些其他配置。\n\n继续修改另外一个配置`sudo vim conf.d/mysql.cnf`，在`[mysql]`下配置`default-character-set = utf8`，这样重启mysql后字符编码就改变了如下：\n\n![](mysql配置完成.png)\n\n---\n以上，最基本的配置就完成了，大概作为学习用途已经足够了，再复杂的配置得参考相应的资料了。","slug":"Install-MySQL5-7","published":1,"updated":"2017-10-26T05:37:01.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y7d000a6svsdainlp2b","content":"<p>大二数据库原理的作业，发现还存在电脑里，于是稍微整理下放到博客里。</p>\n<a id=\"more\"></a>\n<h1 id=\"windows下mysql安装\"><a href=\"#windows下mysql安装\" class=\"headerlink\" title=\"windows下mysql安装\"></a>windows下mysql安装</h1><p>我下载的是zip压缩包，假设解压到<code>D:\\software</code>目录下，官网下载的只有服务端和简单的<code>shell</code>，可以去搜索<code>Navicat</code>客户端，支持多种数据库管理系统，下载<code>MySQL</code>客户端，也支持<code>MariaDB</code>使用。</p>\n<p>注意：Navicat是收费的，免费使用14天。你还可以使用其他客户端，比如phpAdminMySQL。</p>\n<h2 id=\"mysql的简单配置\"><a href=\"#mysql的简单配置\" class=\"headerlink\" title=\"mysql的简单配置\"></a>mysql的简单配置</h2><p>mysql的目录结构如下</p>\n<p><img src=\"mysql目录结构.png\" alt=\"\"></p>\n<p>环境变量需要配置bin目录，mysql的程序都在bin目录下，所以环境变量是在PATH变量上新增<code>D:\\software\\mysql\\bin</code>。</p>\n<p>各个版本目录可能不同，data目录存放系统数据，一开始应该没有，需要自己新建。</p>\n<p>另一个重要的是my.ini文件(或my-default.ini)，需要进行一些简单的配置才能使用。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">[mysql]</span></div><div class=\"line\"><span class=\"comment\"># 设置mysql客户端默认字符集</span></div><div class=\"line\"><span class=\"attr\">default-character-set</span> = utf8</div><div class=\"line\"></div><div class=\"line\"><span class=\"section\">[mysqld]</span></div><div class=\"line\"><span class=\"comment\">#skip_grant_tables  这个先不要，这是忽略权限。</span></div><div class=\"line\"><span class=\"comment\">#设置3306端口</span></div><div class=\"line\"><span class=\"attr\">port</span> = <span class=\"number\">3306</span></div><div class=\"line\"><span class=\"comment\"># 设置mysql的安装目录</span></div><div class=\"line\"><span class=\"attr\">basedir</span> = <span class=\"string\">\"D:/software/mysql-5.7.16-winx64\"</span></div><div class=\"line\"><span class=\"comment\"># 设置mysql数据库的数据的存放目录</span></div><div class=\"line\"><span class=\"attr\">datadir</span> = <span class=\"string\">\"D:/software/mysql-5.7.16-winx64/data\"</span></div><div class=\"line\"><span class=\"comment\"># 允许最大连接数</span></div><div class=\"line\"><span class=\"attr\">max_connections</span> = <span class=\"number\">200</span></div><div class=\"line\"><span class=\"comment\"># 服务端使用的字符集默认为8比特编码的latin1字符集，我们改为通用的utf8</span></div><div class=\"line\"><span class=\"attr\">character-set-server</span> = utf8</div><div class=\"line\"><span class=\"comment\"># 创建新表时将使用的默认存储引擎</span></div><div class=\"line\"><span class=\"attr\">default-storage-engine</span> = INNODB</div></pre></td></tr></table></figure>\n<p>常用的2个程序是<code>mysql</code>和<code>mysqld</code>，需要给服务端设置一些配置，如上，语法跟作用一目了然。</p>\n<p>windows下运行mysql需要使用<code>cmd管理员权限</code>，使用<code>net start mysql</code> 启动mysql服务，<code>net stop mysql</code> 关闭服务。</p>\n<p>一开始需要使用<code>root</code>帐号登录，不需要密码，在命令行下使用<code>mysql -u root -p</code>登录，进入shell后可以使用<code>help</code>命令查看简单的用法。</p>\n<p>具体其他使用方法请查看文档手册或者搜索引擎。</p>\n<h2 id=\"Navicat-客户端简单使用\"><a href=\"#Navicat-客户端简单使用\" class=\"headerlink\" title=\"Navicat 客户端简单使用\"></a>Navicat 客户端简单使用</h2><p>按照安装包的引导安装即可。</p>\n<p><img src=\"Navicat使用期限.png\" alt=\"\"></p>\n<p>注意使用期限是14天。</p>\n<p><img src=\"Navicat使用界面.png\" alt=\"\"></p>\n<p>Navicat界面比较简洁，也只提供基本的功能，如需要使用强大的功能可能需要购买或使用其他客户端。</p>\n<p>Navicat窗口帮助下可以打开本地中文文档，可以查看各种数据库的使用。</p>\n<p>在文件下建立数据库连接写好帐号密码即可连接（不要忘记先在cmd管理员权限下启动mysql服务）。</p>\n<p>然后可以简单的开始操作DBMS了。</p>\n<p><img src=\"操作界面.png\" alt=\"\"></p>\n<h1 id=\"linux-ubuntu-命令行下mysql安装\"><a href=\"#linux-ubuntu-命令行下mysql安装\" class=\"headerlink\" title=\"linux ubuntu 命令行下mysql安装\"></a>linux ubuntu 命令行下mysql安装</h1><p>我选择最简单的安装方式</p>\n<p><img src=\"pic/mysql安装.png\" alt=\"\"></p>\n<p>如上，用<code>sudo apt install mysql-server-5.7</code>下载</p>\n<p>当然你可以先用图形界面找到需要的版本的包或者路径，用wget等工具下载，这里不详细说明，总体思路跟windows下是一致的。</p>\n<p><img src=\"mysql安装路径.png\" alt=\"\"></p>\n<p>用 <code>whereis mysql</code> 命令查看mysql等命令已经添加到环境变量中。</p>\n<p><img src=\"mysql启动.png\" alt=\"\"></p>\n<p>如图，用<code>sudo service mysql start</code> 启动，即使远程连接断开也在后台运行，<code>mysql -u root -p</code>登录root用户连接mysql，可以用<code>ps -ef | grep mysql</code> 来查看。</p>\n<p><img src=\"查看mysql字符编码.png\" alt=\"\"></p>\n<p>登录以后，在mysql下用<code>show variables like &#39;character%</code> 可以查看一些字符相关的环境配置，发现很多是latin1编码，我们需要改为utf8编码</p>\n<p>我们来到/etc/mysql目录下，这里存放许多mysql的配置。我们修改一些配置<code>sudo vim mysql.conf.d/mysqld.cnf</code>，在<code>[mysqld]</code>下配置<code>character-set-server = utf8</code>，当然在这里你还可以修改一些其他配置。</p>\n<p>继续修改另外一个配置<code>sudo vim conf.d/mysql.cnf</code>，在<code>[mysql]</code>下配置<code>default-character-set = utf8</code>，这样重启mysql后字符编码就改变了如下：</p>\n<p><img src=\"mysql配置完成.png\" alt=\"\"></p>\n<hr>\n<p>以上，最基本的配置就完成了，大概作为学习用途已经足够了，再复杂的配置得参考相应的资料了。</p>\n","site":{"data":{}},"excerpt":"<p>大二数据库原理的作业，发现还存在电脑里，于是稍微整理下放到博客里。</p>","more":"<h1 id=\"windows下mysql安装\"><a href=\"#windows下mysql安装\" class=\"headerlink\" title=\"windows下mysql安装\"></a>windows下mysql安装</h1><p>我下载的是zip压缩包，假设解压到<code>D:\\software</code>目录下，官网下载的只有服务端和简单的<code>shell</code>，可以去搜索<code>Navicat</code>客户端，支持多种数据库管理系统，下载<code>MySQL</code>客户端，也支持<code>MariaDB</code>使用。</p>\n<p>注意：Navicat是收费的，免费使用14天。你还可以使用其他客户端，比如phpAdminMySQL。</p>\n<h2 id=\"mysql的简单配置\"><a href=\"#mysql的简单配置\" class=\"headerlink\" title=\"mysql的简单配置\"></a>mysql的简单配置</h2><p>mysql的目录结构如下</p>\n<p><img src=\"mysql目录结构.png\" alt=\"\"></p>\n<p>环境变量需要配置bin目录，mysql的程序都在bin目录下，所以环境变量是在PATH变量上新增<code>D:\\software\\mysql\\bin</code>。</p>\n<p>各个版本目录可能不同，data目录存放系统数据，一开始应该没有，需要自己新建。</p>\n<p>另一个重要的是my.ini文件(或my-default.ini)，需要进行一些简单的配置才能使用。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"section\">[mysql]</span></div><div class=\"line\"><span class=\"comment\"># 设置mysql客户端默认字符集</span></div><div class=\"line\"><span class=\"attr\">default-character-set</span> = utf8</div><div class=\"line\"></div><div class=\"line\"><span class=\"section\">[mysqld]</span></div><div class=\"line\"><span class=\"comment\">#skip_grant_tables  这个先不要，这是忽略权限。</span></div><div class=\"line\"><span class=\"comment\">#设置3306端口</span></div><div class=\"line\"><span class=\"attr\">port</span> = <span class=\"number\">3306</span></div><div class=\"line\"><span class=\"comment\"># 设置mysql的安装目录</span></div><div class=\"line\"><span class=\"attr\">basedir</span> = <span class=\"string\">\"D:/software/mysql-5.7.16-winx64\"</span></div><div class=\"line\"><span class=\"comment\"># 设置mysql数据库的数据的存放目录</span></div><div class=\"line\"><span class=\"attr\">datadir</span> = <span class=\"string\">\"D:/software/mysql-5.7.16-winx64/data\"</span></div><div class=\"line\"><span class=\"comment\"># 允许最大连接数</span></div><div class=\"line\"><span class=\"attr\">max_connections</span> = <span class=\"number\">200</span></div><div class=\"line\"><span class=\"comment\"># 服务端使用的字符集默认为8比特编码的latin1字符集，我们改为通用的utf8</span></div><div class=\"line\"><span class=\"attr\">character-set-server</span> = utf8</div><div class=\"line\"><span class=\"comment\"># 创建新表时将使用的默认存储引擎</span></div><div class=\"line\"><span class=\"attr\">default-storage-engine</span> = INNODB</div></pre></td></tr></table></figure>\n<p>常用的2个程序是<code>mysql</code>和<code>mysqld</code>，需要给服务端设置一些配置，如上，语法跟作用一目了然。</p>\n<p>windows下运行mysql需要使用<code>cmd管理员权限</code>，使用<code>net start mysql</code> 启动mysql服务，<code>net stop mysql</code> 关闭服务。</p>\n<p>一开始需要使用<code>root</code>帐号登录，不需要密码，在命令行下使用<code>mysql -u root -p</code>登录，进入shell后可以使用<code>help</code>命令查看简单的用法。</p>\n<p>具体其他使用方法请查看文档手册或者搜索引擎。</p>\n<h2 id=\"Navicat-客户端简单使用\"><a href=\"#Navicat-客户端简单使用\" class=\"headerlink\" title=\"Navicat 客户端简单使用\"></a>Navicat 客户端简单使用</h2><p>按照安装包的引导安装即可。</p>\n<p><img src=\"Navicat使用期限.png\" alt=\"\"></p>\n<p>注意使用期限是14天。</p>\n<p><img src=\"Navicat使用界面.png\" alt=\"\"></p>\n<p>Navicat界面比较简洁，也只提供基本的功能，如需要使用强大的功能可能需要购买或使用其他客户端。</p>\n<p>Navicat窗口帮助下可以打开本地中文文档，可以查看各种数据库的使用。</p>\n<p>在文件下建立数据库连接写好帐号密码即可连接（不要忘记先在cmd管理员权限下启动mysql服务）。</p>\n<p>然后可以简单的开始操作DBMS了。</p>\n<p><img src=\"操作界面.png\" alt=\"\"></p>\n<h1 id=\"linux-ubuntu-命令行下mysql安装\"><a href=\"#linux-ubuntu-命令行下mysql安装\" class=\"headerlink\" title=\"linux ubuntu 命令行下mysql安装\"></a>linux ubuntu 命令行下mysql安装</h1><p>我选择最简单的安装方式</p>\n<p><img src=\"pic/mysql安装.png\" alt=\"\"></p>\n<p>如上，用<code>sudo apt install mysql-server-5.7</code>下载</p>\n<p>当然你可以先用图形界面找到需要的版本的包或者路径，用wget等工具下载，这里不详细说明，总体思路跟windows下是一致的。</p>\n<p><img src=\"mysql安装路径.png\" alt=\"\"></p>\n<p>用 <code>whereis mysql</code> 命令查看mysql等命令已经添加到环境变量中。</p>\n<p><img src=\"mysql启动.png\" alt=\"\"></p>\n<p>如图，用<code>sudo service mysql start</code> 启动，即使远程连接断开也在后台运行，<code>mysql -u root -p</code>登录root用户连接mysql，可以用<code>ps -ef | grep mysql</code> 来查看。</p>\n<p><img src=\"查看mysql字符编码.png\" alt=\"\"></p>\n<p>登录以后，在mysql下用<code>show variables like &#39;character%</code> 可以查看一些字符相关的环境配置，发现很多是latin1编码，我们需要改为utf8编码</p>\n<p>我们来到/etc/mysql目录下，这里存放许多mysql的配置。我们修改一些配置<code>sudo vim mysql.conf.d/mysqld.cnf</code>，在<code>[mysqld]</code>下配置<code>character-set-server = utf8</code>，当然在这里你还可以修改一些其他配置。</p>\n<p>继续修改另外一个配置<code>sudo vim conf.d/mysql.cnf</code>，在<code>[mysql]</code>下配置<code>default-character-set = utf8</code>，这样重启mysql后字符编码就改变了如下：</p>\n<p><img src=\"mysql配置完成.png\" alt=\"\"></p>\n<hr>\n<p>以上，最基本的配置就完成了，大概作为学习用途已经足够了，再复杂的配置得参考相应的资料了。</p>"},{"title":"k-means","date":"2017-08-08T08:18:09.000Z","categry":"study","_content":"\n公式排版目前没法解决唉，博客写个数学公式怎么这么揪心，好不容易解决了公式显示问题，但排版又很难控制\n\n# k-means\n\n## 基本原理\n\n这个星期学无监督学习(unsuperviser-learning), 最基本的是k-means算法.\nk-means属于`原型聚类`:假设聚类结构能通过一组原型刻画. 而聚类本身是根据数据相似度来划分的,即\"距离\".我这里不展开讲距离计算, 姑且用欧几里德距离来理解，即平时最常见的公式.\n{% raw %}\n\n我们先写出k-means的最小化平方误差: 给定样本集合 $D = {x_1, x_2, \\dots, x_m}$,\n\nk-means对聚类所得的簇划分 $C = {C_1, C_2, \\dots, C_k}$\n的最小平方误差是 $E = \\sum_{i=1}^k \\sum_{x \\in C_i} ||x - \\mu_i||_2^2 $,\n\n其中 $\\mu_i = \\frac{1}{|C_i|} \\sum_{x \\in C_i}x$是簇$ C_i $ 的均值向量\n{% endraw %}\n\n可以看出来, 求该式子的最优解并不容易, 因为需要考察每个样本可能的划分情况(`NP难问题`),\n所以k-means 采用贪心策略, 通过迭代优化求近似解.\n\n感觉学完以上内容, 脑子里好像有了这个算法的轮廓了, 但仔细一想, 还有很多地方需要斟酌.\nk-means是划分为k个类别, 那一开始怎么划分呢?\n我们想到一开始需要选k个样本当作中心点来计算距离, 根据这k个位置就求得每个样本离哪个位置最接近. 这样,第一次聚类就完成了, 但是由于这次聚类造成每个类别的中心点发生了偏移,\n\n我们需要重新计算这时候的中心点,而由于发生了偏移,我们又需要重新计算所有样本最接近的... 如何反复,直到中心点(即均值向量)不变, 便完成了聚类. \n\n如此说来, 这个算法还是蛮朴素的, 但是还有需要斟酌的地方.\n如何选初始点呢？万一2个点靠得近，或者是离群点, 岂不是可能会出现很极端的聚类(比如一个人一个类别).个人觉得这有时候很难避免, 但可以通过多次随机选取初始点并评估各个聚类的效果(最小平方误差),来减少这种情况.\n\n嗯,好像对算法的轮廓又清晰了, 但可能又有疑问, 到底如何选择k值呢?这里应该要具体问题具体分析了.如果只是想得到更好的性能, 把应该把k值从小到大递增来比较选择最优, 但这不一定给你带来实际上的最大收益.比如你是服装商, 把消费者划分了不同尺码的类别来针对客户进行推荐商品, 那到底多细才最优呢,反正我是不知道, 这得根据实际情况和专家经验来决策,而k-means在这里不充当决策者, 更像是打下手的.\n\n扯远了,总之对于k-means, 知道k值我觉得往往很关键.\n\n## 算法伪代码\n\n这样子算法应该比较清晰了,我下来列出(抄上)伪代码, 参考自周志华的西瓜书:\n\n{% raw %}\n输入: \n样本集 $D = \\{x_1, x_2, ..., x_m\\}$, 聚类簇数 k\n\n过程:\n从D中随机选择k个样本作为初始均值向量 $\\{\\mu_1, \\mu_2, ..., \\mu_k\\}$\nrepeat \n\t$C_i = \\emptyset$\n\tfor j = 1, 2, ..., m do\n\t\t计算$x_j$与各均值向量 \\mu_i(1 \\leq i \\leq k)的距离: $d_ji = ||x_i - \\mu_i||_2$;\n\t\t根据距离最近的均值向量确定x_j的簇标记: $\\lambda_j = argmin_{i \\in \\{1,2,...,k\\}}d_ij$;\n\t\t将样本$x_j$划入相应的簇: $C_{\\lambda_j} = C_{\\lambda_j} \\bigcup\\{x_j\\}$\n\tend for\n\n\tfor i = 1, 2, ..., k do\n\t\t计算新均值向量: $\\mu_i^` = \\frac{1}{|C_i|}\\sum_{x \\in C_i|}x$;\n\t\tif $\\mu_i^ \\ne\\mu_i$ then\n\t\t\t更新 $\\mu_i$\n\t\telse\n\t\t\t保持当前均值向量不变\n\t\tend if\n\n\tend for\n\nutil 当前均值向量都没有更新\n\n输出: 簇划分 $C = \\{C_1, C_2, ..., C_k\\}$\n{% endraw %}\n\n## 扯淡\n\n暂时先写到这里,第一次写latex,第一次写博客,写的不好请见谅,以上大段文字\n有些是建立在自己的理解写的,如果有错误,希望能不吝赐教.写的比较浅,其实也没什么意思啊,就是梳理下自己跟其他同学的思路.","source":"_posts/k-means.md","raw":"---\ntitle: k-means\ndate: 2017-08-08 16:18:09\ntags: ML\ncategry: study\n---\n\n公式排版目前没法解决唉，博客写个数学公式怎么这么揪心，好不容易解决了公式显示问题，但排版又很难控制\n\n# k-means\n\n## 基本原理\n\n这个星期学无监督学习(unsuperviser-learning), 最基本的是k-means算法.\nk-means属于`原型聚类`:假设聚类结构能通过一组原型刻画. 而聚类本身是根据数据相似度来划分的,即\"距离\".我这里不展开讲距离计算, 姑且用欧几里德距离来理解，即平时最常见的公式.\n{% raw %}\n\n我们先写出k-means的最小化平方误差: 给定样本集合 $D = {x_1, x_2, \\dots, x_m}$,\n\nk-means对聚类所得的簇划分 $C = {C_1, C_2, \\dots, C_k}$\n的最小平方误差是 $E = \\sum_{i=1}^k \\sum_{x \\in C_i} ||x - \\mu_i||_2^2 $,\n\n其中 $\\mu_i = \\frac{1}{|C_i|} \\sum_{x \\in C_i}x$是簇$ C_i $ 的均值向量\n{% endraw %}\n\n可以看出来, 求该式子的最优解并不容易, 因为需要考察每个样本可能的划分情况(`NP难问题`),\n所以k-means 采用贪心策略, 通过迭代优化求近似解.\n\n感觉学完以上内容, 脑子里好像有了这个算法的轮廓了, 但仔细一想, 还有很多地方需要斟酌.\nk-means是划分为k个类别, 那一开始怎么划分呢?\n我们想到一开始需要选k个样本当作中心点来计算距离, 根据这k个位置就求得每个样本离哪个位置最接近. 这样,第一次聚类就完成了, 但是由于这次聚类造成每个类别的中心点发生了偏移,\n\n我们需要重新计算这时候的中心点,而由于发生了偏移,我们又需要重新计算所有样本最接近的... 如何反复,直到中心点(即均值向量)不变, 便完成了聚类. \n\n如此说来, 这个算法还是蛮朴素的, 但是还有需要斟酌的地方.\n如何选初始点呢？万一2个点靠得近，或者是离群点, 岂不是可能会出现很极端的聚类(比如一个人一个类别).个人觉得这有时候很难避免, 但可以通过多次随机选取初始点并评估各个聚类的效果(最小平方误差),来减少这种情况.\n\n嗯,好像对算法的轮廓又清晰了, 但可能又有疑问, 到底如何选择k值呢?这里应该要具体问题具体分析了.如果只是想得到更好的性能, 把应该把k值从小到大递增来比较选择最优, 但这不一定给你带来实际上的最大收益.比如你是服装商, 把消费者划分了不同尺码的类别来针对客户进行推荐商品, 那到底多细才最优呢,反正我是不知道, 这得根据实际情况和专家经验来决策,而k-means在这里不充当决策者, 更像是打下手的.\n\n扯远了,总之对于k-means, 知道k值我觉得往往很关键.\n\n## 算法伪代码\n\n这样子算法应该比较清晰了,我下来列出(抄上)伪代码, 参考自周志华的西瓜书:\n\n{% raw %}\n输入: \n样本集 $D = \\{x_1, x_2, ..., x_m\\}$, 聚类簇数 k\n\n过程:\n从D中随机选择k个样本作为初始均值向量 $\\{\\mu_1, \\mu_2, ..., \\mu_k\\}$\nrepeat \n\t$C_i = \\emptyset$\n\tfor j = 1, 2, ..., m do\n\t\t计算$x_j$与各均值向量 \\mu_i(1 \\leq i \\leq k)的距离: $d_ji = ||x_i - \\mu_i||_2$;\n\t\t根据距离最近的均值向量确定x_j的簇标记: $\\lambda_j = argmin_{i \\in \\{1,2,...,k\\}}d_ij$;\n\t\t将样本$x_j$划入相应的簇: $C_{\\lambda_j} = C_{\\lambda_j} \\bigcup\\{x_j\\}$\n\tend for\n\n\tfor i = 1, 2, ..., k do\n\t\t计算新均值向量: $\\mu_i^` = \\frac{1}{|C_i|}\\sum_{x \\in C_i|}x$;\n\t\tif $\\mu_i^ \\ne\\mu_i$ then\n\t\t\t更新 $\\mu_i$\n\t\telse\n\t\t\t保持当前均值向量不变\n\t\tend if\n\n\tend for\n\nutil 当前均值向量都没有更新\n\n输出: 簇划分 $C = \\{C_1, C_2, ..., C_k\\}$\n{% endraw %}\n\n## 扯淡\n\n暂时先写到这里,第一次写latex,第一次写博客,写的不好请见谅,以上大段文字\n有些是建立在自己的理解写的,如果有错误,希望能不吝赐教.写的比较浅,其实也没什么意思啊,就是梳理下自己跟其他同学的思路.","slug":"k-means","published":1,"updated":"2017-09-19T14:59:58.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y7h000e6svsuvuijhho","content":"<p>公式排版目前没法解决唉，博客写个数学公式怎么这么揪心，好不容易解决了公式显示问题，但排版又很难控制</p>\n<h1 id=\"k-means\"><a href=\"#k-means\" class=\"headerlink\" title=\"k-means\"></a>k-means</h1><h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>这个星期学无监督学习(unsuperviser-learning), 最基本的是k-means算法.<br>k-means属于<code>原型聚类</code>:假设聚类结构能通过一组原型刻画. 而聚类本身是根据数据相似度来划分的,即”距离”.我这里不展开讲距离计算, 姑且用欧几里德距离来理解，即平时最常见的公式.<br>\n\n我们先写出k-means的最小化平方误差: 给定样本集合 $D = {x_1, x_2, \\dots, x_m}$,\n\nk-means对聚类所得的簇划分 $C = {C_1, C_2, \\dots, C_k}$\n的最小平方误差是 $E = \\sum_{i=1}^k \\sum_{x \\in C_i} ||x - \\mu_i||_2^2 $,\n\n其中 $\\mu_i = \\frac{1}{|C_i|} \\sum_{x \\in C_i}x$是簇$ C_i $ 的均值向量\n</p>\n<p>可以看出来, 求该式子的最优解并不容易, 因为需要考察每个样本可能的划分情况(<code>NP难问题</code>),<br>所以k-means 采用贪心策略, 通过迭代优化求近似解.</p>\n<p>感觉学完以上内容, 脑子里好像有了这个算法的轮廓了, 但仔细一想, 还有很多地方需要斟酌.<br>k-means是划分为k个类别, 那一开始怎么划分呢?<br>我们想到一开始需要选k个样本当作中心点来计算距离, 根据这k个位置就求得每个样本离哪个位置最接近. 这样,第一次聚类就完成了, 但是由于这次聚类造成每个类别的中心点发生了偏移,</p>\n<p>我们需要重新计算这时候的中心点,而由于发生了偏移,我们又需要重新计算所有样本最接近的… 如何反复,直到中心点(即均值向量)不变, 便完成了聚类. </p>\n<p>如此说来, 这个算法还是蛮朴素的, 但是还有需要斟酌的地方.<br>如何选初始点呢？万一2个点靠得近，或者是离群点, 岂不是可能会出现很极端的聚类(比如一个人一个类别).个人觉得这有时候很难避免, 但可以通过多次随机选取初始点并评估各个聚类的效果(最小平方误差),来减少这种情况.</p>\n<p>嗯,好像对算法的轮廓又清晰了, 但可能又有疑问, 到底如何选择k值呢?这里应该要具体问题具体分析了.如果只是想得到更好的性能, 把应该把k值从小到大递增来比较选择最优, 但这不一定给你带来实际上的最大收益.比如你是服装商, 把消费者划分了不同尺码的类别来针对客户进行推荐商品, 那到底多细才最优呢,反正我是不知道, 这得根据实际情况和专家经验来决策,而k-means在这里不充当决策者, 更像是打下手的.</p>\n<p>扯远了,总之对于k-means, 知道k值我觉得往往很关键.</p>\n<h2 id=\"算法伪代码\"><a href=\"#算法伪代码\" class=\"headerlink\" title=\"算法伪代码\"></a>算法伪代码</h2><p>这样子算法应该比较清晰了,我下来列出(抄上)伪代码, 参考自周志华的西瓜书:</p>\n\n输入: \n样本集 $D = \\{x_1, x_2, ..., x_m\\}$, 聚类簇数 k\n\n过程:\n从D中随机选择k个样本作为初始均值向量 $\\{\\mu_1, \\mu_2, ..., \\mu_k\\}$\nrepeat \n\t$C_i = \\emptyset$\n\tfor j = 1, 2, ..., m do\n\t\t计算$x_j$与各均值向量 \\mu_i(1 \\leq i \\leq k)的距离: $d_ji = ||x_i - \\mu_i||_2$;\n\t\t根据距离最近的均值向量确定x_j的簇标记: $\\lambda_j = argmin_{i \\in \\{1,2,...,k\\}}d_ij$;\n\t\t将样本$x_j$划入相应的簇: $C_{\\lambda_j} = C_{\\lambda_j} \\bigcup\\{x_j\\}$\n\tend for\n\n\tfor i = 1, 2, ..., k do\n\t\t计算新均值向量: $\\mu_i^` = \\frac{1}{|C_i|}\\sum_{x \\in C_i|}x$;\n\t\tif $\\mu_i^ \\ne\\mu_i$ then\n\t\t\t更新 $\\mu_i$\n\t\telse\n\t\t\t保持当前均值向量不变\n\t\tend if\n\n\tend for\n\nutil 当前均值向量都没有更新\n\n输出: 簇划分 $C = \\{C_1, C_2, ..., C_k\\}$\n\n<h2 id=\"扯淡\"><a href=\"#扯淡\" class=\"headerlink\" title=\"扯淡\"></a>扯淡</h2><p>暂时先写到这里,第一次写latex,第一次写博客,写的不好请见谅,以上大段文字<br>有些是建立在自己的理解写的,如果有错误,希望能不吝赐教.写的比较浅,其实也没什么意思啊,就是梳理下自己跟其他同学的思路.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>公式排版目前没法解决唉，博客写个数学公式怎么这么揪心，好不容易解决了公式显示问题，但排版又很难控制</p>\n<h1 id=\"k-means\"><a href=\"#k-means\" class=\"headerlink\" title=\"k-means\"></a>k-means</h1><h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>这个星期学无监督学习(unsuperviser-learning), 最基本的是k-means算法.<br>k-means属于<code>原型聚类</code>:假设聚类结构能通过一组原型刻画. 而聚类本身是根据数据相似度来划分的,即”距离”.我这里不展开讲距离计算, 姑且用欧几里德距离来理解，即平时最常见的公式.<br>\n\n我们先写出k-means的最小化平方误差: 给定样本集合 $D = {x_1, x_2, \\dots, x_m}$,\n\nk-means对聚类所得的簇划分 $C = {C_1, C_2, \\dots, C_k}$\n的最小平方误差是 $E = \\sum_{i=1}^k \\sum_{x \\in C_i} ||x - \\mu_i||_2^2 $,\n\n其中 $\\mu_i = \\frac{1}{|C_i|} \\sum_{x \\in C_i}x$是簇$ C_i $ 的均值向量\n</p>\n<p>可以看出来, 求该式子的最优解并不容易, 因为需要考察每个样本可能的划分情况(<code>NP难问题</code>),<br>所以k-means 采用贪心策略, 通过迭代优化求近似解.</p>\n<p>感觉学完以上内容, 脑子里好像有了这个算法的轮廓了, 但仔细一想, 还有很多地方需要斟酌.<br>k-means是划分为k个类别, 那一开始怎么划分呢?<br>我们想到一开始需要选k个样本当作中心点来计算距离, 根据这k个位置就求得每个样本离哪个位置最接近. 这样,第一次聚类就完成了, 但是由于这次聚类造成每个类别的中心点发生了偏移,</p>\n<p>我们需要重新计算这时候的中心点,而由于发生了偏移,我们又需要重新计算所有样本最接近的… 如何反复,直到中心点(即均值向量)不变, 便完成了聚类. </p>\n<p>如此说来, 这个算法还是蛮朴素的, 但是还有需要斟酌的地方.<br>如何选初始点呢？万一2个点靠得近，或者是离群点, 岂不是可能会出现很极端的聚类(比如一个人一个类别).个人觉得这有时候很难避免, 但可以通过多次随机选取初始点并评估各个聚类的效果(最小平方误差),来减少这种情况.</p>\n<p>嗯,好像对算法的轮廓又清晰了, 但可能又有疑问, 到底如何选择k值呢?这里应该要具体问题具体分析了.如果只是想得到更好的性能, 把应该把k值从小到大递增来比较选择最优, 但这不一定给你带来实际上的最大收益.比如你是服装商, 把消费者划分了不同尺码的类别来针对客户进行推荐商品, 那到底多细才最优呢,反正我是不知道, 这得根据实际情况和专家经验来决策,而k-means在这里不充当决策者, 更像是打下手的.</p>\n<p>扯远了,总之对于k-means, 知道k值我觉得往往很关键.</p>\n<h2 id=\"算法伪代码\"><a href=\"#算法伪代码\" class=\"headerlink\" title=\"算法伪代码\"></a>算法伪代码</h2><p>这样子算法应该比较清晰了,我下来列出(抄上)伪代码, 参考自周志华的西瓜书:</p>\n\n输入: \n样本集 $D = \\{x_1, x_2, ..., x_m\\}$, 聚类簇数 k\n\n过程:\n从D中随机选择k个样本作为初始均值向量 $\\{\\mu_1, \\mu_2, ..., \\mu_k\\}$\nrepeat \n\t$C_i = \\emptyset$\n\tfor j = 1, 2, ..., m do\n\t\t计算$x_j$与各均值向量 \\mu_i(1 \\leq i \\leq k)的距离: $d_ji = ||x_i - \\mu_i||_2$;\n\t\t根据距离最近的均值向量确定x_j的簇标记: $\\lambda_j = argmin_{i \\in \\{1,2,...,k\\}}d_ij$;\n\t\t将样本$x_j$划入相应的簇: $C_{\\lambda_j} = C_{\\lambda_j} \\bigcup\\{x_j\\}$\n\tend for\n\n\tfor i = 1, 2, ..., k do\n\t\t计算新均值向量: $\\mu_i^` = \\frac{1}{|C_i|}\\sum_{x \\in C_i|}x$;\n\t\tif $\\mu_i^ \\ne\\mu_i$ then\n\t\t\t更新 $\\mu_i$\n\t\telse\n\t\t\t保持当前均值向量不变\n\t\tend if\n\n\tend for\n\nutil 当前均值向量都没有更新\n\n输出: 簇划分 $C = \\{C_1, C_2, ..., C_k\\}$\n\n<h2 id=\"扯淡\"><a href=\"#扯淡\" class=\"headerlink\" title=\"扯淡\"></a>扯淡</h2><p>暂时先写到这里,第一次写latex,第一次写博客,写的不好请见谅,以上大段文字<br>有些是建立在自己的理解写的,如果有错误,希望能不吝赐教.写的比较浅,其实也没什么意思啊,就是梳理下自己跟其他同学的思路.</p>\n"},{"title":"JS函数式编程笔记1","date":"2017-12-11T13:47:31.000Z","_content":"# JS函数式编程\n\n## 我们在做什么\n\n> “we both know what happens when you assume”，源自一句名言“When you assume you make an ASS of U and ME”，意思是“让两人都难堪”）。但我猜想你在使用可变状态（mutable state）、无限制副作用（unrestricted side effects）和无原则设计（unprincipled design）的过程中已经遇到过一些麻烦。\n\n现在已经有一些通用的编程原则了，各种缩写词带领我们在编程的黑暗隧道里前行：DRY（不要重复自己，don't repeat yourself），高内聚低耦合（loosecoupling high cohesion），YAGNI （你不会用到它的，ya ain't gonna need it），最小意外原则（Principle of least surprise），单一责任（single responsibility）等等。这些原则同样适用于函数式编程(FP)。\n\n<!-- more -->\n\n先看基本的例子\n\n```js\nlet add = function (x, y) {\n    return x + y\n};\nlet multiply = function (x, y) {\n    return x * y\n};\nlet a = 4;\nlet b = 2;\nlet c = 0;\nlet result = add(multiply(b, add(a, c)), multiply(a, b));\n//=>16\n```\n\n你会发现我们不过是在运用古人早已获得的知识\n\n```js\n// 结合律（assosiative）\nadd(add(x, y), z) == add(x, add(y, z));\n// 交换律（commutative）\nadd(x, y) == add(y, x);\n// 同一律（identity）\nadd(x, 0) == x;\n// 分配律（distributive）\nmultiply(x, add(y, z)) == add(multiply(x, y), multiply(x, z));\n// 原有代码\nadd(multiply(b, add(a, c)), multiply(a, b));\n// 应用同一律，去掉多余的加法操作（add(a, c) == a）\nadd(multiply(b, a), multiply(a, b));\n// 再应用分配律\nmultiply(b, add(a, a));\n```\n\n当然这里我们定义 add 和 multiply 是为了代码完整性，实际上并不必要——在调用之前它们肯定已经在某个类库里定义好了。\n\n\n我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。相比命令式编程的那种“某某去做某事”的方式，函数式编程将会有更多的约束，不过你会震惊于这种强约束、数学性的“框架”所带来的回报。\n\n## 一等公民的函数\n\n先看看常见的JS风格的一个例子\n\n```js\nfunction ajaxCall(func) {\n    //...\n}\n\n// 用一个函数把另一个函数包起来，目的仅仅是延迟执行，真的是非常糟糕的编程习惯\nlet getServerStuff = function (callback) {\n    return ajaxCall(function (json) {\n        return callback(json);\n    });\n};\n\n// 这行\n// return ajaxCall(function (json) {\n// return callback(json);\n// });\n// 等价于这行\n// return ajaxCall(callback);\n\n// 应该改成这样\nlet getServerStuff = ajaxCall;\n```\n\n再看另一个例子\n\n```js\nclass Views {\n    //...\n}\n\nclass Db {\n    //...\n}\n\n// 这样做除了徒增代码量，提高维护和检索代码的成本外，没有任何用处\nlet BlogController = (function () {\n    let index = function (posts) {\n        return Views.index(posts);\n    };\n    let show = function (post) {\n        return Views.show(post);\n    };\n    let create = function (attrs) {\n        return Db.create(attrs);\n    };\n    let update = function (post, attrs) {\n        return Db.update(post, attrs);\n    };\n    let destroy = function (post) {\n        return Db.destroy(post);\n    };\n    return {\n        index,\n        show,\n        create,\n        update,\n        destroy\n    };\n})();\n\n// 我们可以把它重写成这样：\nlet BlogController = {\n    index: Views.index,\n    show: Views.show,\n    create: Db.create,\n    update: Db.update,\n    destroy: Db.destroy\n};\n// 或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已\n```\n\n另外，如果一个函数被不必要地包裹起来了，而且发生了改动，那么包裹它的那个函数也要做相应的变更。\n\n```js\nhttpGet('/post/2', function(json){\n    return renderPost(json);\n});\n// 如果 httpGet 要改成可以抛出一个可能出现的 err 异常，那我们还要回过头去把“胶水”函数也改了\n\n// 把整个应用里的所有 httpGet 调用都改成这样，可以传递 err 参数。\nhttpGet('/post/2', function(json, err){\n    return renderPost(json, err);\n});\n\n// 写成一等公民函数的形式，要做的改动将会少得多\nhttpGet('/post/2', renderPost); \n// renderPost 将会在 httpGet 中调用，想要多少参数都行\n```\n\n除了删除不必要的函数，正确地为参数命名也必不可少。当然命名不是什么大问题，但还是有可能存在一些不当的命名，尤其随着代码量的增长以及需求的变更，这种可能性也会增加。\n\n如果一个底层函数使用了 this，而且是以一等公民的方式被调用的，那你就等着 JS 这个蹩脚的抽象概念发怒吧\n\n```js\nconst fs = require('fs');\n// 太可怕了\nfs.readFile('freaky_friday.txt', Db.save);\n// 好一点点\nfs.readFile('freaky_friday.txt', Db.save.bind(Db));\n```\n\n## 纯函数的好处\n\n> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。\n\n比如 slice 和 splice。我们说 slice 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 splice 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了。\n\n```js\nlet xs = [1,2,3,4,5];\n// 纯的\nxs.slice(0,3);\n//=> [1,2,3]\nxs.slice(0,3);\n//=> [1,2,3]\nxs.slice(0,3);\n//=> [1,2,3]\n// 不纯的\nxs.splice(0,3);\n//=> [1,2,3]\nxs.splice(0,3);\n//=> [4,5]\nxs.splice(0,3);\n//=> []\n```\n\n下一个例子\n\n```js\n// 不纯的\nlet minimum = 21;\nlet checkAge = function (age) {\n    return age >= minimum;\n};\n\n// 纯的\nlet checkAge = function (age) {\n    let minimum = 21;\n    return age >= minimum;\n};\n\n// 纯的\nconst minimum = 21;\nlet checkAge = function (age) {\n    return age >= minimum;\n};\n```\n\n在不纯的版本中， checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。\n\n另一方面，使用纯函数的形式，函数就能做到自给自足。我们也可以让 minimum成为一个不可变（immutable）对象，这样就能保留纯粹性，因为状态不会有变化。要实现这个效果，必须得创建一个对象，然后调用 Object.freeze 方法\n\n```js\nlet immutableState = Object.freeze({\n    minimun: 21\n});\n```\n\n> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。\n\n副作用可能包含，但不限于：\n\n* 更改文件系统\n* 往数据库插入记录\n* 发送一个 http 请求\n* 可变数据\n* 打印/log\n* 获取用户输入\n* DOM 查询\n* 访问系统状态\n\n这个列表还可以继续写下去。概括来讲，只要是跟函数外部环境发生的交互就都是副作用——这一点可能会让你怀疑无副作用编程的可行性。函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。\n\n这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。后面讲到 functor 和 monad 的时候我们会学习如何控制它们。\n\n### 追求“纯”的理由\n\n* 可缓存性（Cacheable）\n* 可移植性／自文档化（Portable / SelfDocumenting）\n* 可测试性（Testable）\n* 合理性（Reasonable）\n* 并行性(Parallelism)\n\n#### 可缓存性（Cacheable）\n\n首先，纯函数总能够根据输入来做`缓存`。实现缓存的一种典型方式是 `memoize` 技术\n\n```js\nlet squareNumber = memoize(function(){return x * x});\nsquareNumber(4);\n//=> 16\nsquareNumber(4); // 从缓存中读取输入值为 4 的结果\n//=> 16\nsquareNumber(5);\n//=> 25\nsquareNumber(5); // 从缓存中读取输入值为 5 的结果\n//=> 25\n```\n\n下面的代码是`memoize`一个简单的实现，尽管它不太健壮\n\n```js\nfunction momoize(f) {\n    let cache = {}\n    return function () {\n        let arg_str = JSON.stringify(arguments)\n        // 有cache则返回cache里的，总是保存到cache里\n        cache[arg_str] = cache[arg_str] || f(...arguments)\n        return cache[arg_str]\n    }\n}\n```\n\n值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数\n\n```js\nlet pureHttpCall = memoize(function(url, params){\n    return function() { return $.getJSON(url, params); }\n});\n```\n\n这里有趣的地方在于我们并没有真正发送 http 请求——只是返回了一个函数，当调用它的时候才会发请求。这个函数之所以有资格成为纯函数，是因为它总是会根据相同的输入返回相同的输出：给定了 url 和 params 之后，它就只会返回同一个发送 http 请求的函数\n\n我们的 memoize 函数工作起来没有任何问题，虽然它缓存的并不是 http 请求所返回的结果，而是生成的函数。\n\n重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。\n___\n\n#### 可移植性／自文档化（Portable / SelfDocumenting）\n\n纯函数是完全自给自足的，它需要的所有东西都能轻易获得。仔细思考思考这一点...这种自给自足的好处是什么呢？首先，纯函数的依赖很明确，因此更易于观察和理解。\n\n```js\n// 不纯的\nlet signUp = function (attrs) {\n    let user = saveUser(attrs);\n    welcomeUser(user);\n};\nlet saveUser = function (attrs) {\n    let user = Db.save(attrs);\n    //...\n};\nlet welcomeUser = function (user) {\n    // Email(user, ...);\n    //...\n};\n\n// 纯的\nlet signUp = function (Db, Email, attrs) {\n    return function () {\n        // 参数绑定\n        let user = saveUser(Db, attrs);\n        welcomeUser(Email, user);\n    };\n};\nlet saveUser = function (Db, attrs) {\n    //...\n};\nlet welcomeUser = function (Email, user) {\n    //...\n};\n```\n\n这个例子表明，纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 signUp 的签名就可以看出，它将要用到 Db、Email 和 attrs ，这在最小程度上给了我们足够多的信息。\n\n其次，通过强迫“注入”依赖，或者把它们当作参数传递，我们的应用也更加灵活；因为数据库或者邮件客户端等等都参数化了。\n\n命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。\n\n#### 可测试性（Testable）\n\n第三点，纯函数让`测试`更加容易。\n\n我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。\n\n#### 合理性（Reasonable）\n\n很多人相信使用纯函数最大的好处是`引用透明性（referential transparency）`。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。\n\n由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。我们来看一个例子。\n\n```js\nlet Immutable = require('immutable');\n\nlet decrementHP = function(player) {\n    return player.set(\"hp\", player.hp-1);\n};\n\nlet isSameTeam = function(player1, player2) {\n    return player1.team === player2.team;\n};\n\nlet punch = function(player, target) {\n    if(isSameTeam(player, target)) {\n        return target;\n    } else {\n        return decrementHP(target);\n    }\n};\nlet jobe = Immutable.Map({name:\"Jobe\", hp:20, team: \"red\"});\nlet michael = Immutable.Map({name:\"Michael\", hp:20, team: \"green\"});\n\npunch(jobe, michael);\n//=> Immutable.Map({name:\"Michael\", hp:19, team: \"green\"})\n```\n\ndecrementHP 、 isSameTeam 和 punch 都是纯函数，所以是引用透明的。我们可以使用一种叫做`“等式推导”（equational reasoning）`的技术来分析代码。所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码。我们借助引用透明性来剖析一下这段代码。\n\n```js\nlet punch = function(player, target) {\n    if(player.team === target.team) {\n        return target;\n    } else {\n        return decrementHP(target);\n    }\n};\n```\n\n因为是不可变数据，我们可以直接把 team 替换为实际值：\n\n```js\nlet punch = function(player, target) {\n    if(\"red\" === \"green\") {\n        return target;\n    } else {\n        return decrementHP(target);\n    }\n};\n```\n\nif 语句执行结果为 false ，所以可以把整个 if 语句都删掉：\n\n```js\nlet punch = function(player, target) {\n    return decrementHP(target);\n};\n```\n\n如果再内联 decrementHP ，我们会发现这种情况下， punch 变成了一个让 hp 的值减 1 的调用：\n\n```js\nlet punch = function(player, target) {\n    return target.set(\"hp\", target.hp-1);\n};\n```\n\n总之，等式推导带来的分析代码的能力对重构和理解代码非常重要。事实上，我们重构海鸥程序使用的正是这项技术：利用加和乘的特性。\n\n### 并行性(Parallelism)\n\n最后一点，也是决定性的一点：我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。\n\n并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。\n\n## 柯里化（curry）\n\n### 不可或缺的 curry\n\n> 我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。\n\ncurry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。\n\n```js\nlet add = function(x) {\n    return function(y) {\n        return x + y\n    }\n}\n\nlet inc = add(1)\n\ninc(10)\n// 11\n\n```\n\n这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helperfunction）使这类函数的定义和调用更加容易。\n\n```js\nconst curry = require('lodash/curry')\n\nlet match = curry(function(what, str){\n    return str.match(what)\n})\n\n\nlet replace = curry(function(what, replacement, str){\n    return str.replace(what, replacement)\n})\n\nlet filter = curry(function(f, ary){\n    return ary.filter(f)\n})\n\nlet map = curry(function(f, ary){\n    return ary.map(f)\n})\n\n```\n\n我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里\n\n```js\nmatch(/\\s+/g, \"hello world\")\n// [ ' ' ]\nmatch(/\\s+/g)(\"hello world\")\n// [ ' ' ]\nlet hasSpaces = match(/\\s+/g)\n// function(x) { return x.match(/\\s+/g) }\nhasSpaces(\"hello world\")\n// [ ' ' ]\nhasSpaces(\"spaceless\")\n// null\nfilter(hasSpaces, [\"tori_spelling\", \"tori amos\"])\n// [\"tori amos\"]\nlet findSpaces = filter(hasSpaces)\n// function(xs) { return xs.filter(function(x) { return x.match(/\\s+/g) }) }\nfindSpaces([\"tori_spelling\", \"tori amos\"])\n// [\"tori amos\"]\nlet noVowels = replace(/[aeiou]/ig);\n// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }\nlet censored = noVowels(\"*\");\n// function(x) { return x.replace(/[aeiou]/ig, \"*\") }\ncensored(\"Chocolate Rain\");\n// 'Ch*c*l*t* R**n'\n```\n\n这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。\n\n### 不仅仅是双关语／咖喱\n\n用 map 简单地把参数是单个元素的函数包裹一下，就能把它转换成参数为数组的函数。\n\n```js\nlet getLength = function(x){\n    return x.length\n}\n\nlet getAllLength = map(getLength)\n```\n\n只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码（boilerplate code）。\n\n通常我们不定义直接操作数组的函数，因为只需内联调用 map(getChildren) 就能达到目的。这一点同样适用于 sort 、 filter 以及其他的高阶函数（higherorder function）（高阶函数：参数或返回值为函数的函数）。\n\n当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。\n\ncurry 函数用起来非常得心应手，通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。\n\n## 代码组合（compose）\n\n### 函数饲养\n\n```js\nlet compose = function(f, g){\n    return function(x){\n        return f(g(x))\n    }\n}\n```\n\nf 和 g 都是函数， x 是在它们之间通过“管道”传输的值在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据流。\n\n组合看起来像是在饲养函数让它们结合，产下一个崭新的函数。组合的用法如下：\n\n```js\nlet toUpperCase = function(str){\n    return str.toUpperCase()\n}\nlet toLowerCase = function(str){\n    return str.toLowerCase()\n}\nlet exclaim = function(str){\n    return str + '!'\n}\nlet reverse = function(str){\n    return str.split('').reverse().join('')\n}\nlet angry = compose(exclaim, toUpperCase)\n\nlet shout = compose(exclaim, toUpperCase)\nconsole.log(exclaim(toUpperCase(\"hello\")))\nconsole.log(shout(\"hello\"))\n```\n\n这个组合中函数的执行顺序应该是显而易见的。尽管我们可以定义一个从左向右的版本，但是从右向左执行更加能够反映数学上的含义——是的，组合的概念直接来自于数学课本。\n\n现在是时候去看看所有的组合都有的一个特性了。\n\n```js\n// 结合律（associativity）\n// let associative = compose(f, compose(g, h)) == compose(compose(f, g), h)    \n// true\n\n// 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起\nconsole.log(compose(reverse, compose(toUpperCase, exclaim))(\"world\"))\nconsole.log(compose(compose(reverse, toUpperCase), exclaim)(\"world\"))\n```\n\n符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。\n\n结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。\n\n### pointfree\n\npointfree 模式指的是，永远不必说出你的数据。它的意思是说，函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。\n\n```js\n// 非 pointfree，因为提到了数据：word\nlet snakeCase = function (word) {\n    return word.toLowerCase().replace(/\\s+/ig, '_');\n}\n\n// pointfree\nsnakeCase = compose(replace(/\\s+/ig, '_'), toUpperCase)\n```\n\n这里所做的事情就是通过管道把数据在接受单个参数的函数间传递。利用 curry，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。\n\n另外，pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，pointfree 是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。比如，while 循环是不能组合的。不过你也要警惕，pointfree 就像是一把双刃剑，有时候也能混淆视听。并非所有的函数式代码都是 pointfree 的，不过这没关系。可以使用它的时候就使用，不能使用的时候就用普通函数。\n\n### debug\n\n组合的一个常见错误是，在没有局部调用之前，就组合类似 map 这样接受两个参数的函数。\n\n```js\n// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。\nlet latin = compose(map, angry, reverse)\nlatin([\"frog\", \"eyes\"])\n// error\n// 正确做法：每个函数都接受一个实际参数。\nlet latin = compose(map(angry), reverse)\nlatin([\"frog\", \"eyes\"])\n// [\"EYES!\", \"FROG!\"])\n```\n\n如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的trace 函数来追踪代码的执行情况。\n\n```js\nlet trace = curry(function(tag, x){\n    console.log(tag, x)\n    return x\n})\n\nlet dasherize = compose(join('-'), toLower, split(' '), replace(/\\s{2,}/ig, ' '))\n\ndasherize('The world is a vampire')\n// TypeError: Cannot read property 'apply' of undefined\n\nlet dasherize = compose(join('-'), toLower, trace(\"after split\"), split(' '), replace(/\\s{2,}/ig, ' '));\n// after split [ 'The', 'world', 'is', 'a', 'vampire' ]\n```\n\ntrace 函数允许我们在某个特定的点观察数据以便 debug。像 haskell 和 purescript 之类的语言出于开发的方便，也都提供了类似的函数。\n\n组合将成为我们构造程序的工具，而且幸运的是，它背后是有一个强大的理论做支撑的。\n\n### 范畴学（category theory）\n\n范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（settheory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式：\n\n![范畴学](范畴学.png)\n\n在范畴学中，有一个概念叫做...范畴。有着以下这些组件（component）的搜集\n（collection）就构成了一个范畴：\n\n* 对象的搜集\n* 态射的搜集\n* 态射的组合\n* identity 这个独特的态射\n\n范畴学抽象到足以模拟任何事物，不过目前我们最关心的还是类型和函数，所以让我们把范畴学运用到它们身上看看。\n\n对象的搜集\n\n对象就是数据类型，例如 String 、 Boolean 、 Number 和 Object 等等。通常我们把数据类型视作所有可能的值的一个集合（set）。像 Boolean 就可以看作是 [true, false] 的集合， Number 可以是所有实数的一个集合。把类型当作集合对待是有好处的，因为我们可以利用集合论（set theory）处理类型。\n\n态射的搜集\n\n态射是标准的、普通的纯函数。\n\n态射的组合\n\n这就是本章介绍的新玩意儿—— 组合 。我们已经讨论过compose 函数是符合结合律的，这并非巧合，结合律是在范畴学中对任何组合都适用的一个特性。\n\n![compose](compose.png)\n\n```js\nlet g = function(x){ return x.length }\nlet f = function(x){ return x === 4; }\nlet isFourLetterWord = compose(f, g)\n```\n\nidentity 这个独特的态射\n\n让我们介绍一个名为 id 的实用函数。这个函数接受随便什么输入然后原封不动地返回它：\n\n```js\nlet id = function(x) {return x}\n```\n\nid 函数跟组合一起使用简直完美。下面这个特性对所有的一元函数（unary function）（一元函数：只接受一个参数的函数） f 都成立：\n\n```js\n// identity\ncompose(id, f) == compose(f, id) == f\n// true\n```\n\n这就是实数的单位元（identity property）嘛！慢慢理解它的无用性，很快我们就会到处使用 id 了，不过暂时我们还是把它当作一个替代给定值的函数。这对写 pointfree 的代码非常有用。\n\n除了类型和函数，还有什么范畴呢？还有很多，比如我们可以定义一个有向图（directed graph），以节点为对象，以边为态射，以路径连接为组合。还可以定义一个实数类型（Number），以所有的实数为对象，以 >= 为态射（实际上任何偏序（partial order）或全序（total order）都可以成为一个范畴）。范畴的总数是无限的，但我们只需要关心上面定义的范畴就好了。\n\n### 总结\n\n组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。我们认为组合是高于其他所有原则的设计原则，这是因为组合让我们的代码简单而富有可读性。另外范畴学将在应用架构、模拟副作用和保证正确性方面扮演重要角色。\n\n## 示例应用\n\n### 声明式代码\n\n我们要开始转变观念了，从本章开始，我们将不再指示计算机如何工作，而是指出我们明确希望得到的结果。\n\n与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。\n\n以 SQL 为例，它就没有“先做这个，再做那个”的命令，有的只是一个指明我们想要从数据库取什么数据的表达式。至于如何取数据则是由它自己决定的。以后数据库升级也好，SQL 引擎优化也好，根本不需要更改查询语句。这是因为，有多种方式解析一个表达式并得到相同的结果。\n\n```js\n// 命令式\nlet makes = []\nfor (i = 0; i < cars.length; i++) {\n    makes.push(cars[i].make)\n}\n// 声明式\nlet makes = cars.map(function(car){ return car.make })\n```\n\n命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来...实在是直白得有些露骨。\n\n使用 map 的版本是一个表达式，它对执行顺序没有要求。而且， map 函数如何进行迭代，返回的数组如何收集，都有很大的自由度。它指明的是 做什么 ，不是怎么做。因此，它是正儿八经的声明式代码。\n\n再看一个例子。\n\n```js\nlet authenticate = function(form){\n    let user = toUser(form)\n    return logIn(user)\n\n    // return logIn(toUser(form))\n}\n\nlet authenticate = compose(logIn, toUser)\n```\n\n虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser和 logIn 两个行为的组合。这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。\n\n因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。\n","source":"_posts/JS函数式编程笔记1.md","raw":"---\ntitle: JS函数式编程笔记1\ndate: 2017-12-11 21:47:31\ntags: [JS, FP]\ncategory: study\n---\n# JS函数式编程\n\n## 我们在做什么\n\n> “we both know what happens when you assume”，源自一句名言“When you assume you make an ASS of U and ME”，意思是“让两人都难堪”）。但我猜想你在使用可变状态（mutable state）、无限制副作用（unrestricted side effects）和无原则设计（unprincipled design）的过程中已经遇到过一些麻烦。\n\n现在已经有一些通用的编程原则了，各种缩写词带领我们在编程的黑暗隧道里前行：DRY（不要重复自己，don't repeat yourself），高内聚低耦合（loosecoupling high cohesion），YAGNI （你不会用到它的，ya ain't gonna need it），最小意外原则（Principle of least surprise），单一责任（single responsibility）等等。这些原则同样适用于函数式编程(FP)。\n\n<!-- more -->\n\n先看基本的例子\n\n```js\nlet add = function (x, y) {\n    return x + y\n};\nlet multiply = function (x, y) {\n    return x * y\n};\nlet a = 4;\nlet b = 2;\nlet c = 0;\nlet result = add(multiply(b, add(a, c)), multiply(a, b));\n//=>16\n```\n\n你会发现我们不过是在运用古人早已获得的知识\n\n```js\n// 结合律（assosiative）\nadd(add(x, y), z) == add(x, add(y, z));\n// 交换律（commutative）\nadd(x, y) == add(y, x);\n// 同一律（identity）\nadd(x, 0) == x;\n// 分配律（distributive）\nmultiply(x, add(y, z)) == add(multiply(x, y), multiply(x, z));\n// 原有代码\nadd(multiply(b, add(a, c)), multiply(a, b));\n// 应用同一律，去掉多余的加法操作（add(a, c) == a）\nadd(multiply(b, a), multiply(a, b));\n// 再应用分配律\nmultiply(b, add(a, a));\n```\n\n当然这里我们定义 add 和 multiply 是为了代码完整性，实际上并不必要——在调用之前它们肯定已经在某个类库里定义好了。\n\n\n我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。相比命令式编程的那种“某某去做某事”的方式，函数式编程将会有更多的约束，不过你会震惊于这种强约束、数学性的“框架”所带来的回报。\n\n## 一等公民的函数\n\n先看看常见的JS风格的一个例子\n\n```js\nfunction ajaxCall(func) {\n    //...\n}\n\n// 用一个函数把另一个函数包起来，目的仅仅是延迟执行，真的是非常糟糕的编程习惯\nlet getServerStuff = function (callback) {\n    return ajaxCall(function (json) {\n        return callback(json);\n    });\n};\n\n// 这行\n// return ajaxCall(function (json) {\n// return callback(json);\n// });\n// 等价于这行\n// return ajaxCall(callback);\n\n// 应该改成这样\nlet getServerStuff = ajaxCall;\n```\n\n再看另一个例子\n\n```js\nclass Views {\n    //...\n}\n\nclass Db {\n    //...\n}\n\n// 这样做除了徒增代码量，提高维护和检索代码的成本外，没有任何用处\nlet BlogController = (function () {\n    let index = function (posts) {\n        return Views.index(posts);\n    };\n    let show = function (post) {\n        return Views.show(post);\n    };\n    let create = function (attrs) {\n        return Db.create(attrs);\n    };\n    let update = function (post, attrs) {\n        return Db.update(post, attrs);\n    };\n    let destroy = function (post) {\n        return Db.destroy(post);\n    };\n    return {\n        index,\n        show,\n        create,\n        update,\n        destroy\n    };\n})();\n\n// 我们可以把它重写成这样：\nlet BlogController = {\n    index: Views.index,\n    show: Views.show,\n    create: Db.create,\n    update: Db.update,\n    destroy: Db.destroy\n};\n// 或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已\n```\n\n另外，如果一个函数被不必要地包裹起来了，而且发生了改动，那么包裹它的那个函数也要做相应的变更。\n\n```js\nhttpGet('/post/2', function(json){\n    return renderPost(json);\n});\n// 如果 httpGet 要改成可以抛出一个可能出现的 err 异常，那我们还要回过头去把“胶水”函数也改了\n\n// 把整个应用里的所有 httpGet 调用都改成这样，可以传递 err 参数。\nhttpGet('/post/2', function(json, err){\n    return renderPost(json, err);\n});\n\n// 写成一等公民函数的形式，要做的改动将会少得多\nhttpGet('/post/2', renderPost); \n// renderPost 将会在 httpGet 中调用，想要多少参数都行\n```\n\n除了删除不必要的函数，正确地为参数命名也必不可少。当然命名不是什么大问题，但还是有可能存在一些不当的命名，尤其随着代码量的增长以及需求的变更，这种可能性也会增加。\n\n如果一个底层函数使用了 this，而且是以一等公民的方式被调用的，那你就等着 JS 这个蹩脚的抽象概念发怒吧\n\n```js\nconst fs = require('fs');\n// 太可怕了\nfs.readFile('freaky_friday.txt', Db.save);\n// 好一点点\nfs.readFile('freaky_friday.txt', Db.save.bind(Db));\n```\n\n## 纯函数的好处\n\n> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。\n\n比如 slice 和 splice。我们说 slice 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 splice 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了。\n\n```js\nlet xs = [1,2,3,4,5];\n// 纯的\nxs.slice(0,3);\n//=> [1,2,3]\nxs.slice(0,3);\n//=> [1,2,3]\nxs.slice(0,3);\n//=> [1,2,3]\n// 不纯的\nxs.splice(0,3);\n//=> [1,2,3]\nxs.splice(0,3);\n//=> [4,5]\nxs.splice(0,3);\n//=> []\n```\n\n下一个例子\n\n```js\n// 不纯的\nlet minimum = 21;\nlet checkAge = function (age) {\n    return age >= minimum;\n};\n\n// 纯的\nlet checkAge = function (age) {\n    let minimum = 21;\n    return age >= minimum;\n};\n\n// 纯的\nconst minimum = 21;\nlet checkAge = function (age) {\n    return age >= minimum;\n};\n```\n\n在不纯的版本中， checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。\n\n另一方面，使用纯函数的形式，函数就能做到自给自足。我们也可以让 minimum成为一个不可变（immutable）对象，这样就能保留纯粹性，因为状态不会有变化。要实现这个效果，必须得创建一个对象，然后调用 Object.freeze 方法\n\n```js\nlet immutableState = Object.freeze({\n    minimun: 21\n});\n```\n\n> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。\n\n副作用可能包含，但不限于：\n\n* 更改文件系统\n* 往数据库插入记录\n* 发送一个 http 请求\n* 可变数据\n* 打印/log\n* 获取用户输入\n* DOM 查询\n* 访问系统状态\n\n这个列表还可以继续写下去。概括来讲，只要是跟函数外部环境发生的交互就都是副作用——这一点可能会让你怀疑无副作用编程的可行性。函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。\n\n这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。后面讲到 functor 和 monad 的时候我们会学习如何控制它们。\n\n### 追求“纯”的理由\n\n* 可缓存性（Cacheable）\n* 可移植性／自文档化（Portable / SelfDocumenting）\n* 可测试性（Testable）\n* 合理性（Reasonable）\n* 并行性(Parallelism)\n\n#### 可缓存性（Cacheable）\n\n首先，纯函数总能够根据输入来做`缓存`。实现缓存的一种典型方式是 `memoize` 技术\n\n```js\nlet squareNumber = memoize(function(){return x * x});\nsquareNumber(4);\n//=> 16\nsquareNumber(4); // 从缓存中读取输入值为 4 的结果\n//=> 16\nsquareNumber(5);\n//=> 25\nsquareNumber(5); // 从缓存中读取输入值为 5 的结果\n//=> 25\n```\n\n下面的代码是`memoize`一个简单的实现，尽管它不太健壮\n\n```js\nfunction momoize(f) {\n    let cache = {}\n    return function () {\n        let arg_str = JSON.stringify(arguments)\n        // 有cache则返回cache里的，总是保存到cache里\n        cache[arg_str] = cache[arg_str] || f(...arguments)\n        return cache[arg_str]\n    }\n}\n```\n\n值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数\n\n```js\nlet pureHttpCall = memoize(function(url, params){\n    return function() { return $.getJSON(url, params); }\n});\n```\n\n这里有趣的地方在于我们并没有真正发送 http 请求——只是返回了一个函数，当调用它的时候才会发请求。这个函数之所以有资格成为纯函数，是因为它总是会根据相同的输入返回相同的输出：给定了 url 和 params 之后，它就只会返回同一个发送 http 请求的函数\n\n我们的 memoize 函数工作起来没有任何问题，虽然它缓存的并不是 http 请求所返回的结果，而是生成的函数。\n\n重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。\n___\n\n#### 可移植性／自文档化（Portable / SelfDocumenting）\n\n纯函数是完全自给自足的，它需要的所有东西都能轻易获得。仔细思考思考这一点...这种自给自足的好处是什么呢？首先，纯函数的依赖很明确，因此更易于观察和理解。\n\n```js\n// 不纯的\nlet signUp = function (attrs) {\n    let user = saveUser(attrs);\n    welcomeUser(user);\n};\nlet saveUser = function (attrs) {\n    let user = Db.save(attrs);\n    //...\n};\nlet welcomeUser = function (user) {\n    // Email(user, ...);\n    //...\n};\n\n// 纯的\nlet signUp = function (Db, Email, attrs) {\n    return function () {\n        // 参数绑定\n        let user = saveUser(Db, attrs);\n        welcomeUser(Email, user);\n    };\n};\nlet saveUser = function (Db, attrs) {\n    //...\n};\nlet welcomeUser = function (Email, user) {\n    //...\n};\n```\n\n这个例子表明，纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 signUp 的签名就可以看出，它将要用到 Db、Email 和 attrs ，这在最小程度上给了我们足够多的信息。\n\n其次，通过强迫“注入”依赖，或者把它们当作参数传递，我们的应用也更加灵活；因为数据库或者邮件客户端等等都参数化了。\n\n命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。\n\n#### 可测试性（Testable）\n\n第三点，纯函数让`测试`更加容易。\n\n我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。\n\n#### 合理性（Reasonable）\n\n很多人相信使用纯函数最大的好处是`引用透明性（referential transparency）`。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。\n\n由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。我们来看一个例子。\n\n```js\nlet Immutable = require('immutable');\n\nlet decrementHP = function(player) {\n    return player.set(\"hp\", player.hp-1);\n};\n\nlet isSameTeam = function(player1, player2) {\n    return player1.team === player2.team;\n};\n\nlet punch = function(player, target) {\n    if(isSameTeam(player, target)) {\n        return target;\n    } else {\n        return decrementHP(target);\n    }\n};\nlet jobe = Immutable.Map({name:\"Jobe\", hp:20, team: \"red\"});\nlet michael = Immutable.Map({name:\"Michael\", hp:20, team: \"green\"});\n\npunch(jobe, michael);\n//=> Immutable.Map({name:\"Michael\", hp:19, team: \"green\"})\n```\n\ndecrementHP 、 isSameTeam 和 punch 都是纯函数，所以是引用透明的。我们可以使用一种叫做`“等式推导”（equational reasoning）`的技术来分析代码。所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码。我们借助引用透明性来剖析一下这段代码。\n\n```js\nlet punch = function(player, target) {\n    if(player.team === target.team) {\n        return target;\n    } else {\n        return decrementHP(target);\n    }\n};\n```\n\n因为是不可变数据，我们可以直接把 team 替换为实际值：\n\n```js\nlet punch = function(player, target) {\n    if(\"red\" === \"green\") {\n        return target;\n    } else {\n        return decrementHP(target);\n    }\n};\n```\n\nif 语句执行结果为 false ，所以可以把整个 if 语句都删掉：\n\n```js\nlet punch = function(player, target) {\n    return decrementHP(target);\n};\n```\n\n如果再内联 decrementHP ，我们会发现这种情况下， punch 变成了一个让 hp 的值减 1 的调用：\n\n```js\nlet punch = function(player, target) {\n    return target.set(\"hp\", target.hp-1);\n};\n```\n\n总之，等式推导带来的分析代码的能力对重构和理解代码非常重要。事实上，我们重构海鸥程序使用的正是这项技术：利用加和乘的特性。\n\n### 并行性(Parallelism)\n\n最后一点，也是决定性的一点：我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。\n\n并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。\n\n## 柯里化（curry）\n\n### 不可或缺的 curry\n\n> 我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。\n\ncurry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。\n\n```js\nlet add = function(x) {\n    return function(y) {\n        return x + y\n    }\n}\n\nlet inc = add(1)\n\ninc(10)\n// 11\n\n```\n\n这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helperfunction）使这类函数的定义和调用更加容易。\n\n```js\nconst curry = require('lodash/curry')\n\nlet match = curry(function(what, str){\n    return str.match(what)\n})\n\n\nlet replace = curry(function(what, replacement, str){\n    return str.replace(what, replacement)\n})\n\nlet filter = curry(function(f, ary){\n    return ary.filter(f)\n})\n\nlet map = curry(function(f, ary){\n    return ary.map(f)\n})\n\n```\n\n我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里\n\n```js\nmatch(/\\s+/g, \"hello world\")\n// [ ' ' ]\nmatch(/\\s+/g)(\"hello world\")\n// [ ' ' ]\nlet hasSpaces = match(/\\s+/g)\n// function(x) { return x.match(/\\s+/g) }\nhasSpaces(\"hello world\")\n// [ ' ' ]\nhasSpaces(\"spaceless\")\n// null\nfilter(hasSpaces, [\"tori_spelling\", \"tori amos\"])\n// [\"tori amos\"]\nlet findSpaces = filter(hasSpaces)\n// function(xs) { return xs.filter(function(x) { return x.match(/\\s+/g) }) }\nfindSpaces([\"tori_spelling\", \"tori amos\"])\n// [\"tori amos\"]\nlet noVowels = replace(/[aeiou]/ig);\n// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }\nlet censored = noVowels(\"*\");\n// function(x) { return x.replace(/[aeiou]/ig, \"*\") }\ncensored(\"Chocolate Rain\");\n// 'Ch*c*l*t* R**n'\n```\n\n这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。\n\n### 不仅仅是双关语／咖喱\n\n用 map 简单地把参数是单个元素的函数包裹一下，就能把它转换成参数为数组的函数。\n\n```js\nlet getLength = function(x){\n    return x.length\n}\n\nlet getAllLength = map(getLength)\n```\n\n只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码（boilerplate code）。\n\n通常我们不定义直接操作数组的函数，因为只需内联调用 map(getChildren) 就能达到目的。这一点同样适用于 sort 、 filter 以及其他的高阶函数（higherorder function）（高阶函数：参数或返回值为函数的函数）。\n\n当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。\n\ncurry 函数用起来非常得心应手，通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。\n\n## 代码组合（compose）\n\n### 函数饲养\n\n```js\nlet compose = function(f, g){\n    return function(x){\n        return f(g(x))\n    }\n}\n```\n\nf 和 g 都是函数， x 是在它们之间通过“管道”传输的值在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据流。\n\n组合看起来像是在饲养函数让它们结合，产下一个崭新的函数。组合的用法如下：\n\n```js\nlet toUpperCase = function(str){\n    return str.toUpperCase()\n}\nlet toLowerCase = function(str){\n    return str.toLowerCase()\n}\nlet exclaim = function(str){\n    return str + '!'\n}\nlet reverse = function(str){\n    return str.split('').reverse().join('')\n}\nlet angry = compose(exclaim, toUpperCase)\n\nlet shout = compose(exclaim, toUpperCase)\nconsole.log(exclaim(toUpperCase(\"hello\")))\nconsole.log(shout(\"hello\"))\n```\n\n这个组合中函数的执行顺序应该是显而易见的。尽管我们可以定义一个从左向右的版本，但是从右向左执行更加能够反映数学上的含义——是的，组合的概念直接来自于数学课本。\n\n现在是时候去看看所有的组合都有的一个特性了。\n\n```js\n// 结合律（associativity）\n// let associative = compose(f, compose(g, h)) == compose(compose(f, g), h)    \n// true\n\n// 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起\nconsole.log(compose(reverse, compose(toUpperCase, exclaim))(\"world\"))\nconsole.log(compose(compose(reverse, toUpperCase), exclaim)(\"world\"))\n```\n\n符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。\n\n结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。\n\n### pointfree\n\npointfree 模式指的是，永远不必说出你的数据。它的意思是说，函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。\n\n```js\n// 非 pointfree，因为提到了数据：word\nlet snakeCase = function (word) {\n    return word.toLowerCase().replace(/\\s+/ig, '_');\n}\n\n// pointfree\nsnakeCase = compose(replace(/\\s+/ig, '_'), toUpperCase)\n```\n\n这里所做的事情就是通过管道把数据在接受单个参数的函数间传递。利用 curry，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。\n\n另外，pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，pointfree 是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。比如，while 循环是不能组合的。不过你也要警惕，pointfree 就像是一把双刃剑，有时候也能混淆视听。并非所有的函数式代码都是 pointfree 的，不过这没关系。可以使用它的时候就使用，不能使用的时候就用普通函数。\n\n### debug\n\n组合的一个常见错误是，在没有局部调用之前，就组合类似 map 这样接受两个参数的函数。\n\n```js\n// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。\nlet latin = compose(map, angry, reverse)\nlatin([\"frog\", \"eyes\"])\n// error\n// 正确做法：每个函数都接受一个实际参数。\nlet latin = compose(map(angry), reverse)\nlatin([\"frog\", \"eyes\"])\n// [\"EYES!\", \"FROG!\"])\n```\n\n如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的trace 函数来追踪代码的执行情况。\n\n```js\nlet trace = curry(function(tag, x){\n    console.log(tag, x)\n    return x\n})\n\nlet dasherize = compose(join('-'), toLower, split(' '), replace(/\\s{2,}/ig, ' '))\n\ndasherize('The world is a vampire')\n// TypeError: Cannot read property 'apply' of undefined\n\nlet dasherize = compose(join('-'), toLower, trace(\"after split\"), split(' '), replace(/\\s{2,}/ig, ' '));\n// after split [ 'The', 'world', 'is', 'a', 'vampire' ]\n```\n\ntrace 函数允许我们在某个特定的点观察数据以便 debug。像 haskell 和 purescript 之类的语言出于开发的方便，也都提供了类似的函数。\n\n组合将成为我们构造程序的工具，而且幸运的是，它背后是有一个强大的理论做支撑的。\n\n### 范畴学（category theory）\n\n范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（settheory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式：\n\n![范畴学](范畴学.png)\n\n在范畴学中，有一个概念叫做...范畴。有着以下这些组件（component）的搜集\n（collection）就构成了一个范畴：\n\n* 对象的搜集\n* 态射的搜集\n* 态射的组合\n* identity 这个独特的态射\n\n范畴学抽象到足以模拟任何事物，不过目前我们最关心的还是类型和函数，所以让我们把范畴学运用到它们身上看看。\n\n对象的搜集\n\n对象就是数据类型，例如 String 、 Boolean 、 Number 和 Object 等等。通常我们把数据类型视作所有可能的值的一个集合（set）。像 Boolean 就可以看作是 [true, false] 的集合， Number 可以是所有实数的一个集合。把类型当作集合对待是有好处的，因为我们可以利用集合论（set theory）处理类型。\n\n态射的搜集\n\n态射是标准的、普通的纯函数。\n\n态射的组合\n\n这就是本章介绍的新玩意儿—— 组合 。我们已经讨论过compose 函数是符合结合律的，这并非巧合，结合律是在范畴学中对任何组合都适用的一个特性。\n\n![compose](compose.png)\n\n```js\nlet g = function(x){ return x.length }\nlet f = function(x){ return x === 4; }\nlet isFourLetterWord = compose(f, g)\n```\n\nidentity 这个独特的态射\n\n让我们介绍一个名为 id 的实用函数。这个函数接受随便什么输入然后原封不动地返回它：\n\n```js\nlet id = function(x) {return x}\n```\n\nid 函数跟组合一起使用简直完美。下面这个特性对所有的一元函数（unary function）（一元函数：只接受一个参数的函数） f 都成立：\n\n```js\n// identity\ncompose(id, f) == compose(f, id) == f\n// true\n```\n\n这就是实数的单位元（identity property）嘛！慢慢理解它的无用性，很快我们就会到处使用 id 了，不过暂时我们还是把它当作一个替代给定值的函数。这对写 pointfree 的代码非常有用。\n\n除了类型和函数，还有什么范畴呢？还有很多，比如我们可以定义一个有向图（directed graph），以节点为对象，以边为态射，以路径连接为组合。还可以定义一个实数类型（Number），以所有的实数为对象，以 >= 为态射（实际上任何偏序（partial order）或全序（total order）都可以成为一个范畴）。范畴的总数是无限的，但我们只需要关心上面定义的范畴就好了。\n\n### 总结\n\n组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。我们认为组合是高于其他所有原则的设计原则，这是因为组合让我们的代码简单而富有可读性。另外范畴学将在应用架构、模拟副作用和保证正确性方面扮演重要角色。\n\n## 示例应用\n\n### 声明式代码\n\n我们要开始转变观念了，从本章开始，我们将不再指示计算机如何工作，而是指出我们明确希望得到的结果。\n\n与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。\n\n以 SQL 为例，它就没有“先做这个，再做那个”的命令，有的只是一个指明我们想要从数据库取什么数据的表达式。至于如何取数据则是由它自己决定的。以后数据库升级也好，SQL 引擎优化也好，根本不需要更改查询语句。这是因为，有多种方式解析一个表达式并得到相同的结果。\n\n```js\n// 命令式\nlet makes = []\nfor (i = 0; i < cars.length; i++) {\n    makes.push(cars[i].make)\n}\n// 声明式\nlet makes = cars.map(function(car){ return car.make })\n```\n\n命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来...实在是直白得有些露骨。\n\n使用 map 的版本是一个表达式，它对执行顺序没有要求。而且， map 函数如何进行迭代，返回的数组如何收集，都有很大的自由度。它指明的是 做什么 ，不是怎么做。因此，它是正儿八经的声明式代码。\n\n再看一个例子。\n\n```js\nlet authenticate = function(form){\n    let user = toUser(form)\n    return logIn(user)\n\n    // return logIn(toUser(form))\n}\n\nlet authenticate = compose(logIn, toUser)\n```\n\n虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser和 logIn 两个行为的组合。这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。\n\n因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。\n","slug":"JS函数式编程笔记1","published":1,"updated":"2017-12-31T11:37:27.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y7p000f6svsgt5p6vdk","content":"<h1 id=\"JS函数式编程\"><a href=\"#JS函数式编程\" class=\"headerlink\" title=\"JS函数式编程\"></a>JS函数式编程</h1><h2 id=\"我们在做什么\"><a href=\"#我们在做什么\" class=\"headerlink\" title=\"我们在做什么\"></a>我们在做什么</h2><blockquote>\n<p>“we both know what happens when you assume”，源自一句名言“When you assume you make an ASS of U and ME”，意思是“让两人都难堪”）。但我猜想你在使用可变状态（mutable state）、无限制副作用（unrestricted side effects）和无原则设计（unprincipled design）的过程中已经遇到过一些麻烦。</p>\n</blockquote>\n<p>现在已经有一些通用的编程原则了，各种缩写词带领我们在编程的黑暗隧道里前行：DRY（不要重复自己，don’t repeat yourself），高内聚低耦合（loosecoupling high cohesion），YAGNI （你不会用到它的，ya ain’t gonna need it），最小意外原则（Principle of least surprise），单一责任（single responsibility）等等。这些原则同样适用于函数式编程(FP)。</p>\n<a id=\"more\"></a>\n<p>先看基本的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> multiply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x * y</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> result = add(multiply(b, add(a, c)), multiply(a, b));</div><div class=\"line\"><span class=\"comment\">//=&gt;16</span></div></pre></td></tr></table></figure>\n<p>你会发现我们不过是在运用古人早已获得的知识</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结合律（assosiative）</span></div><div class=\"line\">add(add(x, y), z) == add(x, add(y, z));</div><div class=\"line\"><span class=\"comment\">// 交换律（commutative）</span></div><div class=\"line\">add(x, y) == add(y, x);</div><div class=\"line\"><span class=\"comment\">// 同一律（identity）</span></div><div class=\"line\">add(x, <span class=\"number\">0</span>) == x;</div><div class=\"line\"><span class=\"comment\">// 分配律（distributive）</span></div><div class=\"line\">multiply(x, add(y, z)) == add(multiply(x, y), multiply(x, z));</div><div class=\"line\"><span class=\"comment\">// 原有代码</span></div><div class=\"line\">add(multiply(b, add(a, c)), multiply(a, b));</div><div class=\"line\"><span class=\"comment\">// 应用同一律，去掉多余的加法操作（add(a, c) == a）</span></div><div class=\"line\">add(multiply(b, a), multiply(a, b));</div><div class=\"line\"><span class=\"comment\">// 再应用分配律</span></div><div class=\"line\">multiply(b, add(a, a));</div></pre></td></tr></table></figure>\n<p>当然这里我们定义 add 和 multiply 是为了代码完整性，实际上并不必要——在调用之前它们肯定已经在某个类库里定义好了。</p>\n<p>我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。相比命令式编程的那种“某某去做某事”的方式，函数式编程将会有更多的约束，不过你会震惊于这种强约束、数学性的“框架”所带来的回报。</p>\n<h2 id=\"一等公民的函数\"><a href=\"#一等公民的函数\" class=\"headerlink\" title=\"一等公民的函数\"></a>一等公民的函数</h2><p>先看看常见的JS风格的一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajaxCall</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用一个函数把另一个函数包起来，目的仅仅是延迟执行，真的是非常糟糕的编程习惯</span></div><div class=\"line\"><span class=\"keyword\">let</span> getServerStuff = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ajaxCall(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">json</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> callback(json);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这行</span></div><div class=\"line\"><span class=\"comment\">// return ajaxCall(function (json) &#123;</span></div><div class=\"line\"><span class=\"comment\">// return callback(json);</span></div><div class=\"line\"><span class=\"comment\">// &#125;);</span></div><div class=\"line\"><span class=\"comment\">// 等价于这行</span></div><div class=\"line\"><span class=\"comment\">// return ajaxCall(callback);</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 应该改成这样</span></div><div class=\"line\"><span class=\"keyword\">let</span> getServerStuff = ajaxCall;</div></pre></td></tr></table></figure>\n<p>再看另一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Views</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Db</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这样做除了徒增代码量，提高维护和检索代码的成本外，没有任何用处</span></div><div class=\"line\"><span class=\"keyword\">let</span> BlogController = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Views.index(posts);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> show = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Views.show(post);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">attrs</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Db.create(attrs);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> update = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post, attrs</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Db.update(post, attrs);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> destroy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Db.destroy(post);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        index,</div><div class=\"line\">        show,</div><div class=\"line\">        create,</div><div class=\"line\">        update,</div><div class=\"line\">        destroy</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 我们可以把它重写成这样：</span></div><div class=\"line\"><span class=\"keyword\">let</span> BlogController = &#123;</div><div class=\"line\">    index: Views.index,</div><div class=\"line\">    show: Views.show,</div><div class=\"line\">    create: Db.create,</div><div class=\"line\">    update: Db.update,</div><div class=\"line\">    destroy: Db.destroy</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已</span></div></pre></td></tr></table></figure>\n<p>另外，如果一个函数被不必要地包裹起来了，而且发生了改动，那么包裹它的那个函数也要做相应的变更。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> renderPost(json);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// 如果 httpGet 要改成可以抛出一个可能出现的 err 异常，那我们还要回过头去把“胶水”函数也改了</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 把整个应用里的所有 httpGet 调用都改成这样，可以传递 err 参数。</span></div><div class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json, err</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> renderPost(json, err);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写成一等公民函数的形式，要做的改动将会少得多</span></div><div class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, renderPost); </div><div class=\"line\"><span class=\"comment\">// renderPost 将会在 httpGet 中调用，想要多少参数都行</span></div></pre></td></tr></table></figure>\n<p>除了删除不必要的函数，正确地为参数命名也必不可少。当然命名不是什么大问题，但还是有可能存在一些不当的命名，尤其随着代码量的增长以及需求的变更，这种可能性也会增加。</p>\n<p>如果一个底层函数使用了 this，而且是以一等公民的方式被调用的，那你就等着 JS 这个蹩脚的抽象概念发怒吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// 太可怕了</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'freaky_friday.txt'</span>, Db.save);</div><div class=\"line\"><span class=\"comment\">// 好一点点</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'freaky_friday.txt'</span>, Db.save.bind(Db));</div></pre></td></tr></table></figure>\n<h2 id=\"纯函数的好处\"><a href=\"#纯函数的好处\" class=\"headerlink\" title=\"纯函数的好处\"></a>纯函数的好处</h2><blockquote>\n<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>\n</blockquote>\n<p>比如 slice 和 splice。我们说 slice 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 splice 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> xs = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\">xs.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\">xs.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\">xs.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\"><span class=\"comment\">// 不纯的</span></div><div class=\"line\">xs.splice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\">xs.splice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [4,5]</span></div><div class=\"line\">xs.splice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; []</span></div></pre></td></tr></table></figure>\n<p>下一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 不纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> minimum = <span class=\"number\">21</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> age &gt;= minimum;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> minimum = <span class=\"number\">21</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> age &gt;= minimum;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\"><span class=\"keyword\">const</span> minimum = <span class=\"number\">21</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> age &gt;= minimum;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>在不纯的版本中， checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。</p>\n<p>另一方面，使用纯函数的形式，函数就能做到自给自足。我们也可以让 minimum成为一个不可变（immutable）对象，这样就能保留纯粹性，因为状态不会有变化。要实现这个效果，必须得创建一个对象，然后调用 Object.freeze 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> immutableState = <span class=\"built_in\">Object</span>.freeze(&#123;</div><div class=\"line\">    minimun: <span class=\"number\">21</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>\n</blockquote>\n<p>副作用可能包含，但不限于：</p>\n<ul>\n<li>更改文件系统</li>\n<li>往数据库插入记录</li>\n<li>发送一个 http 请求</li>\n<li>可变数据</li>\n<li>打印/log</li>\n<li>获取用户输入</li>\n<li>DOM 查询</li>\n<li>访问系统状态</li>\n</ul>\n<p>这个列表还可以继续写下去。概括来讲，只要是跟函数外部环境发生的交互就都是副作用——这一点可能会让你怀疑无副作用编程的可行性。函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。</p>\n<p>这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。后面讲到 functor 和 monad 的时候我们会学习如何控制它们。</p>\n<h3 id=\"追求“纯”的理由\"><a href=\"#追求“纯”的理由\" class=\"headerlink\" title=\"追求“纯”的理由\"></a>追求“纯”的理由</h3><ul>\n<li>可缓存性（Cacheable）</li>\n<li>可移植性／自文档化（Portable / SelfDocumenting）</li>\n<li>可测试性（Testable）</li>\n<li>合理性（Reasonable）</li>\n<li>并行性(Parallelism)</li>\n</ul>\n<h4 id=\"可缓存性（Cacheable）\"><a href=\"#可缓存性（Cacheable）\" class=\"headerlink\" title=\"可缓存性（Cacheable）\"></a>可缓存性（Cacheable）</h4><p>首先，纯函数总能够根据输入来做<code>缓存</code>。实现缓存的一种典型方式是 <code>memoize</code> 技术</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> squareNumber = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> x * x&#125;);</div><div class=\"line\">squareNumber(<span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; 16</span></div><div class=\"line\">squareNumber(<span class=\"number\">4</span>); <span class=\"comment\">// 从缓存中读取输入值为 4 的结果</span></div><div class=\"line\"><span class=\"comment\">//=&gt; 16</span></div><div class=\"line\">squareNumber(<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; 25</span></div><div class=\"line\">squareNumber(<span class=\"number\">5</span>); <span class=\"comment\">// 从缓存中读取输入值为 5 的结果</span></div><div class=\"line\"><span class=\"comment\">//=&gt; 25</span></div></pre></td></tr></table></figure>\n<p>下面的代码是<code>memoize</code>一个简单的实现，尽管它不太健壮</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">momoize</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> cache = &#123;&#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> arg_str = <span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">arguments</span>)</div><div class=\"line\">        <span class=\"comment\">// 有cache则返回cache里的，总是保存到cache里</span></div><div class=\"line\">        cache[arg_str] = cache[arg_str] || f(...arguments)</div><div class=\"line\">        <span class=\"keyword\">return</span> cache[arg_str]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> pureHttpCall = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, params</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> $.getJSON(url, params); &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里有趣的地方在于我们并没有真正发送 http 请求——只是返回了一个函数，当调用它的时候才会发请求。这个函数之所以有资格成为纯函数，是因为它总是会根据相同的输入返回相同的输出：给定了 url 和 params 之后，它就只会返回同一个发送 http 请求的函数</p>\n<p>我们的 memoize 函数工作起来没有任何问题，虽然它缓存的并不是 http 请求所返回的结果，而是生成的函数。</p>\n<p>重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。</p>\n<hr>\n<h4 id=\"可移植性／自文档化（Portable-SelfDocumenting）\"><a href=\"#可移植性／自文档化（Portable-SelfDocumenting）\" class=\"headerlink\" title=\"可移植性／自文档化（Portable / SelfDocumenting）\"></a>可移植性／自文档化（Portable / SelfDocumenting）</h4><p>纯函数是完全自给自足的，它需要的所有东西都能轻易获得。仔细思考思考这一点…这种自给自足的好处是什么呢？首先，纯函数的依赖很明确，因此更易于观察和理解。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 不纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> signUp = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> user = saveUser(attrs);</div><div class=\"line\">    welcomeUser(user);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> saveUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> user = Db.save(attrs);</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> welcomeUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Email(user, ...);</span></div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> signUp = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Db, Email, attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 参数绑定</span></div><div class=\"line\">        <span class=\"keyword\">let</span> user = saveUser(Db, attrs);</div><div class=\"line\">        welcomeUser(Email, user);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> saveUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Db, attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> welcomeUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Email, user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这个例子表明，纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 signUp 的签名就可以看出，它将要用到 Db、Email 和 attrs ，这在最小程度上给了我们足够多的信息。</p>\n<p>其次，通过强迫“注入”依赖，或者把它们当作参数传递，我们的应用也更加灵活；因为数据库或者邮件客户端等等都参数化了。</p>\n<p>命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。</p>\n<h4 id=\"可测试性（Testable）\"><a href=\"#可测试性（Testable）\" class=\"headerlink\" title=\"可测试性（Testable）\"></a>可测试性（Testable）</h4><p>第三点，纯函数让<code>测试</code>更加容易。</p>\n<p>我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。</p>\n<h4 id=\"合理性（Reasonable）\"><a href=\"#合理性（Reasonable）\" class=\"headerlink\" title=\"合理性（Reasonable）\"></a>合理性（Reasonable）</h4><p>很多人相信使用纯函数最大的好处是<code>引用透明性（referential transparency）</code>。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</p>\n<p>由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。我们来看一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Immutable = <span class=\"built_in\">require</span>(<span class=\"string\">'immutable'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> decrementHP = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> player.set(<span class=\"string\">\"hp\"</span>, player.hp<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> isSameTeam = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player1, player2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> player1.team === player2.team;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(isSameTeam(player, target)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> target;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> jobe = Immutable.Map(&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Jobe\"</span>, <span class=\"attr\">hp</span>:<span class=\"number\">20</span>, <span class=\"attr\">team</span>: <span class=\"string\">\"red\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">let</span> michael = Immutable.Map(&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Michael\"</span>, <span class=\"attr\">hp</span>:<span class=\"number\">20</span>, <span class=\"attr\">team</span>: <span class=\"string\">\"green\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\">punch(jobe, michael);</div><div class=\"line\"><span class=\"comment\">//=&gt; Immutable.Map(&#123;name:\"Michael\", hp:19, team: \"green\"&#125;)</span></div></pre></td></tr></table></figure>\n<p>decrementHP 、 isSameTeam 和 punch 都是纯函数，所以是引用透明的。我们可以使用一种叫做<code>“等式推导”（equational reasoning）</code>的技术来分析代码。所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码。我们借助引用透明性来剖析一下这段代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(player.team === target.team) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> target;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为是不可变数据，我们可以直接把 team 替换为实际值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"red\"</span> === <span class=\"string\">\"green\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> target;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>if 语句执行结果为 false ，所以可以把整个 if 语句都删掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果再内联 decrementHP ，我们会发现这种情况下， punch 变成了一个让 hp 的值减 1 的调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> target.set(<span class=\"string\">\"hp\"</span>, target.hp<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>总之，等式推导带来的分析代码的能力对重构和理解代码非常重要。事实上，我们重构海鸥程序使用的正是这项技术：利用加和乘的特性。</p>\n<h3 id=\"并行性-Parallelism\"><a href=\"#并行性-Parallelism\" class=\"headerlink\" title=\"并行性(Parallelism)\"></a>并行性(Parallelism)</h3><p>最后一点，也是决定性的一点：我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。</p>\n<p>并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。</p>\n<h2 id=\"柯里化（curry）\"><a href=\"#柯里化（curry）\" class=\"headerlink\" title=\"柯里化（curry）\"></a>柯里化（curry）</h2><h3 id=\"不可或缺的-curry\"><a href=\"#不可或缺的-curry\" class=\"headerlink\" title=\"不可或缺的 curry\"></a>不可或缺的 curry</h3><blockquote>\n<p>我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。</p>\n</blockquote>\n<p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x + y</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> inc = add(<span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">inc(<span class=\"number\">10</span>)</div><div class=\"line\"><span class=\"comment\">// 11</span></div></pre></td></tr></table></figure>\n<p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helperfunction）使这类函数的定义和调用更加容易。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash/curry'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">what, str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.match(what)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> replace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">what, replacement, str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.replace(what, replacement)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> filter = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, ary</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ary.filter(f)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, ary</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ary.map(f)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">match(<span class=\"regexp\">/\\s+/g</span>, <span class=\"string\">\"hello world\"</span>)</div><div class=\"line\"><span class=\"comment\">// [ ' ' ]</span></div><div class=\"line\">match(<span class=\"regexp\">/\\s+/g</span>)(<span class=\"string\">\"hello world\"</span>)</div><div class=\"line\"><span class=\"comment\">// [ ' ' ]</span></div><div class=\"line\"><span class=\"keyword\">let</span> hasSpaces = match(<span class=\"regexp\">/\\s+/g</span>)</div><div class=\"line\"><span class=\"comment\">// function(x) &#123; return x.match(/\\s+/g) &#125;</span></div><div class=\"line\">hasSpaces(<span class=\"string\">\"hello world\"</span>)</div><div class=\"line\"><span class=\"comment\">// [ ' ' ]</span></div><div class=\"line\">hasSpaces(<span class=\"string\">\"spaceless\"</span>)</div><div class=\"line\"><span class=\"comment\">// null</span></div><div class=\"line\">filter(hasSpaces, [<span class=\"string\">\"tori_spelling\"</span>, <span class=\"string\">\"tori amos\"</span>])</div><div class=\"line\"><span class=\"comment\">// [\"tori amos\"]</span></div><div class=\"line\"><span class=\"keyword\">let</span> findSpaces = filter(hasSpaces)</div><div class=\"line\"><span class=\"comment\">// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(/\\s+/g) &#125;) &#125;</span></div><div class=\"line\">findSpaces([<span class=\"string\">\"tori_spelling\"</span>, <span class=\"string\">\"tori amos\"</span>])</div><div class=\"line\"><span class=\"comment\">// [\"tori amos\"]</span></div><div class=\"line\"><span class=\"keyword\">let</span> noVowels = replace(<span class=\"regexp\">/[aeiou]/ig</span>);</div><div class=\"line\"><span class=\"comment\">// function(replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;</span></div><div class=\"line\"><span class=\"keyword\">let</span> censored = noVowels(<span class=\"string\">\"*\"</span>);</div><div class=\"line\"><span class=\"comment\">// function(x) &#123; return x.replace(/[aeiou]/ig, \"*\") &#125;</span></div><div class=\"line\">censored(<span class=\"string\">\"Chocolate Rain\"</span>);</div><div class=\"line\"><span class=\"comment\">// 'Ch*c*l*t* R**n'</span></div></pre></td></tr></table></figure>\n<p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p>\n<h3 id=\"不仅仅是双关语／咖喱\"><a href=\"#不仅仅是双关语／咖喱\" class=\"headerlink\" title=\"不仅仅是双关语／咖喱\"></a>不仅仅是双关语／咖喱</h3><p>用 map 简单地把参数是单个元素的函数包裹一下，就能把它转换成参数为数组的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> getLength = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x.length</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> getAllLength = map(getLength)</div></pre></td></tr></table></figure>\n<p>只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码（boilerplate code）。</p>\n<p>通常我们不定义直接操作数组的函数，因为只需内联调用 map(getChildren) 就能达到目的。这一点同样适用于 sort 、 filter 以及其他的高阶函数（higherorder function）（高阶函数：参数或返回值为函数的函数）。</p>\n<p>当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。</p>\n<p>curry 函数用起来非常得心应手，通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。</p>\n<h2 id=\"代码组合（compose）\"><a href=\"#代码组合（compose）\" class=\"headerlink\" title=\"代码组合（compose）\"></a>代码组合（compose）</h2><h3 id=\"函数饲养\"><a href=\"#函数饲养\" class=\"headerlink\" title=\"函数饲养\"></a>函数饲养</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f(g(x))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>f 和 g 都是函数， x 是在它们之间通过“管道”传输的值在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据流。</p>\n<p>组合看起来像是在饲养函数让它们结合，产下一个崭新的函数。组合的用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> toUpperCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toUpperCase()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> toLowerCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toLowerCase()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> exclaim = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str + <span class=\"string\">'!'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> angry = compose(exclaim, toUpperCase)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> shout = compose(exclaim, toUpperCase)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(exclaim(toUpperCase(<span class=\"string\">\"hello\"</span>)))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(shout(<span class=\"string\">\"hello\"</span>))</div></pre></td></tr></table></figure>\n<p>这个组合中函数的执行顺序应该是显而易见的。尽管我们可以定义一个从左向右的版本，但是从右向左执行更加能够反映数学上的含义——是的，组合的概念直接来自于数学课本。</p>\n<p>现在是时候去看看所有的组合都有的一个特性了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结合律（associativity）</span></div><div class=\"line\"><span class=\"comment\">// let associative = compose(f, compose(g, h)) == compose(compose(f, g), h)    </span></div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(compose(reverse, compose(toUpperCase, exclaim))(<span class=\"string\">\"world\"</span>))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(compose(compose(reverse, toUpperCase), exclaim)(<span class=\"string\">\"world\"</span>))</div></pre></td></tr></table></figure>\n<p>符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。</p>\n<p>结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。</p>\n<h3 id=\"pointfree\"><a href=\"#pointfree\" class=\"headerlink\" title=\"pointfree\"></a>pointfree</h3><p>pointfree 模式指的是，永远不必说出你的数据。它的意思是说，函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 非 pointfree，因为提到了数据：word</span></div><div class=\"line\"><span class=\"keyword\">let</span> snakeCase = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> word.toLowerCase().replace(<span class=\"regexp\">/\\s+/ig</span>, <span class=\"string\">'_'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// pointfree</span></div><div class=\"line\">snakeCase = compose(replace(<span class=\"regexp\">/\\s+/ig</span>, <span class=\"string\">'_'</span>), toUpperCase)</div></pre></td></tr></table></figure>\n<p>这里所做的事情就是通过管道把数据在接受单个参数的函数间传递。利用 curry，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。</p>\n<p>另外，pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，pointfree 是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。比如，while 循环是不能组合的。不过你也要警惕，pointfree 就像是一把双刃剑，有时候也能混淆视听。并非所有的函数式代码都是 pointfree 的，不过这没关系。可以使用它的时候就使用，不能使用的时候就用普通函数。</p>\n<h3 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h3><p>组合的一个常见错误是，在没有局部调用之前，就组合类似 map 这样接受两个参数的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。</span></div><div class=\"line\"><span class=\"keyword\">let</span> latin = compose(map, angry, reverse)</div><div class=\"line\">latin([<span class=\"string\">\"frog\"</span>, <span class=\"string\">\"eyes\"</span>])</div><div class=\"line\"><span class=\"comment\">// error</span></div><div class=\"line\"><span class=\"comment\">// 正确做法：每个函数都接受一个实际参数。</span></div><div class=\"line\"><span class=\"keyword\">let</span> latin = compose(map(angry), reverse)</div><div class=\"line\">latin([<span class=\"string\">\"frog\"</span>, <span class=\"string\">\"eyes\"</span>])</div><div class=\"line\"><span class=\"comment\">// [\"EYES!\", \"FROG!\"])</span></div></pre></td></tr></table></figure>\n<p>如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的trace 函数来追踪代码的执行情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> trace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag, x</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(tag, x)</div><div class=\"line\">    <span class=\"keyword\">return</span> x</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> dasherize = compose(join(<span class=\"string\">'-'</span>), toLower, split(<span class=\"string\">' '</span>), replace(<span class=\"regexp\">/\\s&#123;2,&#125;/ig</span>, <span class=\"string\">' '</span>))</div><div class=\"line\"></div><div class=\"line\">dasherize(<span class=\"string\">'The world is a vampire'</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: Cannot read property 'apply' of undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> dasherize = compose(join(<span class=\"string\">'-'</span>), toLower, trace(<span class=\"string\">\"after split\"</span>), split(<span class=\"string\">' '</span>), replace(<span class=\"regexp\">/\\s&#123;2,&#125;/ig</span>, <span class=\"string\">' '</span>));</div><div class=\"line\"><span class=\"comment\">// after split [ 'The', 'world', 'is', 'a', 'vampire' ]</span></div></pre></td></tr></table></figure>\n<p>trace 函数允许我们在某个特定的点观察数据以便 debug。像 haskell 和 purescript 之类的语言出于开发的方便，也都提供了类似的函数。</p>\n<p>组合将成为我们构造程序的工具，而且幸运的是，它背后是有一个强大的理论做支撑的。</p>\n<h3 id=\"范畴学（category-theory）\"><a href=\"#范畴学（category-theory）\" class=\"headerlink\" title=\"范畴学（category theory）\"></a>范畴学（category theory）</h3><p>范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（settheory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式：</p>\n<p><img src=\"范畴学.png\" alt=\"范畴学\"></p>\n<p>在范畴学中，有一个概念叫做…范畴。有着以下这些组件（component）的搜集<br>（collection）就构成了一个范畴：</p>\n<ul>\n<li>对象的搜集</li>\n<li>态射的搜集</li>\n<li>态射的组合</li>\n<li>identity 这个独特的态射</li>\n</ul>\n<p>范畴学抽象到足以模拟任何事物，不过目前我们最关心的还是类型和函数，所以让我们把范畴学运用到它们身上看看。</p>\n<p>对象的搜集</p>\n<p>对象就是数据类型，例如 String 、 Boolean 、 Number 和 Object 等等。通常我们把数据类型视作所有可能的值的一个集合（set）。像 Boolean 就可以看作是 [true, false] 的集合， Number 可以是所有实数的一个集合。把类型当作集合对待是有好处的，因为我们可以利用集合论（set theory）处理类型。</p>\n<p>态射的搜集</p>\n<p>态射是标准的、普通的纯函数。</p>\n<p>态射的组合</p>\n<p>这就是本章介绍的新玩意儿—— 组合 。我们已经讨论过compose 函数是符合结合律的，这并非巧合，结合律是在范畴学中对任何组合都适用的一个特性。</p>\n<p><img src=\"compose.png\" alt=\"compose\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x.length &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x === <span class=\"number\">4</span>; &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> isFourLetterWord = compose(f, g)</div></pre></td></tr></table></figure>\n<p>identity 这个独特的态射</p>\n<p>让我们介绍一个名为 id 的实用函数。这个函数接受随便什么输入然后原封不动地返回它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> id = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x&#125;</div></pre></td></tr></table></figure>\n<p>id 函数跟组合一起使用简直完美。下面这个特性对所有的一元函数（unary function）（一元函数：只接受一个参数的函数） f 都成立：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// identity</span></div><div class=\"line\">compose(id, f) == compose(f, id) == f</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这就是实数的单位元（identity property）嘛！慢慢理解它的无用性，很快我们就会到处使用 id 了，不过暂时我们还是把它当作一个替代给定值的函数。这对写 pointfree 的代码非常有用。</p>\n<p>除了类型和函数，还有什么范畴呢？还有很多，比如我们可以定义一个有向图（directed graph），以节点为对象，以边为态射，以路径连接为组合。还可以定义一个实数类型（Number），以所有的实数为对象，以 &gt;= 为态射（实际上任何偏序（partial order）或全序（total order）都可以成为一个范畴）。范畴的总数是无限的，但我们只需要关心上面定义的范畴就好了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。我们认为组合是高于其他所有原则的设计原则，这是因为组合让我们的代码简单而富有可读性。另外范畴学将在应用架构、模拟副作用和保证正确性方面扮演重要角色。</p>\n<h2 id=\"示例应用\"><a href=\"#示例应用\" class=\"headerlink\" title=\"示例应用\"></a>示例应用</h2><h3 id=\"声明式代码\"><a href=\"#声明式代码\" class=\"headerlink\" title=\"声明式代码\"></a>声明式代码</h3><p>我们要开始转变观念了，从本章开始，我们将不再指示计算机如何工作，而是指出我们明确希望得到的结果。</p>\n<p>与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。</p>\n<p>以 SQL 为例，它就没有“先做这个，再做那个”的命令，有的只是一个指明我们想要从数据库取什么数据的表达式。至于如何取数据则是由它自己决定的。以后数据库升级也好，SQL 引擎优化也好，根本不需要更改查询语句。这是因为，有多种方式解析一个表达式并得到相同的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 命令式</span></div><div class=\"line\"><span class=\"keyword\">let</span> makes = []</div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; cars.length; i++) &#123;</div><div class=\"line\">    makes.push(cars[i].make)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 声明式</span></div><div class=\"line\"><span class=\"keyword\">let</span> makes = cars.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">car</span>)</span>&#123; <span class=\"keyword\">return</span> car.make &#125;)</div></pre></td></tr></table></figure>\n<p>命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来…实在是直白得有些露骨。</p>\n<p>使用 map 的版本是一个表达式，它对执行顺序没有要求。而且， map 函数如何进行迭代，返回的数组如何收集，都有很大的自由度。它指明的是 做什么 ，不是怎么做。因此，它是正儿八经的声明式代码。</p>\n<p>再看一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> authenticate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">form</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> user = toUser(form)</div><div class=\"line\">    <span class=\"keyword\">return</span> logIn(user)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// return logIn(toUser(form))</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> authenticate = compose(logIn, toUser)</div></pre></td></tr></table></figure>\n<p>虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser和 logIn 两个行为的组合。这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。</p>\n<p>因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JS函数式编程\"><a href=\"#JS函数式编程\" class=\"headerlink\" title=\"JS函数式编程\"></a>JS函数式编程</h1><h2 id=\"我们在做什么\"><a href=\"#我们在做什么\" class=\"headerlink\" title=\"我们在做什么\"></a>我们在做什么</h2><blockquote>\n<p>“we both know what happens when you assume”，源自一句名言“When you assume you make an ASS of U and ME”，意思是“让两人都难堪”）。但我猜想你在使用可变状态（mutable state）、无限制副作用（unrestricted side effects）和无原则设计（unprincipled design）的过程中已经遇到过一些麻烦。</p>\n</blockquote>\n<p>现在已经有一些通用的编程原则了，各种缩写词带领我们在编程的黑暗隧道里前行：DRY（不要重复自己，don’t repeat yourself），高内聚低耦合（loosecoupling high cohesion），YAGNI （你不会用到它的，ya ain’t gonna need it），最小意外原则（Principle of least surprise），单一责任（single responsibility）等等。这些原则同样适用于函数式编程(FP)。</p>","more":"<p>先看基本的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> multiply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x * y</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> result = add(multiply(b, add(a, c)), multiply(a, b));</div><div class=\"line\"><span class=\"comment\">//=&gt;16</span></div></pre></td></tr></table></figure>\n<p>你会发现我们不过是在运用古人早已获得的知识</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结合律（assosiative）</span></div><div class=\"line\">add(add(x, y), z) == add(x, add(y, z));</div><div class=\"line\"><span class=\"comment\">// 交换律（commutative）</span></div><div class=\"line\">add(x, y) == add(y, x);</div><div class=\"line\"><span class=\"comment\">// 同一律（identity）</span></div><div class=\"line\">add(x, <span class=\"number\">0</span>) == x;</div><div class=\"line\"><span class=\"comment\">// 分配律（distributive）</span></div><div class=\"line\">multiply(x, add(y, z)) == add(multiply(x, y), multiply(x, z));</div><div class=\"line\"><span class=\"comment\">// 原有代码</span></div><div class=\"line\">add(multiply(b, add(a, c)), multiply(a, b));</div><div class=\"line\"><span class=\"comment\">// 应用同一律，去掉多余的加法操作（add(a, c) == a）</span></div><div class=\"line\">add(multiply(b, a), multiply(a, b));</div><div class=\"line\"><span class=\"comment\">// 再应用分配律</span></div><div class=\"line\">multiply(b, add(a, a));</div></pre></td></tr></table></figure>\n<p>当然这里我们定义 add 和 multiply 是为了代码完整性，实际上并不必要——在调用之前它们肯定已经在某个类库里定义好了。</p>\n<p>我们希望去践行每一部分都能完美接合的理论，希望能以一种通用的、可组合的组件来表示我们的特定问题，然后利用这些组件的特性来解决这些问题。相比命令式编程的那种“某某去做某事”的方式，函数式编程将会有更多的约束，不过你会震惊于这种强约束、数学性的“框架”所带来的回报。</p>\n<h2 id=\"一等公民的函数\"><a href=\"#一等公民的函数\" class=\"headerlink\" title=\"一等公民的函数\"></a>一等公民的函数</h2><p>先看看常见的JS风格的一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajaxCall</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 用一个函数把另一个函数包起来，目的仅仅是延迟执行，真的是非常糟糕的编程习惯</span></div><div class=\"line\"><span class=\"keyword\">let</span> getServerStuff = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ajaxCall(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">json</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> callback(json);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这行</span></div><div class=\"line\"><span class=\"comment\">// return ajaxCall(function (json) &#123;</span></div><div class=\"line\"><span class=\"comment\">// return callback(json);</span></div><div class=\"line\"><span class=\"comment\">// &#125;);</span></div><div class=\"line\"><span class=\"comment\">// 等价于这行</span></div><div class=\"line\"><span class=\"comment\">// return ajaxCall(callback);</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 应该改成这样</span></div><div class=\"line\"><span class=\"keyword\">let</span> getServerStuff = ajaxCall;</div></pre></td></tr></table></figure>\n<p>再看另一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Views</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Db</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这样做除了徒增代码量，提高维护和检索代码的成本外，没有任何用处</span></div><div class=\"line\"><span class=\"keyword\">let</span> BlogController = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> index = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Views.index(posts);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> show = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Views.show(post);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">attrs</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Db.create(attrs);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> update = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post, attrs</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Db.update(post, attrs);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">let</span> destroy = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">post</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Db.destroy(post);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        index,</div><div class=\"line\">        show,</div><div class=\"line\">        create,</div><div class=\"line\">        update,</div><div class=\"line\">        destroy</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 我们可以把它重写成这样：</span></div><div class=\"line\"><span class=\"keyword\">let</span> BlogController = &#123;</div><div class=\"line\">    index: Views.index,</div><div class=\"line\">    show: Views.show,</div><div class=\"line\">    create: Db.create,</div><div class=\"line\">    update: Db.update,</div><div class=\"line\">    destroy: Db.destroy</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// 或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已</span></div></pre></td></tr></table></figure>\n<p>另外，如果一个函数被不必要地包裹起来了，而且发生了改动，那么包裹它的那个函数也要做相应的变更。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> renderPost(json);</div><div class=\"line\">&#125;);</div><div class=\"line\"><span class=\"comment\">// 如果 httpGet 要改成可以抛出一个可能出现的 err 异常，那我们还要回过头去把“胶水”函数也改了</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 把整个应用里的所有 httpGet 调用都改成这样，可以传递 err 参数。</span></div><div class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json, err</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> renderPost(json, err);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 写成一等公民函数的形式，要做的改动将会少得多</span></div><div class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, renderPost); </div><div class=\"line\"><span class=\"comment\">// renderPost 将会在 httpGet 中调用，想要多少参数都行</span></div></pre></td></tr></table></figure>\n<p>除了删除不必要的函数，正确地为参数命名也必不可少。当然命名不是什么大问题，但还是有可能存在一些不当的命名，尤其随着代码量的增长以及需求的变更，这种可能性也会增加。</p>\n<p>如果一个底层函数使用了 this，而且是以一等公民的方式被调用的，那你就等着 JS 这个蹩脚的抽象概念发怒吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// 太可怕了</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'freaky_friday.txt'</span>, Db.save);</div><div class=\"line\"><span class=\"comment\">// 好一点点</span></div><div class=\"line\">fs.readFile(<span class=\"string\">'freaky_friday.txt'</span>, Db.save.bind(Db));</div></pre></td></tr></table></figure>\n<h2 id=\"纯函数的好处\"><a href=\"#纯函数的好处\" class=\"headerlink\" title=\"纯函数的好处\"></a>纯函数的好处</h2><blockquote>\n<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>\n</blockquote>\n<p>比如 slice 和 splice。我们说 slice 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 splice 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> xs = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\">xs.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\">xs.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\">xs.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\"><span class=\"comment\">// 不纯的</span></div><div class=\"line\">xs.splice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [1,2,3]</span></div><div class=\"line\">xs.splice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; [4,5]</span></div><div class=\"line\">xs.splice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; []</span></div></pre></td></tr></table></figure>\n<p>下一个例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 不纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> minimum = <span class=\"number\">21</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> age &gt;= minimum;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> minimum = <span class=\"number\">21</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> age &gt;= minimum;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\"><span class=\"keyword\">const</span> minimum = <span class=\"number\">21</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> age &gt;= minimum;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>在不纯的版本中， checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态（system state）；这一点令人沮丧，因为它引入了外部的环境，从而增加了认知负荷（cognitive load）。</p>\n<p>另一方面，使用纯函数的形式，函数就能做到自给自足。我们也可以让 minimum成为一个不可变（immutable）对象，这样就能保留纯粹性，因为状态不会有变化。要实现这个效果，必须得创建一个对象，然后调用 Object.freeze 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> immutableState = <span class=\"built_in\">Object</span>.freeze(&#123;</div><div class=\"line\">    minimun: <span class=\"number\">21</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>\n</blockquote>\n<p>副作用可能包含，但不限于：</p>\n<ul>\n<li>更改文件系统</li>\n<li>往数据库插入记录</li>\n<li>发送一个 http 请求</li>\n<li>可变数据</li>\n<li>打印/log</li>\n<li>获取用户输入</li>\n<li>DOM 查询</li>\n<li>访问系统状态</li>\n</ul>\n<p>这个列表还可以继续写下去。概括来讲，只要是跟函数外部环境发生的交互就都是副作用——这一点可能会让你怀疑无副作用编程的可行性。函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。</p>\n<p>这并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生。后面讲到 functor 和 monad 的时候我们会学习如何控制它们。</p>\n<h3 id=\"追求“纯”的理由\"><a href=\"#追求“纯”的理由\" class=\"headerlink\" title=\"追求“纯”的理由\"></a>追求“纯”的理由</h3><ul>\n<li>可缓存性（Cacheable）</li>\n<li>可移植性／自文档化（Portable / SelfDocumenting）</li>\n<li>可测试性（Testable）</li>\n<li>合理性（Reasonable）</li>\n<li>并行性(Parallelism)</li>\n</ul>\n<h4 id=\"可缓存性（Cacheable）\"><a href=\"#可缓存性（Cacheable）\" class=\"headerlink\" title=\"可缓存性（Cacheable）\"></a>可缓存性（Cacheable）</h4><p>首先，纯函数总能够根据输入来做<code>缓存</code>。实现缓存的一种典型方式是 <code>memoize</code> 技术</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> squareNumber = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> x * x&#125;);</div><div class=\"line\">squareNumber(<span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; 16</span></div><div class=\"line\">squareNumber(<span class=\"number\">4</span>); <span class=\"comment\">// 从缓存中读取输入值为 4 的结果</span></div><div class=\"line\"><span class=\"comment\">//=&gt; 16</span></div><div class=\"line\">squareNumber(<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"comment\">//=&gt; 25</span></div><div class=\"line\">squareNumber(<span class=\"number\">5</span>); <span class=\"comment\">// 从缓存中读取输入值为 5 的结果</span></div><div class=\"line\"><span class=\"comment\">//=&gt; 25</span></div></pre></td></tr></table></figure>\n<p>下面的代码是<code>memoize</code>一个简单的实现，尽管它不太健壮</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">momoize</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> cache = &#123;&#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> arg_str = <span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">arguments</span>)</div><div class=\"line\">        <span class=\"comment\">// 有cache则返回cache里的，总是保存到cache里</span></div><div class=\"line\">        cache[arg_str] = cache[arg_str] || f(...arguments)</div><div class=\"line\">        <span class=\"keyword\">return</span> cache[arg_str]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得注意的一点是，可以通过延迟执行的方式把不纯的函数转换为纯函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> pureHttpCall = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, params</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> $.getJSON(url, params); &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里有趣的地方在于我们并没有真正发送 http 请求——只是返回了一个函数，当调用它的时候才会发请求。这个函数之所以有资格成为纯函数，是因为它总是会根据相同的输入返回相同的输出：给定了 url 和 params 之后，它就只会返回同一个发送 http 请求的函数</p>\n<p>我们的 memoize 函数工作起来没有任何问题，虽然它缓存的并不是 http 请求所返回的结果，而是生成的函数。</p>\n<p>重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。</p>\n<hr>\n<h4 id=\"可移植性／自文档化（Portable-SelfDocumenting）\"><a href=\"#可移植性／自文档化（Portable-SelfDocumenting）\" class=\"headerlink\" title=\"可移植性／自文档化（Portable / SelfDocumenting）\"></a>可移植性／自文档化（Portable / SelfDocumenting）</h4><p>纯函数是完全自给自足的，它需要的所有东西都能轻易获得。仔细思考思考这一点…这种自给自足的好处是什么呢？首先，纯函数的依赖很明确，因此更易于观察和理解。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 不纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> signUp = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> user = saveUser(attrs);</div><div class=\"line\">    welcomeUser(user);</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> saveUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> user = Db.save(attrs);</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> welcomeUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Email(user, ...);</span></div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 纯的</span></div><div class=\"line\"><span class=\"keyword\">let</span> signUp = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Db, Email, attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 参数绑定</span></div><div class=\"line\">        <span class=\"keyword\">let</span> user = saveUser(Db, attrs);</div><div class=\"line\">        welcomeUser(Email, user);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> saveUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Db, attrs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> welcomeUser = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Email, user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这个例子表明，纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 signUp 的签名就可以看出，它将要用到 Db、Email 和 attrs ，这在最小程度上给了我们足够多的信息。</p>\n<p>其次，通过强迫“注入”依赖，或者把它们当作参数传递，我们的应用也更加灵活；因为数据库或者邮件客户端等等都参数化了。</p>\n<p>命令式编程中“典型”的方法和过程都深深地根植于它们所在的环境中，通过状态、依赖和有效作用（available effects）达成；纯函数与此相反，它与环境无关，只要我们愿意，可以在任何地方运行它。</p>\n<h4 id=\"可测试性（Testable）\"><a href=\"#可测试性（Testable）\" class=\"headerlink\" title=\"可测试性（Testable）\"></a>可测试性（Testable）</h4><p>第三点，纯函数让<code>测试</code>更加容易。</p>\n<p>我们不需要伪造一个“真实的”支付网关，或者每一次测试之前都要配置、之后都要断言状态（assert the state）。只需简单地给函数一个输入，然后断言输出就好了。</p>\n<h4 id=\"合理性（Reasonable）\"><a href=\"#合理性（Reasonable）\" class=\"headerlink\" title=\"合理性（Reasonable）\"></a>合理性（Reasonable）</h4><p>很多人相信使用纯函数最大的好处是<code>引用透明性（referential transparency）</code>。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</p>\n<p>由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。我们来看一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Immutable = <span class=\"built_in\">require</span>(<span class=\"string\">'immutable'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> decrementHP = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> player.set(<span class=\"string\">\"hp\"</span>, player.hp<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> isSameTeam = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player1, player2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> player1.team === player2.team;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(isSameTeam(player, target)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> target;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> jobe = Immutable.Map(&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Jobe\"</span>, <span class=\"attr\">hp</span>:<span class=\"number\">20</span>, <span class=\"attr\">team</span>: <span class=\"string\">\"red\"</span>&#125;);</div><div class=\"line\"><span class=\"keyword\">let</span> michael = Immutable.Map(&#123;<span class=\"attr\">name</span>:<span class=\"string\">\"Michael\"</span>, <span class=\"attr\">hp</span>:<span class=\"number\">20</span>, <span class=\"attr\">team</span>: <span class=\"string\">\"green\"</span>&#125;);</div><div class=\"line\"></div><div class=\"line\">punch(jobe, michael);</div><div class=\"line\"><span class=\"comment\">//=&gt; Immutable.Map(&#123;name:\"Michael\", hp:19, team: \"green\"&#125;)</span></div></pre></td></tr></table></figure>\n<p>decrementHP 、 isSameTeam 和 punch 都是纯函数，所以是引用透明的。我们可以使用一种叫做<code>“等式推导”（equational reasoning）</code>的技术来分析代码。所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码。我们借助引用透明性来剖析一下这段代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(player.team === target.team) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> target;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>因为是不可变数据，我们可以直接把 team 替换为实际值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"red\"</span> === <span class=\"string\">\"green\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> target;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>if 语句执行结果为 false ，所以可以把整个 if 语句都删掉：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> decrementHP(target);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如果再内联 decrementHP ，我们会发现这种情况下， punch 变成了一个让 hp 的值减 1 的调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> punch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">player, target</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> target.set(<span class=\"string\">\"hp\"</span>, target.hp<span class=\"number\">-1</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>总之，等式推导带来的分析代码的能力对重构和理解代码非常重要。事实上，我们重构海鸥程序使用的正是这项技术：利用加和乘的特性。</p>\n<h3 id=\"并行性-Parallelism\"><a href=\"#并行性-Parallelism\" class=\"headerlink\" title=\"并行性(Parallelism)\"></a>并行性(Parallelism)</h3><p>最后一点，也是决定性的一点：我们可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。</p>\n<p>并行代码在服务端 js 环境以及使用了 web worker 的浏览器那里是非常容易实现的，因为它们使用了线程（thread）。</p>\n<h2 id=\"柯里化（curry）\"><a href=\"#柯里化（curry）\" class=\"headerlink\" title=\"柯里化（curry）\"></a>柯里化（curry）</h2><h3 id=\"不可或缺的-curry\"><a href=\"#不可或缺的-curry\" class=\"headerlink\" title=\"不可或缺的 curry\"></a>不可或缺的 curry</h3><blockquote>\n<p>我父亲以前跟我说过，有些事物在你得到之前是无足轻重的，得到之后就不可或缺了。微波炉是这样，智能手机是这样，互联网也是这样——老人们在没有互联网的时候过得也很充实。对我来说，函数的柯里化（curry）也是这样。</p>\n</blockquote>\n<p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x + y</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> inc = add(<span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">inc(<span class=\"number\">10</span>)</div><div class=\"line\"><span class=\"comment\">// 11</span></div></pre></td></tr></table></figure>\n<p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的 curry 帮助函数（helperfunction）使这类函数的定义和调用更加容易。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash/curry'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">what, str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.match(what)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> replace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">what, replacement, str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.replace(what, replacement)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> filter = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, ary</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ary.filter(f)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, ary</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> ary.map(f)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">match(<span class=\"regexp\">/\\s+/g</span>, <span class=\"string\">\"hello world\"</span>)</div><div class=\"line\"><span class=\"comment\">// [ ' ' ]</span></div><div class=\"line\">match(<span class=\"regexp\">/\\s+/g</span>)(<span class=\"string\">\"hello world\"</span>)</div><div class=\"line\"><span class=\"comment\">// [ ' ' ]</span></div><div class=\"line\"><span class=\"keyword\">let</span> hasSpaces = match(<span class=\"regexp\">/\\s+/g</span>)</div><div class=\"line\"><span class=\"comment\">// function(x) &#123; return x.match(/\\s+/g) &#125;</span></div><div class=\"line\">hasSpaces(<span class=\"string\">\"hello world\"</span>)</div><div class=\"line\"><span class=\"comment\">// [ ' ' ]</span></div><div class=\"line\">hasSpaces(<span class=\"string\">\"spaceless\"</span>)</div><div class=\"line\"><span class=\"comment\">// null</span></div><div class=\"line\">filter(hasSpaces, [<span class=\"string\">\"tori_spelling\"</span>, <span class=\"string\">\"tori amos\"</span>])</div><div class=\"line\"><span class=\"comment\">// [\"tori amos\"]</span></div><div class=\"line\"><span class=\"keyword\">let</span> findSpaces = filter(hasSpaces)</div><div class=\"line\"><span class=\"comment\">// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(/\\s+/g) &#125;) &#125;</span></div><div class=\"line\">findSpaces([<span class=\"string\">\"tori_spelling\"</span>, <span class=\"string\">\"tori amos\"</span>])</div><div class=\"line\"><span class=\"comment\">// [\"tori amos\"]</span></div><div class=\"line\"><span class=\"keyword\">let</span> noVowels = replace(<span class=\"regexp\">/[aeiou]/ig</span>);</div><div class=\"line\"><span class=\"comment\">// function(replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;</span></div><div class=\"line\"><span class=\"keyword\">let</span> censored = noVowels(<span class=\"string\">\"*\"</span>);</div><div class=\"line\"><span class=\"comment\">// function(x) &#123; return x.replace(/[aeiou]/ig, \"*\") &#125;</span></div><div class=\"line\">censored(<span class=\"string\">\"Chocolate Rain\"</span>);</div><div class=\"line\"><span class=\"comment\">// 'Ch*c*l*t* R**n'</span></div></pre></td></tr></table></figure>\n<p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p>\n<h3 id=\"不仅仅是双关语／咖喱\"><a href=\"#不仅仅是双关语／咖喱\" class=\"headerlink\" title=\"不仅仅是双关语／咖喱\"></a>不仅仅是双关语／咖喱</h3><p>用 map 简单地把参数是单个元素的函数包裹一下，就能把它转换成参数为数组的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> getLength = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x.length</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> getAllLength = map(getLength)</div></pre></td></tr></table></figure>\n<p>只传给函数一部分参数通常也叫做局部调用（partial application），能够大量减少样板文件代码（boilerplate code）。</p>\n<p>通常我们不定义直接操作数组的函数，因为只需内联调用 map(getChildren) 就能达到目的。这一点同样适用于 sort 、 filter 以及其他的高阶函数（higherorder function）（高阶函数：参数或返回值为函数的函数）。</p>\n<p>当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。</p>\n<p>curry 函数用起来非常得心应手，通过简单地传递几个参数，就能动态创建实用的新函数；而且还能带来一个额外好处，那就是保留了数学的函数定义，尽管参数不止一个。</p>\n<h2 id=\"代码组合（compose）\"><a href=\"#代码组合（compose）\" class=\"headerlink\" title=\"代码组合（compose）\"></a>代码组合（compose）</h2><h3 id=\"函数饲养\"><a href=\"#函数饲养\" class=\"headerlink\" title=\"函数饲养\"></a>函数饲养</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f(g(x))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>f 和 g 都是函数， x 是在它们之间通过“管道”传输的值在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据流。</p>\n<p>组合看起来像是在饲养函数让它们结合，产下一个崭新的函数。组合的用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> toUpperCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toUpperCase()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> toLowerCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toLowerCase()</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> exclaim = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str + <span class=\"string\">'!'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> angry = compose(exclaim, toUpperCase)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> shout = compose(exclaim, toUpperCase)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(exclaim(toUpperCase(<span class=\"string\">\"hello\"</span>)))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(shout(<span class=\"string\">\"hello\"</span>))</div></pre></td></tr></table></figure>\n<p>这个组合中函数的执行顺序应该是显而易见的。尽管我们可以定义一个从左向右的版本，但是从右向左执行更加能够反映数学上的含义——是的，组合的概念直接来自于数学课本。</p>\n<p>现在是时候去看看所有的组合都有的一个特性了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 结合律（associativity）</span></div><div class=\"line\"><span class=\"comment\">// let associative = compose(f, compose(g, h)) == compose(compose(f, g), h)    </span></div><div class=\"line\"><span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(compose(reverse, compose(toUpperCase, exclaim))(<span class=\"string\">\"world\"</span>))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(compose(compose(reverse, toUpperCase), exclaim)(<span class=\"string\">\"world\"</span>))</div></pre></td></tr></table></figure>\n<p>符合结合律意味着不管你是把 g 和 h 分到一组，还是把 f 和 g 分到一组都不重要。</p>\n<p>结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。</p>\n<h3 id=\"pointfree\"><a href=\"#pointfree\" class=\"headerlink\" title=\"pointfree\"></a>pointfree</h3><p>pointfree 模式指的是，永远不必说出你的数据。它的意思是说，函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 非 pointfree，因为提到了数据：word</span></div><div class=\"line\"><span class=\"keyword\">let</span> snakeCase = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">word</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> word.toLowerCase().replace(<span class=\"regexp\">/\\s+/ig</span>, <span class=\"string\">'_'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// pointfree</span></div><div class=\"line\">snakeCase = compose(replace(<span class=\"regexp\">/\\s+/ig</span>, <span class=\"string\">'_'</span>), toUpperCase)</div></pre></td></tr></table></figure>\n<p>这里所做的事情就是通过管道把数据在接受单个参数的函数间传递。利用 curry，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。</p>\n<p>另外，pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，pointfree 是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。比如，while 循环是不能组合的。不过你也要警惕，pointfree 就像是一把双刃剑，有时候也能混淆视听。并非所有的函数式代码都是 pointfree 的，不过这没关系。可以使用它的时候就使用，不能使用的时候就用普通函数。</p>\n<h3 id=\"debug\"><a href=\"#debug\" class=\"headerlink\" title=\"debug\"></a>debug</h3><p>组合的一个常见错误是，在没有局部调用之前，就组合类似 map 这样接受两个参数的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 错误做法：我们传给了 `angry` 一个数组，根本不知道最后传给 `map` 的是什么东西。</span></div><div class=\"line\"><span class=\"keyword\">let</span> latin = compose(map, angry, reverse)</div><div class=\"line\">latin([<span class=\"string\">\"frog\"</span>, <span class=\"string\">\"eyes\"</span>])</div><div class=\"line\"><span class=\"comment\">// error</span></div><div class=\"line\"><span class=\"comment\">// 正确做法：每个函数都接受一个实际参数。</span></div><div class=\"line\"><span class=\"keyword\">let</span> latin = compose(map(angry), reverse)</div><div class=\"line\">latin([<span class=\"string\">\"frog\"</span>, <span class=\"string\">\"eyes\"</span>])</div><div class=\"line\"><span class=\"comment\">// [\"EYES!\", \"FROG!\"])</span></div></pre></td></tr></table></figure>\n<p>如果在 debug 组合的时候遇到了困难，那么可以使用下面这个实用的，但是不纯的trace 函数来追踪代码的执行情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> trace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag, x</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(tag, x)</div><div class=\"line\">    <span class=\"keyword\">return</span> x</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> dasherize = compose(join(<span class=\"string\">'-'</span>), toLower, split(<span class=\"string\">' '</span>), replace(<span class=\"regexp\">/\\s&#123;2,&#125;/ig</span>, <span class=\"string\">' '</span>))</div><div class=\"line\"></div><div class=\"line\">dasherize(<span class=\"string\">'The world is a vampire'</span>)</div><div class=\"line\"><span class=\"comment\">// TypeError: Cannot read property 'apply' of undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> dasherize = compose(join(<span class=\"string\">'-'</span>), toLower, trace(<span class=\"string\">\"after split\"</span>), split(<span class=\"string\">' '</span>), replace(<span class=\"regexp\">/\\s&#123;2,&#125;/ig</span>, <span class=\"string\">' '</span>));</div><div class=\"line\"><span class=\"comment\">// after split [ 'The', 'world', 'is', 'a', 'vampire' ]</span></div></pre></td></tr></table></figure>\n<p>trace 函数允许我们在某个特定的点观察数据以便 debug。像 haskell 和 purescript 之类的语言出于开发的方便，也都提供了类似的函数。</p>\n<p>组合将成为我们构造程序的工具，而且幸运的是，它背后是有一个强大的理论做支撑的。</p>\n<h3 id=\"范畴学（category-theory）\"><a href=\"#范畴学（category-theory）\" class=\"headerlink\" title=\"范畴学（category theory）\"></a>范畴学（category theory）</h3><p>范畴学（category theory）是数学中的一个抽象分支，能够形式化诸如集合论（settheory）、类型论（type theory）、群论（group theory）以及逻辑学（logic）等数学分支中的一些概念。范畴学主要处理对象（object）、态射（morphism）和变化式（transformation），而这些概念跟编程的联系非常紧密。下图是一些相同的概念分别在不同理论下的形式：</p>\n<p><img src=\"范畴学.png\" alt=\"范畴学\"></p>\n<p>在范畴学中，有一个概念叫做…范畴。有着以下这些组件（component）的搜集<br>（collection）就构成了一个范畴：</p>\n<ul>\n<li>对象的搜集</li>\n<li>态射的搜集</li>\n<li>态射的组合</li>\n<li>identity 这个独特的态射</li>\n</ul>\n<p>范畴学抽象到足以模拟任何事物，不过目前我们最关心的还是类型和函数，所以让我们把范畴学运用到它们身上看看。</p>\n<p>对象的搜集</p>\n<p>对象就是数据类型，例如 String 、 Boolean 、 Number 和 Object 等等。通常我们把数据类型视作所有可能的值的一个集合（set）。像 Boolean 就可以看作是 [true, false] 的集合， Number 可以是所有实数的一个集合。把类型当作集合对待是有好处的，因为我们可以利用集合论（set theory）处理类型。</p>\n<p>态射的搜集</p>\n<p>态射是标准的、普通的纯函数。</p>\n<p>态射的组合</p>\n<p>这就是本章介绍的新玩意儿—— 组合 。我们已经讨论过compose 函数是符合结合律的，这并非巧合，结合律是在范畴学中对任何组合都适用的一个特性。</p>\n<p><img src=\"compose.png\" alt=\"compose\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> g = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x.length &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x === <span class=\"number\">4</span>; &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> isFourLetterWord = compose(f, g)</div></pre></td></tr></table></figure>\n<p>identity 这个独特的态射</p>\n<p>让我们介绍一个名为 id 的实用函数。这个函数接受随便什么输入然后原封不动地返回它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> id = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x&#125;</div></pre></td></tr></table></figure>\n<p>id 函数跟组合一起使用简直完美。下面这个特性对所有的一元函数（unary function）（一元函数：只接受一个参数的函数） f 都成立：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// identity</span></div><div class=\"line\">compose(id, f) == compose(f, id) == f</div><div class=\"line\"><span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这就是实数的单位元（identity property）嘛！慢慢理解它的无用性，很快我们就会到处使用 id 了，不过暂时我们还是把它当作一个替代给定值的函数。这对写 pointfree 的代码非常有用。</p>\n<p>除了类型和函数，还有什么范畴呢？还有很多，比如我们可以定义一个有向图（directed graph），以节点为对象，以边为态射，以路径连接为组合。还可以定义一个实数类型（Number），以所有的实数为对象，以 &gt;= 为态射（实际上任何偏序（partial order）或全序（total order）都可以成为一个范畴）。范畴的总数是无限的，但我们只需要关心上面定义的范畴就好了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。我们认为组合是高于其他所有原则的设计原则，这是因为组合让我们的代码简单而富有可读性。另外范畴学将在应用架构、模拟副作用和保证正确性方面扮演重要角色。</p>\n<h2 id=\"示例应用\"><a href=\"#示例应用\" class=\"headerlink\" title=\"示例应用\"></a>示例应用</h2><h3 id=\"声明式代码\"><a href=\"#声明式代码\" class=\"headerlink\" title=\"声明式代码\"></a>声明式代码</h3><p>我们要开始转变观念了，从本章开始，我们将不再指示计算机如何工作，而是指出我们明确希望得到的结果。</p>\n<p>与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。</p>\n<p>以 SQL 为例，它就没有“先做这个，再做那个”的命令，有的只是一个指明我们想要从数据库取什么数据的表达式。至于如何取数据则是由它自己决定的。以后数据库升级也好，SQL 引擎优化也好，根本不需要更改查询语句。这是因为，有多种方式解析一个表达式并得到相同的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 命令式</span></div><div class=\"line\"><span class=\"keyword\">let</span> makes = []</div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; cars.length; i++) &#123;</div><div class=\"line\">    makes.push(cars[i].make)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 声明式</span></div><div class=\"line\"><span class=\"keyword\">let</span> makes = cars.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">car</span>)</span>&#123; <span class=\"keyword\">return</span> car.make &#125;)</div></pre></td></tr></table></figure>\n<p>命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来…实在是直白得有些露骨。</p>\n<p>使用 map 的版本是一个表达式，它对执行顺序没有要求。而且， map 函数如何进行迭代，返回的数组如何收集，都有很大的自由度。它指明的是 做什么 ，不是怎么做。因此，它是正儿八经的声明式代码。</p>\n<p>再看一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> authenticate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">form</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> user = toUser(form)</div><div class=\"line\">    <span class=\"keyword\">return</span> logIn(user)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// return logIn(toUser(form))</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> authenticate = compose(logIn, toUser)</div></pre></td></tr></table></figure>\n<p>虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser和 logIn 两个行为的组合。这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范（high level specification）。</p>\n<p>因为声明式代码不指定执行顺序，所以它天然地适合进行并行运算。它与纯函数一起解释了为何函数式编程是未来并行计算的一个不错选择——我们真的不需要做什么就能实现一个并行／并发系统。</p>"},{"title":"VAET阅读稿","date":"2017-10-11T10:53:34.000Z","_content":"\n# VAET: A Visual Analytics Approach for E-transactions Time-Series  电子交易时间序列的一种可视化分析方法\n\n> Cong Xie, Wei Chen, Member, IEEE, Xinxin Huang, Yueqi Hu, Scott Barlowe, and Jing Yang\n\n创新实践的论文阅读作业，翻译了主要内容，加上部分自己的理解并修改部分内容，保留了部分原文，有时候阅读原文更好理解。全文按照论文组织的方式编写，主要是为了理清楚论文的主要思想，并可以简单地给其他人做宏观上的解释，达到基本的教学目的。此文将作为ppt的前稿。\n\n---\n\n<!-- more -->\n\n![图1](VAET-system.png)\n\n## INTRODUCTION 介绍\n\nThe E-transaction time-series contains transactions among multiple users in a time range. Each record contains a time stamp, the IDs of the seller and buyer, and the associated attributes of the commodities. Each record is an atomic element representing an online transaction among a seller and a buyer.\n\n电子交易时间序列包含时间范围内的多个用户之间的交易。 每个记录都包含时间戳，卖方和买方的ID以及相关联的商品的属性。每个卖方和买方之间的网上交易记录都是一个原子元素。\n\n*在时间上下文中分析电子交易时间序列至关重要了解交易行为，学习用户偏好和发现时间趋势。*\n\n通过面试分析师发现以下一些问题常常很难回答：\n\n* 卖方的多个交易之间的时间和`上下文`关系是什么？比如短时间内有个卖家有大量的交易，而且可能来自某个买家，分析师需要发现这样的交易的各种属性。\n* 最常见的交易模式是什么？比如平时工作日交易比较稀疏，但是圣诞节交易比较频繁。\n* 如何识别`有趣`的交易？比如买家勾结来加速影响卖家的信用，一旦这样的模式定义好了，分析师需要在相关的大量数据集中找到特定属性值来挖掘这样的交易。\n* 如何在上下文检测某个交易？比如小额购买巨量的商品可能是个假的交易，利用它来提升卖家排名。为了确认交易是假的，分析师需要将交易与买方和卖方的信息关联。\n\n我们认为，自动数据挖掘过程在回答上述问题时并没有足够的灵活性和准确性。\n因此迫切需要视觉分析方法，使分析人员能够通过集成计算能力，人类知觉能力和领域知识，通过即时视觉反馈灵活地形成和测试假设。\n\n目前还没有适用于上述情况的可视化方法。\n多变量时间序列可视化的现有研究工作主要集中在总结多维度的全局和/或时间趋势或发现个体维度的模式，如Sparklines。\n\n因此提出了一种新颖的视觉分析系统，称为电子交易时间序列的视觉分析（VAET），旨在探索电子交易时间序列，以便在时间上下文中分析多个用户之间的交易模式。\nVAET有如下2个主要的可视化分析组件：\n\n* Overview: This component helps the analysts effectively identify salient transactions from a large dataset. 该组件帮助分析师在大量数据集中快速找到突出的交易。VAET使用概率决策树学习器首先计算每个交易的显着性值，以揭示其与分析目标的相关性（例如，作为假交易的可能性）。然后，显着值显示在一个称为`显着时间映射`（TOS）的像素方向的显示中。该映射提供了一个工作空间来探索和选择不同时间粒度的潜在有趣的交易;\n* Detail view：This component allows the analysts to conduct detailed examination on interesting transactions for insights. 该组件允许分析人员对感兴趣的交易进行仔细检查，以获取见解。特别地，从概述中选择的交易使用称为`KnotLines`的新的视觉隐喻来显示。协调TOS映射和KnotLines，以便分析人员可以快速识别来自大型数据集的有趣事务。\n\nA case study and a user study with a real online transaction dataset demonstrated that VAET was effective in supporting a variety of analysis tasks.\n真实在线交易数据集的案例研究和用户研究表明，VAET有效支持各种分析任务。\n\nVAET的主要贡献包括：\n\n* 视觉分析系统，允许分析人员在时间上有效地分析大型电子交易时间序列;\n* 从大型数据集中检测和可视化突出事务的方法;\n* 一种新颖的视觉隐喻，用于紧凑地放置和编码特征属性以及多用户事务的时间和上下文相关性\n\n## RELATED WORK 相关工作\n\n### Visual Analysis of E-transaction Data 电子交易数据的可视化分析\n\n以下是之前一些人做的过相关研究（寻找合适的可视化方法来展示交易数据）\n\nThe transaction data contains various types of attributes, such as numerical, temporal and categorical. The Sparklines [23] can be used to visualize multiple trends in financial data. Liu et al. [11] proposed a visualization system called SellTrend for analyzing airline travel purchase requests. WireVis [3] was proposed to search on predefined patterns in large wire transaction datasets. Visual analytics approaches have been proposed to explore web clickstreams of online transactions [26]. Our approach is among the earliest visual analytics approaches for the exploration of temporal and contextual connections in multiuser transactions.\n\nTransaction data often have multi-dimensional attributes. Analyzing them often requires the integration of well-designed data mining models. *Probabilistic models are employed to model user behavior [12], resulting in user clusters. This scheme has been successfully applied to classify E-transaction data into different types [2].* Association analysis is another widely used model for transaction data. Hao et al. [7] proposed the DAV system to visualize the relationships of associated products.\n\n### Visual Analysis of User Behavior Time-Series 用户行为时间序列的可视化分析\n\n以前有很多关于用户行为时间序列分析和可视化的作品。这里我们只总结最相关的一些，并将它们分类为分析个人行为，用户交互和组行为的技术。\n\n`Temporal Individual Behavior Patterns` Many visualization approaches designed to analyze user behavior data are focused on exploring the temporal behavior patterns of individuals.\n旨在分析用户行为数据的许多可视化方法都集中在探索个人的时间行为模式。\nTimeSearcher [8] allows users to select interesting time-series using a rectangular query region. LifeLines [16] visualizes health-related incidents of patients along a timeline. Most previous works utilize high-dimensional visual exploration tools such as parallel coordinates [4] to explore extracted patterns. Density-based display techniques [6], [10] are capable of showing large time-series datasets for real-time monitoring. Additional visual exploration techniques include time trajectory [21] and [13].\n\n`User Interaction Patterns` conventional solutions consider the user network as a social network and analyze its global structure\n常规解决方案将用户网络视为社会网络，并分析其全局结构。\nSallaberry et al. [20] provide an overview of dynamic network evolution over time. Other approaches emphasize the user interaction characteristics such as email connections [25] and instant messages [27]. However, these methods are focused on the structural changes rather than the temporal variations of the interactions. Other approaches aim to reveal the relationships among multiple users in a temporal context. For instance, Storyline [22] shows the narrative threads that form a plot or a subplot in works of fiction. The history flow approach successfully reveals author collaboration patterns [24]. Code Swarm [15] visualizes the animated histories of software project evolution. VAET reveals both the temporal patterns of multi-user behavior and their atomic level correlations. It improves the above approaches by allowing the analysts to explore a large number of transactions at different granularities.\n\n## Problem definition 问题定义\n\n> Multi-user transaction data is a special type of user behavior data with a focus on characterizing raw, detailed, and subtle inter-user transactions. An E-transaction time-series dataset contains information about each E-transaction, including information about transaction time, the buyer, and the seller. Each E-transaction records a transaction between a buyer and a seller.\n\n多用户事务数据是一种特殊类型的用户行为数据，重点是描述原始，详细和微妙的用户间交易。电子交易时间序列数据集包含每个电子交易的信息，包括有关交易时间，买方和卖方的信息。 每个电子交易记录买方和卖方之间的交易。\n\n一般来说，一个电子交易包含以下属性：\n\n* `User information` includes the IDs and other information about the buyer and the seller who make the transaction, e.g., their age group, gender, and location.\n\n* `Transaction information` includes the time stamp and other information about the commodities, e.g., the payment amount, the number, and the sales category of the commodity.\n\nThe above attributes can be numerical, ordinal, categorical, textual, or temporal. \n上述属性可以是数字，序数，分类，文本或时间。\n\n分析师通常通过一系列低级别任务进行复杂的任务。 这些任务通常关注卖方的行为，例如：\n\n* 识别感兴趣的时段和/或销售类别。\n* 识别具有特定属性的有趣模式的交易（例如，支付金额≥500）并检查其详细信息。\n* 识别具有有趣交易模式的卖家，例如卖家以小额付款金额进行频繁交易。\n* 检查特定卖家的交易模式\n\nThe analysts usually conduct a complex task through a set of low level tasks. These tasks typically focus on the behavior of the seller, such as:\n\n* T1 Identifying time periods and/or sales categories of interest.\n* T2 Identifying transactions with interesting patterns in specific attributes(e.g., payment amount ≥ 500) and examining their detailed information.\n* T3 Identifying sellers with interesting transaction patterns, such as a seller making frequent transactions with small payment amounts.\n* T4 Examining the transaction patterns of a specific seller\n\n我们使用术语`显着`定量地描述交易与分析师定义的目标的相关程度。根据调查，识别和审查突出交易是电子交易时间序列探索中至关重要但具有挑战性的任务。通常，分析师需要通过迭代查询数据集并检查检索到的事务之间的属性值和关系来手动识别突出事务。此外，分析师经常需要检查突出交易以及用户的历史数据等信息，以证明其行为或揭示有趣的模式。这个过程通常是费力和乏味的。VAET旨在简化此过程，提高整体运行效率。（VAET is designed to ease this process and improve the overall operation efficiency.）\n\n## APPROACH OVERVIEW 方法概览\n\nThe goal of VAET is to identify and explore interesting transactions by selecting those with high saliency and studying them. This is accomplished by integrating the capabilities of both data mining and visualization techniques within the following iterative visual exploration pipeline.\n\nVAET的目标是通过选择具有高度显着性并研究它们来识别和探索有趣的交易。这是通过将数据挖掘和可视化技术的功能集成在以下迭代视觉探索流程中来实现的。\n\n* 步骤1，使用决策树的显着计算：从每个事务中提取一组特征。分析人员将某些交易的功能手动标记为训练数据。使用这些特征，在训练数据上构建概率决策树学习器。然后用它来产生每个未标记交易的显着值（图2（b））。\n\n* 步骤2，使用TOS映射进行浏览和选择：所有事务的显着性值映射到紧凑的基于密度的生存时间（TOS）映射。在此映射中，交易按时间和类别排序，并以颜色对应于显着值的像素表示。分析师可以交互地探索映射，调查全球分布和地域格局，并选择根据这个观点的显着性值，有趣的交易。（图2（c））。\n\n* 步骤3，使用KnotLines进行详细分析：分析师选择的交易通过一种新颖的视觉隐喻`KnotLines`可视化，允许研究多个属性和上下文连接（图2（d））。分析人员确定为突出事务的交易可以被标记并反馈到步骤1以继续迭代过程（图2（e））。\n\n\n* Step 1 Saliency computation with decision tree: A set of features are extracted from each transaction. The analysts manually label the features of some transactions as the training data. Using these features, a probabilistic decision tree learner is constructed upon the training data. It is then employed to produce the saliency values for each unlabeled transaction (Figure 2 (b)).\n* Step 2 Browsing and selection using the TOS map: The saliencyvalues of all transactions are mapped to a compact, density-based Time-Of-Saliency (TOS) map. In this map, transactions are ordered by time and categories and represented by pixels whose colors correspond to saliency values. The analysts can interactively explore the map, investigate the global distribution and local patterns, and select interesting transactions according to the saliency values from this view. (Figure 2 (c)).\n* Step 3 Detailed analysis using KnotLines: The analyst-selected transactions are visualized with a novel visual metaphor, KnotLines, that allows the study of multiple attributes and contextual connections (Figure 2 (d)). The transactions identified as salient by the analysts can be labeled and fed back into Step 1 to continue the iterative process (Figure 2 (e)).\n\n\n分析人员可以通过调整标记的数据集，导航映射和探索有趣的交易来迭代地循环上述步骤。 TOS映射和KnotLines可视化提供可扩展的探索，如时间间隔选择和详细审查。\n\n![图2](VAET-overview.png)\n\n## SALIENCY COMPUTATION WITH DECISION TREE 决策树的显著性计算\n\n计算显着性值本质上是上下文感知和任务定位的。 对于许多任务，显着性值不能直接从事务属性导出。 例如，当分析师搜索异常交易时，往往需要考虑卖方的交易频率。 让分析人员手动指定每个交易的显着性值也是不切实际的。 因此，我们建议通过定义和计算一组交易的特征来计算每个记录的显着性值。特别地，我们的方法通过`概率决策树`计算显着值作为概率估计问题。 我们选择决策树，因为它可以处理连续和分类的属性，很容易解释。 决策树最初由一组分析师确定的训练数据的特征构建。 将决策树应用于每个未标记事务的特征，产生的概率范围为0到1，用作底层事务的显着值。 分析师手动标记为交易的交易可以在随后的分析中添加到训练数据集中（图2（e））。\n\n### Feature Extraction 特征提取\n\nVAET计算一组分析师指定的每个事务的时间和上下文特征作为一组特征。 一般来说，定义了三种类型的特征：\n\n* `基本特征` 确定交易是否有趣的一个直接方法是使用指定属性的值作为基本特征，例如商品的支付金额。另外，分析人员可以定义新的属性。例如，如果卖家在分析师给出的有趣的列表中，则他或她被视为显着的卖家，如图3所示。这些属性的集合构成一组基本功能。\n* `文本功能` 交易可以包含文本信息，例如商品的评论。 VAET检查文本信息是否包含分析师指定列表中的敏感词。分析人员保留一个字典，用于从过去几个月手动收集敏感的词汇和短语。例如，在一种欺诈交易中，买家希望尽快回收现金。 “现金回馈”是一个敏感的短语。敏感词在不同的情况下有所不同，可以视为文字特征。\n* `时间特征` 交易序列的时间模式对于识别数据集中的有趣模式至关重要。例如，卖方在时间间隔内的交易金额表示他或她的受欢迎程度。然而，以传统的决策树方法难以发现面向时间的关系。为了解决这个问题，VAET使用卖方在每个时间间隔的交易频率作为衡量时间趋势。时间间隔的大小取决于数据收集配置。\n\n* `Basic Features` One straightforward way to determine whether a transaction is interesting is to use the values of specified attributes as basic features, such as the payment amount of a commodity. In addition, the analysts can define new attributes. For example, if a seller is in the interesting list given by the analyst, he or she is considered as a salient seller, as shown in *Figure 3*. The collection of these attributes constructs a set of basic features. \n* `Textual Features` A transaction may contain textual information, such as the comment of a commodity. VAET examines whether the textual information contains sensitive words in a analyst-specified list. The analysts keep a dictionary for sensitive words and phrases collected manually from the past several months. For example, in a kind of fraud transactions, the buyers want their cash back as soon as possible. “cash back” is a sensitive phrase here. Sensitive words vary in different situations, and can be regarded as textual features. \n* `Temporal Features` Temporal patterns of a sequence of transactions are essential for identifying interesting patterns in the datasets. For example, the transaction amount of a seller in a time interval indicates his or her popularity. However, time-oriented relations are difficult to discover with conventional decision tree approaches. To address this problem, VAET uses the transaction frequency of the seller in every time interval as a measure of the temporal trend. The size of the time interval depends on the data collection configuration.\n\n![图3](feature-extraction.png)\n\n### Estimating saliency using Probabilistic Decision Tree 使用概率决策树估计显着性\n\n决策树最初使用训练数据集构建，该数据集由分析师标记的交易的提取功能组成。 如图2（e）所示，可以通过添加分析员标识的事务，在可视化探索过程中手动更新训练数据集。 在我们的方法中，使用完善的C4.5算法从训练数据中自动构建决策树，其根据特征将训练集递归地分解为子集。 在决策树中（参见图4的示例），叶子节点表示类（显着或非显着2个类别），内部节点对应于特征。 在每个内部节点处，C4.5根据产生`最高归一化信息增益`（highest normalized information gain）的特征将样本分解为子集，并将特征分配给该节点\n\n![图4](decision-tree.png)\n\n概率根据决策树叶上的交易进行估计。 我们将FP表示为叶上的假阳数，T P表示真阳数（见图5中的混淆矩阵）。 叶上的概率分布估计由下式给出:\n\nP(y|x) = TP / (TP + FP)\n\n![表1](confusion-matrix.png)\n\n## TIME-OF-SALIENCY MAP: BROWSING A LARGE SET OF TRANSACTIONS 显著性时间映射：浏览大量交易集\n\n![图5](TOS-map.png)\n### Generation of Time-Of-Saliency Map 生成显著性时间映射\n\nTOS映射是基于2D密度的展示，沿着水平轴的时间和由销售类别（例如，“电子配件”和“衣服”）组织的垂直轴TOS映射均匀分割成行，每个行代表一个销售类别。在图（a）中，由蓝色框突出显示的颜色矩形提供了垂直轴上类别的视觉索引。此外，每行按照*时间间隔水平分割*。*根据其时间戳和销售类别*每个事务被投射到相应的单元。投射到同一个单元格的所有事务的显着值相加，并将总和映射到单元格的颜色。色彩映射可以使用默认颜色标度或分析器指定的色标。所得到的TOS映射可视化地为分析任务编码事务的相关性。*黑暗区域*意味着一组潜在有趣的交易。特别地，连续的暗带表示在一段时间内相应的销售类别中的高度突出的交易（参见图1（a）中的TOS映射中的所选区域）。\n\n### Time-Of-Saliency Exploration 探索显著性时间映射\n\nTOS映射视图中提供了以下交互，可用于完成第一个任务（即识别感兴趣的时段和/或销售类别。）\n\n* `时间窗口` TOS映射以分析人员`可调节的时间间隔`显示交易。可以使用额外的时间窗口小部件来定位视图的特定区域以进行进一步和详细的研究。分析师可以在`时间选择栏`上单击并拖动以设置TOS映射的时间窗口，如图5（a）中TOS映射顶部的突出显示。图5（b）显示了分析师设置时间窗口后的TOS映射。\n\n* `感兴趣的区域` 分析师可以点击`类别索引`（图5（a）中的蓝框）来选择同一类别的交易。 也可以使用`套索工具`来选择有趣的区域。 当选择一个区域时，将出现一个`浮动文本框`以显示有关该区域的信息。 所选交易的详细信息可以在第7节中描述的KnotLines视图中进一步可视化和探索。此外，还提供了一个`条形图视图`（图1（c））以显示所选数据中的类别的销售量。\n\n\n* `Time Windowing` The TOS map shows the transactions in an analyst-adjustable time interval. An additional time windowing widget can be used to locate a specific region of the view for further and detailed study. Analysts can click and drag on the time selection bar to set the time window of the TOS map, as highlighted over the top of the TOS map in Figure 5 (a). Figure 5 (b) shows the TOS map after the analyst sets the time window. \n\n* `Region-Of-Interest` Selection The analysts can click on the category index (the blue box in Figure 5 (a)) to choose the transactions of the same category. A lasso tool can also be used to select interesting regions. When a region is selected, a floating text box will appear to show the information about the region. The detailed information of selected transactions can be further visualized and explored in the KnotLines view described in Section 7. In addition, a bar chart view (Figure 1 (c)) is provided to show the sales volume of categories in the selected data.\n\n## KNOTLINES: EXAMINING TRANSACTIONS IN DETAIL 详细审查交易\n\nKnotLines允许分析师对从TOS映射中选择的显着交易进行详细分析。它旨在解决任务2到任务4。KnotLines可视化显示两种类型的信息：属性和交易的时间趋势。\n\n### Data Organization and Visual Layout 数据组织和视觉布局\n\n为了研究交易之间的属性相似性和时间相关性，所选择的交易集被组织成一个三级分层树（图6）。 首先，我们使用矩阵表来可视化事务的组织，如图7（a）所示。\n\n\n![图6](hierarchical-tree.png)\n\n* `一级` 整个选定的交易集根据不同的卖家分为N组（1级）。图7（a）中的*每一行代表一个组*。一组包含卖家的所有交易。这些组沿垂直轴从上到下列出。\n* `二级` 一组中的交易根据其时间戳进一步分为子组（2级）。图7（a）中的*水平轴表示时间*。每行分别对应于M个时间间隔的时间轴上的M个正方形。所有间隔的长度相同，可以调整以探索不同粒度的数据。属于相同时间间隔的卖方的交易形成一个子组（2级）。\n* `三级` 根据销售类别（例如，“图书”），将一个子组进一步分为（级别3）。在图7（a）中，每个正方形被分割成K个细胞，每个细胞代表一个部分。同一部分的交易由同一卖方作出，在同一时间间隔内进行，属于同一销售类别。\n\n`PS`：即三级严格递增，一级是属于同一个卖家，二级属于同一个卖家某段时间，三级属于同一个卖家某段时间的某类销售类别。分别按行，按列，按细胞划分。这个是交易集逻辑上关系，而图7是一种为了方便分析而设计表示该关系的可视化方法。\n\n* `Level One` The whole selected transaction set is divided into N groups (level 1) according to different sellers. Each row in Figure 7 (a) represents a group. A group contains all transactions of a seller. The groups are listed from top to bottom along the vertical axis. \n* `Level Two` The transactions in a group are further divided into subgroups (level 2) according to their time stamps. The horizontal axisin Figure 7 (a) represents the time. Each row is split into M squaresalong the time axis which correspond to M time intervals. The lengthsof all intervals are the same and can be adjusted to explore the data at different granularities. Transactions of a seller which fall into the same time interval form a sub-group (level 2).\n* `Level Three` A subgroup is further divided into sections (level 3)according to the sales categories (e.g., “Books”). In Figure 7 (a), each square is segmented into K cells, each of which represents a section. Transactions in the same section are made by the same seller, take place in the same time interval, and belong to the same sales category.\n\n![图7](visual-organization.png)\n\n\n因为大部分卖家的交易量在一天的时间内可能很高，因此图7（a）所示矩阵中的交易密度可能非常稀疏。 另外，组N的数量可能很大（例如，100万）。 为了使探索更加有效，矩阵式布局应重新设计为更紧凑。\n\nVAET采用一个简单的两步启发式方案，对每个组进行操作。 \n\n1. 在第一步中，删除第一个非空子组之前和最后一个非空子组之后的空子组。 这个步骤导致许多组仅覆盖水平空间的一小部分，因为它们中的大多数具有短的时间跨度。\n\n1. 为了增加空间效率，在第二步中启发式优化组的布局。 迭代布局策略用于满足以下原则： \n    * 整洁：组不应重叠;\n    * 紧凑型：空间利用率高;\n    * 代表：重要群体应优先展示\n\nVAET employs a simple two-step heuristic scheme that operates on each group. In the first step, empty sub-groups before the first nonempty sub-group and after the last non-empty sub-group are removed. This step results in many groups that only cover a small portion of the horizontal space, because most of them have a short time span. To increase the space efficiency, the placement of the groups is heuristically optimized in the second step. An iterative layout strategy is used to satisfy the following principles:\n\n* Uncluttered: groups should not overlap;\n* Compact: space utilization should be high;\n* Representative: important groups should have a display priority\n\n分析人士指出， *这种设计（即图7）* 有几个主要缺点：\n\n* 由于部分可能包含数百个交易，可视化严重凌乱。 分析师建议在同一部分内汇总交易;\n* 分析师认为，紧凑的布局是空间效率高的必需品。 然而，他们很难从这个视图来识别同一卖家所做的交易。需要额外的视觉属性来强调这一重要关系;\n* 在此视图中没有提供有关交易的重要信息，如付款金额，交易是否缺少值，以及是否经常发生相同的交易。\n\nThe analysts pointed out that there were several major drawbacks in this design: (1) The visualization was seriously cluttered since a section may contain hundreds of transactions. The analysts suggested aggregating transactions within the same section; (2) The analysts agreed that the compact layout was necessary for high space efficiency. However, it was difficult for them to identify transactions made by the same seller from this view. Additional visual attributes were desired to emphasize this important relationship; (3) Important information about the transactions such as payment amount, whether a transaction had missing values, and if identical transactions occurred frequently, was not presented in this view.\n\n### KnotLines （结线）\n\n为了解决上述问题，我们设计了一个增强的视觉隐喻调用KnotLines。它受到音乐符号的启发，这可以被看作是一个改进的散点图，它沿着时间轴放置不同类型的点（音符）。它是时间序列（例如节拍和节奏）及其连接的复杂视觉表示。\n\n这里就不详细说明了，具体见表2。\n\n![图8](Knotlines.png)\n\n表2 是Knotlines的可视化各个部分的含义\n| 图形部分 | 含义|\n|----|----|\n| 视觉编码 | 交易数据|\n| 一个knotline | 同一卖家在不同时间的交易（一组）|\n| 一个knotbunch | 同一卖家在一段时间间隔内进行交易（一个子组）|\n| 茎长 | 在一段时间内同一卖家的交易总支付金额|\n| 一个结 | 在一段时间内，同一卖家与同名销售类别的交易（一节）|\n| 结的颜色 | 该结点的销售类别|\n| 结的大小 | 该结点的商品数量|\n| 一个未填充的结点 | 与卖方或买方位置异常的交易|\n\n![表2](Visual-Encoding.png)\n\n### Visual Exploration 可视化探索\n\n除了布局模式的规范和详细结点的调查之外，KnotLines还提供了一套用于分析多个结线的交互。\n\n* `显着调制` KnotLines视图中显示的每个事务都包含一个显着值。 分析师可以显示从2D TOS映射中选择的所有交易，或仅显示显着值大于给定阈值（例如，0.8）的所选交易。 当视图中显示许多节线时，此过滤操作非常有用，因此它支持T2和T3。 图9显示了显着性调制的影响。\n* `查看导航` KnotLines视图可以水平放大，以清楚说明，这对T2和T3有帮助。 时间间隔的长度将相应调整。 分析师可以垂直或水平滚动查看更多的knotlines。\n* `兴趣选择结` 我们可以通过单击或使用套索工具拖动来选择一组结。 指定结时，会以黄色的圆圈突出显示。 由同一买家制造的相关结也用灰色的圆环突出显示分析师的注意力（图1（b））。 将出现一个浮动文本框，显示所选结的详细信息，如卖方的位置，支付金额和销售类别。 分析员可以在详细视图（图1（e））中的所选结（部分）中检查交易的信息（例如，买方和卖方的位置，子类别和商品编号），其中 是为T2设计的。 对T4有帮助的统计视图（图1（f））用于提供所选结的统计信息，如交易频率和卖方支付金额的趋势。\n* `标签` 当特定交易被分析师识别为突出显示时，可以将其添加到标记数据中进行迭代视觉分析和探索。\n\n\n* `Saliency Modulation` Each transaction shown in the KnotLines view contains a saliency value. The analysts can show either all transactions selected from the 2D TOS map or only the selected transactions whose saliency values are larger than a given threshold (e.g., 0.8).This filtering operation is useful when there are many knotlines shown in the view, so it supports T2 and T3. Figure 9 demonstrates the effect of saliency modulation.\n\n* `View navigation` The KnotLines view can be zoomed horizontally for clear illustration, a function helpful for T2 and T3. The lengths of the time intervals will be adjusted accordingly. Analysts can scroll vertically or horizontally to see more knotlines.\n\n* `Knots of Interest Selection` We can select a set of knots by clicking, or dragging using a lasso tool. When a knot is specified, it is highlighted with a yellow ring. Related knots which are made by the same buyer are also highlighted with grey rings to draw the analysts’ attention (Figure 1 (b)). A floating text box will appear displaying the detailed information of the selected knot such as the location of the seller, the payment amount, and the sales category. Analysts can check the information of the transactions (e.g., the location of the buyer and the seller, the sub-category, and the commodity number) in the selected knot (section) in the detail view (Figure 1 (e)), which is designed for T2. A statistic view (Figure 1 (f)), which is helpful for T4, is used to present statistical information for the selected knot, such as the trend of the transaction frequency and the payment amount of the seller.\n\n* `Labeling` When a specific transaction is identified as salient by analysts,it can be added to the labeled data for iterative visual analysis and exploration.\n\n![图1](VAET-system.png)\n\n## CASE STUDY 案例研究\n\n`PS`: 这部分应该是论文作者讲述一次真实分析过程，里面有分析的思路与流程，还有该系统的使用特点。\n\n来自我们的客户 - 客户（C2C）零售业务的数据部门的分析师参与了这项研究。 该公司提供了一个数据集，其中包含2600万个在线电子交易，从中他们想要检测假交易。 约有930万卖家和买家参与了数据集。 他有兴趣通过与合作伙伴买家建立假交易来识别卖家何时积累信用。 异常交易行为的一些指标可能是异常大量的商品，支付金额的大幅变化，特定卖方和买方之间的频繁交易，以及价值超出其正常范围的属性。\n\n### Construction of Decision Tree 决策树构建\n\n计算每个时间间隔内的卖方的交易频率并将其用作`时间特征`。 根据由分析者提供并用作文本特征的敏感字典，提取了评论中的`关键词`和`短语`（例如“信用”）。我们标注了大约300笔交易，这些交易是使用分层抽样从每个类别中选出的。 我们用标记的数据训练了决策树。 将要分析的交易的提取特征描述作为决策树的`输入`，并为每个输入产生显着性值。\n\n我们使用`精确率`p和`召回率`r来评估决策树的效率：p = TP /（TP + FP）= 0.89，r = TP /（T P + FN）= 0.92，其中TP，TN，FP和FN 从训练数据的预测结果中计数（见表1）。\n`PS:` 这几个概念一般用于评估机器学习算法的性能等指标，也是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。 决策树算法在这里的作用只是用来找到显著性值。\n\n### Abnormal Frequency and Locations of Transactions 异常频率和交易地点\n\n分析师在简短的培训课程之后开始在TOS映射中进行勘探。他注意到一个具有`高度显着性的长长的地区`（图10）。随后，分析师指定了时间窗口，并放大到所需的区域。为了进一步研究交易行为，分析师选择了这个地区，发现许多交易在9月19日上午10点被分类为“图书”。分析师注意到连续的红色结在图1（b）的连线上连接。他告诉我们，*这种模式表明卖家在选定的时间间隔内频繁交易*。经查核详细资料后，分析师发现这些交易属于“充值卡”类别，并由*不同的买家*组成。他评论说，这可能是一个促销活动，因为他在这些交易中没有发现异常信息。分析师将显着阈值增加到0.8，`显着调制滑块`（Saliency Modulation）。*这使得分析师能够有效地过滤出许多不太显着的交易*。分析师立即找到多个未填充的结，指示具有缺失值的交易。他评论说，使用未填充的结来呈现缺失值的交易有效地吸引了他的注意。为了进一步调查这些记录是否表示促销或假交易，分析师进行了进一步分析。*当他点击这条结线中的一个未填充的结时，同一个结线中的许多其他结被突出显示*（图1（b）），表明这些结的大部分交易是由同一买方和卖方进行的。分析师注意到，详细信息视图中，买方的交货地址为空，通过查看此结线中的结的详细信息（图1（e））。他评论说这是可疑的，因为如果买方不填写他的地址，买家就不会买到这个商品。通过查看结的交易历史（图1（f）），分析师发现，卖方的销售额在一段时间内急剧增加。\n\n分析师认为这些交易可能与赚取`信用`有关。 该结论由数据提供商的商业智能部门的分析师进行了验证，他们检查了与交易相关的其他信息，如卖方和买方的IP地址。 他们解释说，这些交易是由一组帮助卖家增加`信用`的买家进行的，卖家没有真正交付产品。 分析师将这一结线中的交易标示为`显着`，并将它们添加到训练数据集中。\n\n![图10](salient-transactions.png)\n\n![图1](VAET-system.png)\n\n### Abnormal Attribute Values of Transactions 交易的异常属性值\n\n分析师在TOS映射中选择了另一个时间窗口。通过查看`条形图`视图中的销售类别信息（图11（a）），分析师发现，“电子配件”类别中销售的商品总数远远大于其他销售类别。*分析师认为，由于商品数量庞大，这将是促销活动*。他在`knotline`视图中调查了这个假设，但没有发现任何包含频繁连续的“电子配件”结。\n\n分析师在TOS映射中选择了此类别，以过滤掉不相关的类别。通过仔细检查剩余的结，分析师发现一个具有短茎的极大的结（图11（b）），表明一个较大的商品数量，总支付金额却较低。分析师告诉我们，“*通过这种knotline，我第一眼就注意到支付和商品数量之间的异常关系*”。结的详细视图（图11（c））显示，本节包含单笔交易，支付金额仅为10美分，商品却为22万件。通过进一步调查卖方的交易历史（图11（d）），分析师消除了销售促销的概率，因为卖方在一段时间内交易次数很少，表明销售商品很少。分析师认为这是一个事件，卖方试图根据已经出售的商品数量增加他们的互联网搜索排名。*分析师还将该交易标注为显着，并将其添加到训练数据集*。\n\n![图11](fig11.png)\n\n## USER STUDY 用户研究\n\n我们进行了用户研究，*以评估VAET支持低级别分析任务的能力*，即第3节中讨论的T1-T4。所使用的数据集是第8节（即上一节）中探讨的交易数据集。\n\n### Design 设计\n\n10名参与者（6名男性和4名女性）年龄介于21岁至35岁之间进行了用户研究。 其中两人是分析师，其他人则是研究生。 所有参与者都具有使用在线商务的经验，并且对电脑熟悉。 学生的专业包括计算机科学，设计，数学和生物学。 以前他们都没有使用过VAET。\n\n参与者一个接一个地参加研究。 对于每个参与者，在测试部分之前进行了短暂的训练。 在培训部分，教练首先向参与者介绍了VAET的25分钟演示。 在演示过程中，教练解释了VAET的视觉设计和功能。 在演示之后，参与者在教练的帮助下练习了VAET提供的互动5分钟。 在测试部分，参与者被要求完成9次练习，与实际分析中遇到的练习类似，无需教练帮助。 然后，他们被要求通过回答问卷并提供主观反馈来评估系统。\n\n这9个练习是针对三种不同的具体情况而设计的，其中两项是在第8节中描述的。每个低级任务都通过一项或多项练习进行评估。 他们评估的练习和任务如下（任务显示在括号中）：\n\n* E1 “使用TOS映射，从9月21日上午9点至10点选择具有最高显着性的销售类别。”目标：确定TOS映射（T1）中感兴趣的时间段和销售类别。\n\nE2和E3来自第8.3节所述的情况。\n\n* E2 “选择商品数量最大的销售类别”。目标：解释条形图并确定感兴趣的销售类别（T1）。\n\n* E3 “查找KnotLines中商品数量最多的交易。”目标：解释一个结的视觉编码，并识别具有特定属性（T2）的有趣模式的交易。\n\n要完成E4-E6，参加者将被要求在9月19日晚上18点至19点之间设置时间，并选择“充值卡”。\n\n* E4 “从KnotLines视图中找到具有最高交易频率的卖家（knotline）”。目标：解释knotline的视觉编码，并识别有趣的交易模式（T3）的卖家。\n\n* E5 “在KnotLines视图中，哪些卖方的交易模式不会发生？ （a）大量商品的单笔交易，但支付金额很小。 （b）低频连续交易。 （c）持续交易频率高，支付金额小。 （d）我不知道。“目标：解释这个knotlines和识别有趣的卖家交易模式（T3）。\n\n* E6 “E4中卖方交易历史的一个特征是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：以统计视角检查卖方的行为（T4）。\n\nE7 - E9与8.2节描述的情况相同。 \n\n* E7 “在KnotLines视图中查找未填充的结，并报告买方城市。”目标：使用详细信息视图（T2）检查事务的属性值。\n\n* E8 “E7中确定的卖方交易历史的主要特点是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：使用统计视图检查卖方的行为（T4）。\n\n* E9 “E7中确定的卖方的交易行为是什么？ （a）具有大量商品编号的单一交易。 （b）付款金额低的频繁交易。 （c）与异常购买城市频繁交易。“目标：解释和检查KnotLines（T4）的卖方交易模式。\n\nE1 “Choose the sales category with the highest saliency value from 9 am to 10 am on September 21 using the TOS map.” Objective: Identify time periods and sales categories of interest in the TOS map (T1).\n\nE2 and E3 were from the case described in Section 8.3.\n\nE2 “Choose the sales category with the largest commodity number.” Objective: Interpret the bar chart and identify sales categories of interest (T1).\n\nE3 “Find the transaction with the largest number of commodities in KnotLines.” Objective: Interpret the visual encoding of a knot and identify transactions with interesting patterns in specific attributes (T2).\n\nTo finish E4 - E6, participants were asked to set the time between 18 pm and 19 pm on September 19, and choose “Top-up Card”.\n\nE4 “Find the seller (knotline) with the highest transaction frequency from the KnotLines view.” Objective: Interpret the visual encoding of a knotline and identify sellers with interesting transaction patterns (T3).\n\nE5 “In the KnotLines view, which transaction pattern of the seller does not occur? (a) Single transaction with a large number of commodities but a small payment amount. (b) Continuous transactions with low frequency. (c) Continuous transactions with high frequency and a small payment amount. (d) I don’t know.” Objective: Interpret the knotlines and identify interesting seller transaction patterns (T3). \n\nE6 “Which is a feature of the seller transaction history of the knot in E4? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden, frequent transactions.” Objective: Examine the seller’s behavior in the statistic view (T4). \n\nE7 - E9 were the same case described in Section 8.2.\n\nE7 “Find unfilled knots in the KnotLines view and report the buyer cities of them.” Objective: Examine the attribute values of the transactions using the detailed information view (T2). \n\nE8 “What is the main feature of the seller’s transaction history of the knot identified in E7? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden ,frequent transactions.” Objective: Examine the seller’s behavior using the statistic view (T4).\n\nE9 “What is the transaction behavior of the seller identified in E7? (a) A single transaction with a large commodity number. (b) Frequent transactions with low payment amounts. (c) Frequent transactions with abnormal buyer cities.” Objective: Interpret and examine the seller’s transaction patterns from KnotLines (T4).\n\n练习结束后，参加者完成了由6个问题组成的调查问卷（Q1〜Q6）。 要求用1到5评估等级（1=非常简单或高效，5=非常困难或低效），*学习该VAET系统的难度和VAET的效率*。 这些问题也收集到主观反馈。 六个问题如下：\n\n1. 容易或难以学习TOS映射？\n2. 使用TOS映射探索显着数据是否有效？\n3. 单个结的`视觉编码`是否容易或难以解释？\n4. KnotLines的视觉编码和布局是否容易或难以解释？\n5. 使用KnotLines分析用户交易模式是否有效？\n6. 使用VAET整体分析多用户行为是否容易或困难？\n\n----\n\n1. Is it easy or hard to learn the TOS map?\n2. Is it efficient or not to explore salient data with the TOS map?\n3. Is it easy or hard to interpret the visual encoding of a single knot?\n4. Is it easy or hard to interpret the visual encoding and layout of KnotLines?\n5. Is it efficient or not to analyze the user transaction patterns with KnotLines?\n6. Is it easy or hard to analyze multi-user behavior with VAET as a whole?\n\n### Results 结果\n\n收集9次练习的准确性和时间进行评估\n\n总体来说，参加者完成了练习，在90次全部练习中产生5次错误（精准度为94.4％）。分析师正确回答了所有问题。对于学生参与者，其中两人在E5上出错，E8上有两个错，E9上有一个错。\n\n我们采访了E5的错误参与者。他们都说他们“只注意到knotlines的主要模式，忽略了发生较少的模式”。但是，他们没有解释用户行为的问题。回答E8的参与者错误地提到他们忘记检查统计视图中显示的卖家历史信息（图1（f）），而是根据KnotLines视图回答问题。在E9错误的参与者认为，零买家城市（null buyer cities）对于不需要交货地址的电子书等虚拟商品的交易是正常的。事实上，“图书”类别中的所有商品都是实物。虽然一些参与者有T3和T4的问题，但总体准确性表明VAET可以很好地支持任务。\n\nOverall, the participants completed the exercises, yielding 5 mistakes out of the 90 total exercises (94.4% accuracy). The analysts answered all questions correctly. As for the student participants, two of them erred on E5, two erred on E8 and one erred on E9. \n\nWe interviewed the participants who erred on E5. They both said that they “only noticed the main patterns of the knotlines and ignored the patterns with fewer occurrence”. However, they had no problem interpreting the user behavior from them. The participants who answered E8 incorrectly mentioned that they forgot to check the seller history information shown in the statistic view (Figure 1(f)) and answered the question based on the KnotLines view instead. The participant who erred on E9 thought that null buyer cities are normal for transactions of virtual commodities such as E-books, which do not need delivery addresses. In fact, all commodities in the “Books” category are real items. Although some participants had problems with T3 and T4, the overall accuracy indicates that VAET supports the tasks well.\n\n图12显示了每次锻炼的完成时间的平均值和标准偏差。 E3，E4和E7的时间比其他问题的时间长。 这三个练习要求参与者搜索具有特定特征的knotlines，这可能需要更多的时间仔细检查视图。 参与者能够快速完成其他6个问题。 完成时间为5.14s至44.22s。 分析师花费的时间远远少于学生参与者。 总体而言，VAET允许大多数参与者在90秒内完成复杂的练习和任务（如E4和T3）。 在考虑交易的各种属性以及它们之间的关系时，这是相当快的。\n\n![图12](fig12.png)\n\n\n分析师的反馈与讨论\n\n在用户研究结束时，我们采访了分析师和其他参与者。 两位分析师都对分类结果感到满意。 他们评论说，在分析不同类型的交易时，特征提取和决策树的集成是高效和灵活的。 我们要求他们将决策树与之前使用的逻辑回归进行比较。 他们认为我们的模型有几个优点：\n\n* 决策树对于分析师来说很简单易懂。\n* 在处理属性的缺失值时，决策树比逻辑回归更强大。\n* 使用决策树的分类比逻辑回归更快。 \n\n他认为我们可以通过使用更多的信息来改进我们的方法，比如今后买家和卖家的IP地址。\n\n他们评论说，TOS映射是直观的，勘探方便。一位分析师表示：“KnotLines的多用户行为的可视化是创造性和生动的。”*虽然一位分析师认为该系统很难学习，但很少参与者难以解释可视化*，大多数人能够在简短的培训会议后找到有趣的交易。两位分析师都提到，VAET能够帮助他们探索未被发现的交易模式。这是至关重要的，因为“欺骗人总是不断改变伎俩”。他们认为，VAET有能力找到新兴的交易模式，并帮助他们改进数据模型。分析师们渴望将VAET用于实际的多用户应用程序，在这些应用程序中，他们发现许多高维度事务之间的上下文和时间相关性。有趣的是，一些参与者最初认为使用我们的系统需要基本的音乐知识。其他与会者提到，他们对音乐笔记的了解影响了对设计的理解。例如，茎长度固定在音符中，但在我们的设计中是可变的。此外，有些人认为与其他knotbunches（类似于四分之一音符）没有连接的单个knotbunch持续比连接的knotbunch短（类似于第八个音符）。事实是，交易没有持续时间，因为它们都是立即在线发生的。与会者告诉我们，在他们学会如何解读设计之后，这种差异并没有妨碍他们的分析。\n\n## CONCLUSION 总结\n\n本文提出了一种用于识别基本交易数据和研究*大片碎片记录*的`时间`或`集体行为`的新型视觉探索方案。 在对KnotLines进行选择交易的详细探索和推理之前，执行决策树算法和TOS映射的过滤过程，以从大量记录中选择潜在有趣的交易。 案例研究和用户研究证实，VAET可以有效地支持大部分任务。 根据结果，一些任务如T3需要更好地解决，因为交易模式可以是`动态的`和`多层次的`。 为了使VAET更容易学习和使用，我们希望使TOS映射和KnotLines的设计更加直观。 对于未来的工作，我们也希望对更多的数据集进行扩展。\n\nThis paper presents a novel visual exploration scheme for identifying elementary transaction data and studying the temporal or collective behavior from large pieces of fragmented records. Prior to detailed exploration and reasoning of the chosen transactions with KnotLines, a decision tree algorithm and a filtering process by TOS map are performed to choose potentially interesting transactions from a huge amount of records. The case study and the user study verify that VAET can effectively support most of the tasks. According to the result, some tasks such as T3 need to be better addressed as the patterns of transactions can be dynamic and multi-level. To make VAET easier to learn and use, we would like to make the design of TOS map and KnotLines more intuitive. For future work, we also would like to extend our approach for more datasets.","source":"_posts/VAET阅读稿.md","raw":"---\ntitle: VAET阅读稿\ndate: 2017-10-11 18:53:34\ntags: [数据可视化, 论文阅读]\ncategory: study\n---\n\n# VAET: A Visual Analytics Approach for E-transactions Time-Series  电子交易时间序列的一种可视化分析方法\n\n> Cong Xie, Wei Chen, Member, IEEE, Xinxin Huang, Yueqi Hu, Scott Barlowe, and Jing Yang\n\n创新实践的论文阅读作业，翻译了主要内容，加上部分自己的理解并修改部分内容，保留了部分原文，有时候阅读原文更好理解。全文按照论文组织的方式编写，主要是为了理清楚论文的主要思想，并可以简单地给其他人做宏观上的解释，达到基本的教学目的。此文将作为ppt的前稿。\n\n---\n\n<!-- more -->\n\n![图1](VAET-system.png)\n\n## INTRODUCTION 介绍\n\nThe E-transaction time-series contains transactions among multiple users in a time range. Each record contains a time stamp, the IDs of the seller and buyer, and the associated attributes of the commodities. Each record is an atomic element representing an online transaction among a seller and a buyer.\n\n电子交易时间序列包含时间范围内的多个用户之间的交易。 每个记录都包含时间戳，卖方和买方的ID以及相关联的商品的属性。每个卖方和买方之间的网上交易记录都是一个原子元素。\n\n*在时间上下文中分析电子交易时间序列至关重要了解交易行为，学习用户偏好和发现时间趋势。*\n\n通过面试分析师发现以下一些问题常常很难回答：\n\n* 卖方的多个交易之间的时间和`上下文`关系是什么？比如短时间内有个卖家有大量的交易，而且可能来自某个买家，分析师需要发现这样的交易的各种属性。\n* 最常见的交易模式是什么？比如平时工作日交易比较稀疏，但是圣诞节交易比较频繁。\n* 如何识别`有趣`的交易？比如买家勾结来加速影响卖家的信用，一旦这样的模式定义好了，分析师需要在相关的大量数据集中找到特定属性值来挖掘这样的交易。\n* 如何在上下文检测某个交易？比如小额购买巨量的商品可能是个假的交易，利用它来提升卖家排名。为了确认交易是假的，分析师需要将交易与买方和卖方的信息关联。\n\n我们认为，自动数据挖掘过程在回答上述问题时并没有足够的灵活性和准确性。\n因此迫切需要视觉分析方法，使分析人员能够通过集成计算能力，人类知觉能力和领域知识，通过即时视觉反馈灵活地形成和测试假设。\n\n目前还没有适用于上述情况的可视化方法。\n多变量时间序列可视化的现有研究工作主要集中在总结多维度的全局和/或时间趋势或发现个体维度的模式，如Sparklines。\n\n因此提出了一种新颖的视觉分析系统，称为电子交易时间序列的视觉分析（VAET），旨在探索电子交易时间序列，以便在时间上下文中分析多个用户之间的交易模式。\nVAET有如下2个主要的可视化分析组件：\n\n* Overview: This component helps the analysts effectively identify salient transactions from a large dataset. 该组件帮助分析师在大量数据集中快速找到突出的交易。VAET使用概率决策树学习器首先计算每个交易的显着性值，以揭示其与分析目标的相关性（例如，作为假交易的可能性）。然后，显着值显示在一个称为`显着时间映射`（TOS）的像素方向的显示中。该映射提供了一个工作空间来探索和选择不同时间粒度的潜在有趣的交易;\n* Detail view：This component allows the analysts to conduct detailed examination on interesting transactions for insights. 该组件允许分析人员对感兴趣的交易进行仔细检查，以获取见解。特别地，从概述中选择的交易使用称为`KnotLines`的新的视觉隐喻来显示。协调TOS映射和KnotLines，以便分析人员可以快速识别来自大型数据集的有趣事务。\n\nA case study and a user study with a real online transaction dataset demonstrated that VAET was effective in supporting a variety of analysis tasks.\n真实在线交易数据集的案例研究和用户研究表明，VAET有效支持各种分析任务。\n\nVAET的主要贡献包括：\n\n* 视觉分析系统，允许分析人员在时间上有效地分析大型电子交易时间序列;\n* 从大型数据集中检测和可视化突出事务的方法;\n* 一种新颖的视觉隐喻，用于紧凑地放置和编码特征属性以及多用户事务的时间和上下文相关性\n\n## RELATED WORK 相关工作\n\n### Visual Analysis of E-transaction Data 电子交易数据的可视化分析\n\n以下是之前一些人做的过相关研究（寻找合适的可视化方法来展示交易数据）\n\nThe transaction data contains various types of attributes, such as numerical, temporal and categorical. The Sparklines [23] can be used to visualize multiple trends in financial data. Liu et al. [11] proposed a visualization system called SellTrend for analyzing airline travel purchase requests. WireVis [3] was proposed to search on predefined patterns in large wire transaction datasets. Visual analytics approaches have been proposed to explore web clickstreams of online transactions [26]. Our approach is among the earliest visual analytics approaches for the exploration of temporal and contextual connections in multiuser transactions.\n\nTransaction data often have multi-dimensional attributes. Analyzing them often requires the integration of well-designed data mining models. *Probabilistic models are employed to model user behavior [12], resulting in user clusters. This scheme has been successfully applied to classify E-transaction data into different types [2].* Association analysis is another widely used model for transaction data. Hao et al. [7] proposed the DAV system to visualize the relationships of associated products.\n\n### Visual Analysis of User Behavior Time-Series 用户行为时间序列的可视化分析\n\n以前有很多关于用户行为时间序列分析和可视化的作品。这里我们只总结最相关的一些，并将它们分类为分析个人行为，用户交互和组行为的技术。\n\n`Temporal Individual Behavior Patterns` Many visualization approaches designed to analyze user behavior data are focused on exploring the temporal behavior patterns of individuals.\n旨在分析用户行为数据的许多可视化方法都集中在探索个人的时间行为模式。\nTimeSearcher [8] allows users to select interesting time-series using a rectangular query region. LifeLines [16] visualizes health-related incidents of patients along a timeline. Most previous works utilize high-dimensional visual exploration tools such as parallel coordinates [4] to explore extracted patterns. Density-based display techniques [6], [10] are capable of showing large time-series datasets for real-time monitoring. Additional visual exploration techniques include time trajectory [21] and [13].\n\n`User Interaction Patterns` conventional solutions consider the user network as a social network and analyze its global structure\n常规解决方案将用户网络视为社会网络，并分析其全局结构。\nSallaberry et al. [20] provide an overview of dynamic network evolution over time. Other approaches emphasize the user interaction characteristics such as email connections [25] and instant messages [27]. However, these methods are focused on the structural changes rather than the temporal variations of the interactions. Other approaches aim to reveal the relationships among multiple users in a temporal context. For instance, Storyline [22] shows the narrative threads that form a plot or a subplot in works of fiction. The history flow approach successfully reveals author collaboration patterns [24]. Code Swarm [15] visualizes the animated histories of software project evolution. VAET reveals both the temporal patterns of multi-user behavior and their atomic level correlations. It improves the above approaches by allowing the analysts to explore a large number of transactions at different granularities.\n\n## Problem definition 问题定义\n\n> Multi-user transaction data is a special type of user behavior data with a focus on characterizing raw, detailed, and subtle inter-user transactions. An E-transaction time-series dataset contains information about each E-transaction, including information about transaction time, the buyer, and the seller. Each E-transaction records a transaction between a buyer and a seller.\n\n多用户事务数据是一种特殊类型的用户行为数据，重点是描述原始，详细和微妙的用户间交易。电子交易时间序列数据集包含每个电子交易的信息，包括有关交易时间，买方和卖方的信息。 每个电子交易记录买方和卖方之间的交易。\n\n一般来说，一个电子交易包含以下属性：\n\n* `User information` includes the IDs and other information about the buyer and the seller who make the transaction, e.g., their age group, gender, and location.\n\n* `Transaction information` includes the time stamp and other information about the commodities, e.g., the payment amount, the number, and the sales category of the commodity.\n\nThe above attributes can be numerical, ordinal, categorical, textual, or temporal. \n上述属性可以是数字，序数，分类，文本或时间。\n\n分析师通常通过一系列低级别任务进行复杂的任务。 这些任务通常关注卖方的行为，例如：\n\n* 识别感兴趣的时段和/或销售类别。\n* 识别具有特定属性的有趣模式的交易（例如，支付金额≥500）并检查其详细信息。\n* 识别具有有趣交易模式的卖家，例如卖家以小额付款金额进行频繁交易。\n* 检查特定卖家的交易模式\n\nThe analysts usually conduct a complex task through a set of low level tasks. These tasks typically focus on the behavior of the seller, such as:\n\n* T1 Identifying time periods and/or sales categories of interest.\n* T2 Identifying transactions with interesting patterns in specific attributes(e.g., payment amount ≥ 500) and examining their detailed information.\n* T3 Identifying sellers with interesting transaction patterns, such as a seller making frequent transactions with small payment amounts.\n* T4 Examining the transaction patterns of a specific seller\n\n我们使用术语`显着`定量地描述交易与分析师定义的目标的相关程度。根据调查，识别和审查突出交易是电子交易时间序列探索中至关重要但具有挑战性的任务。通常，分析师需要通过迭代查询数据集并检查检索到的事务之间的属性值和关系来手动识别突出事务。此外，分析师经常需要检查突出交易以及用户的历史数据等信息，以证明其行为或揭示有趣的模式。这个过程通常是费力和乏味的。VAET旨在简化此过程，提高整体运行效率。（VAET is designed to ease this process and improve the overall operation efficiency.）\n\n## APPROACH OVERVIEW 方法概览\n\nThe goal of VAET is to identify and explore interesting transactions by selecting those with high saliency and studying them. This is accomplished by integrating the capabilities of both data mining and visualization techniques within the following iterative visual exploration pipeline.\n\nVAET的目标是通过选择具有高度显着性并研究它们来识别和探索有趣的交易。这是通过将数据挖掘和可视化技术的功能集成在以下迭代视觉探索流程中来实现的。\n\n* 步骤1，使用决策树的显着计算：从每个事务中提取一组特征。分析人员将某些交易的功能手动标记为训练数据。使用这些特征，在训练数据上构建概率决策树学习器。然后用它来产生每个未标记交易的显着值（图2（b））。\n\n* 步骤2，使用TOS映射进行浏览和选择：所有事务的显着性值映射到紧凑的基于密度的生存时间（TOS）映射。在此映射中，交易按时间和类别排序，并以颜色对应于显着值的像素表示。分析师可以交互地探索映射，调查全球分布和地域格局，并选择根据这个观点的显着性值，有趣的交易。（图2（c））。\n\n* 步骤3，使用KnotLines进行详细分析：分析师选择的交易通过一种新颖的视觉隐喻`KnotLines`可视化，允许研究多个属性和上下文连接（图2（d））。分析人员确定为突出事务的交易可以被标记并反馈到步骤1以继续迭代过程（图2（e））。\n\n\n* Step 1 Saliency computation with decision tree: A set of features are extracted from each transaction. The analysts manually label the features of some transactions as the training data. Using these features, a probabilistic decision tree learner is constructed upon the training data. It is then employed to produce the saliency values for each unlabeled transaction (Figure 2 (b)).\n* Step 2 Browsing and selection using the TOS map: The saliencyvalues of all transactions are mapped to a compact, density-based Time-Of-Saliency (TOS) map. In this map, transactions are ordered by time and categories and represented by pixels whose colors correspond to saliency values. The analysts can interactively explore the map, investigate the global distribution and local patterns, and select interesting transactions according to the saliency values from this view. (Figure 2 (c)).\n* Step 3 Detailed analysis using KnotLines: The analyst-selected transactions are visualized with a novel visual metaphor, KnotLines, that allows the study of multiple attributes and contextual connections (Figure 2 (d)). The transactions identified as salient by the analysts can be labeled and fed back into Step 1 to continue the iterative process (Figure 2 (e)).\n\n\n分析人员可以通过调整标记的数据集，导航映射和探索有趣的交易来迭代地循环上述步骤。 TOS映射和KnotLines可视化提供可扩展的探索，如时间间隔选择和详细审查。\n\n![图2](VAET-overview.png)\n\n## SALIENCY COMPUTATION WITH DECISION TREE 决策树的显著性计算\n\n计算显着性值本质上是上下文感知和任务定位的。 对于许多任务，显着性值不能直接从事务属性导出。 例如，当分析师搜索异常交易时，往往需要考虑卖方的交易频率。 让分析人员手动指定每个交易的显着性值也是不切实际的。 因此，我们建议通过定义和计算一组交易的特征来计算每个记录的显着性值。特别地，我们的方法通过`概率决策树`计算显着值作为概率估计问题。 我们选择决策树，因为它可以处理连续和分类的属性，很容易解释。 决策树最初由一组分析师确定的训练数据的特征构建。 将决策树应用于每个未标记事务的特征，产生的概率范围为0到1，用作底层事务的显着值。 分析师手动标记为交易的交易可以在随后的分析中添加到训练数据集中（图2（e））。\n\n### Feature Extraction 特征提取\n\nVAET计算一组分析师指定的每个事务的时间和上下文特征作为一组特征。 一般来说，定义了三种类型的特征：\n\n* `基本特征` 确定交易是否有趣的一个直接方法是使用指定属性的值作为基本特征，例如商品的支付金额。另外，分析人员可以定义新的属性。例如，如果卖家在分析师给出的有趣的列表中，则他或她被视为显着的卖家，如图3所示。这些属性的集合构成一组基本功能。\n* `文本功能` 交易可以包含文本信息，例如商品的评论。 VAET检查文本信息是否包含分析师指定列表中的敏感词。分析人员保留一个字典，用于从过去几个月手动收集敏感的词汇和短语。例如，在一种欺诈交易中，买家希望尽快回收现金。 “现金回馈”是一个敏感的短语。敏感词在不同的情况下有所不同，可以视为文字特征。\n* `时间特征` 交易序列的时间模式对于识别数据集中的有趣模式至关重要。例如，卖方在时间间隔内的交易金额表示他或她的受欢迎程度。然而，以传统的决策树方法难以发现面向时间的关系。为了解决这个问题，VAET使用卖方在每个时间间隔的交易频率作为衡量时间趋势。时间间隔的大小取决于数据收集配置。\n\n* `Basic Features` One straightforward way to determine whether a transaction is interesting is to use the values of specified attributes as basic features, such as the payment amount of a commodity. In addition, the analysts can define new attributes. For example, if a seller is in the interesting list given by the analyst, he or she is considered as a salient seller, as shown in *Figure 3*. The collection of these attributes constructs a set of basic features. \n* `Textual Features` A transaction may contain textual information, such as the comment of a commodity. VAET examines whether the textual information contains sensitive words in a analyst-specified list. The analysts keep a dictionary for sensitive words and phrases collected manually from the past several months. For example, in a kind of fraud transactions, the buyers want their cash back as soon as possible. “cash back” is a sensitive phrase here. Sensitive words vary in different situations, and can be regarded as textual features. \n* `Temporal Features` Temporal patterns of a sequence of transactions are essential for identifying interesting patterns in the datasets. For example, the transaction amount of a seller in a time interval indicates his or her popularity. However, time-oriented relations are difficult to discover with conventional decision tree approaches. To address this problem, VAET uses the transaction frequency of the seller in every time interval as a measure of the temporal trend. The size of the time interval depends on the data collection configuration.\n\n![图3](feature-extraction.png)\n\n### Estimating saliency using Probabilistic Decision Tree 使用概率决策树估计显着性\n\n决策树最初使用训练数据集构建，该数据集由分析师标记的交易的提取功能组成。 如图2（e）所示，可以通过添加分析员标识的事务，在可视化探索过程中手动更新训练数据集。 在我们的方法中，使用完善的C4.5算法从训练数据中自动构建决策树，其根据特征将训练集递归地分解为子集。 在决策树中（参见图4的示例），叶子节点表示类（显着或非显着2个类别），内部节点对应于特征。 在每个内部节点处，C4.5根据产生`最高归一化信息增益`（highest normalized information gain）的特征将样本分解为子集，并将特征分配给该节点\n\n![图4](decision-tree.png)\n\n概率根据决策树叶上的交易进行估计。 我们将FP表示为叶上的假阳数，T P表示真阳数（见图5中的混淆矩阵）。 叶上的概率分布估计由下式给出:\n\nP(y|x) = TP / (TP + FP)\n\n![表1](confusion-matrix.png)\n\n## TIME-OF-SALIENCY MAP: BROWSING A LARGE SET OF TRANSACTIONS 显著性时间映射：浏览大量交易集\n\n![图5](TOS-map.png)\n### Generation of Time-Of-Saliency Map 生成显著性时间映射\n\nTOS映射是基于2D密度的展示，沿着水平轴的时间和由销售类别（例如，“电子配件”和“衣服”）组织的垂直轴TOS映射均匀分割成行，每个行代表一个销售类别。在图（a）中，由蓝色框突出显示的颜色矩形提供了垂直轴上类别的视觉索引。此外，每行按照*时间间隔水平分割*。*根据其时间戳和销售类别*每个事务被投射到相应的单元。投射到同一个单元格的所有事务的显着值相加，并将总和映射到单元格的颜色。色彩映射可以使用默认颜色标度或分析器指定的色标。所得到的TOS映射可视化地为分析任务编码事务的相关性。*黑暗区域*意味着一组潜在有趣的交易。特别地，连续的暗带表示在一段时间内相应的销售类别中的高度突出的交易（参见图1（a）中的TOS映射中的所选区域）。\n\n### Time-Of-Saliency Exploration 探索显著性时间映射\n\nTOS映射视图中提供了以下交互，可用于完成第一个任务（即识别感兴趣的时段和/或销售类别。）\n\n* `时间窗口` TOS映射以分析人员`可调节的时间间隔`显示交易。可以使用额外的时间窗口小部件来定位视图的特定区域以进行进一步和详细的研究。分析师可以在`时间选择栏`上单击并拖动以设置TOS映射的时间窗口，如图5（a）中TOS映射顶部的突出显示。图5（b）显示了分析师设置时间窗口后的TOS映射。\n\n* `感兴趣的区域` 分析师可以点击`类别索引`（图5（a）中的蓝框）来选择同一类别的交易。 也可以使用`套索工具`来选择有趣的区域。 当选择一个区域时，将出现一个`浮动文本框`以显示有关该区域的信息。 所选交易的详细信息可以在第7节中描述的KnotLines视图中进一步可视化和探索。此外，还提供了一个`条形图视图`（图1（c））以显示所选数据中的类别的销售量。\n\n\n* `Time Windowing` The TOS map shows the transactions in an analyst-adjustable time interval. An additional time windowing widget can be used to locate a specific region of the view for further and detailed study. Analysts can click and drag on the time selection bar to set the time window of the TOS map, as highlighted over the top of the TOS map in Figure 5 (a). Figure 5 (b) shows the TOS map after the analyst sets the time window. \n\n* `Region-Of-Interest` Selection The analysts can click on the category index (the blue box in Figure 5 (a)) to choose the transactions of the same category. A lasso tool can also be used to select interesting regions. When a region is selected, a floating text box will appear to show the information about the region. The detailed information of selected transactions can be further visualized and explored in the KnotLines view described in Section 7. In addition, a bar chart view (Figure 1 (c)) is provided to show the sales volume of categories in the selected data.\n\n## KNOTLINES: EXAMINING TRANSACTIONS IN DETAIL 详细审查交易\n\nKnotLines允许分析师对从TOS映射中选择的显着交易进行详细分析。它旨在解决任务2到任务4。KnotLines可视化显示两种类型的信息：属性和交易的时间趋势。\n\n### Data Organization and Visual Layout 数据组织和视觉布局\n\n为了研究交易之间的属性相似性和时间相关性，所选择的交易集被组织成一个三级分层树（图6）。 首先，我们使用矩阵表来可视化事务的组织，如图7（a）所示。\n\n\n![图6](hierarchical-tree.png)\n\n* `一级` 整个选定的交易集根据不同的卖家分为N组（1级）。图7（a）中的*每一行代表一个组*。一组包含卖家的所有交易。这些组沿垂直轴从上到下列出。\n* `二级` 一组中的交易根据其时间戳进一步分为子组（2级）。图7（a）中的*水平轴表示时间*。每行分别对应于M个时间间隔的时间轴上的M个正方形。所有间隔的长度相同，可以调整以探索不同粒度的数据。属于相同时间间隔的卖方的交易形成一个子组（2级）。\n* `三级` 根据销售类别（例如，“图书”），将一个子组进一步分为（级别3）。在图7（a）中，每个正方形被分割成K个细胞，每个细胞代表一个部分。同一部分的交易由同一卖方作出，在同一时间间隔内进行，属于同一销售类别。\n\n`PS`：即三级严格递增，一级是属于同一个卖家，二级属于同一个卖家某段时间，三级属于同一个卖家某段时间的某类销售类别。分别按行，按列，按细胞划分。这个是交易集逻辑上关系，而图7是一种为了方便分析而设计表示该关系的可视化方法。\n\n* `Level One` The whole selected transaction set is divided into N groups (level 1) according to different sellers. Each row in Figure 7 (a) represents a group. A group contains all transactions of a seller. The groups are listed from top to bottom along the vertical axis. \n* `Level Two` The transactions in a group are further divided into subgroups (level 2) according to their time stamps. The horizontal axisin Figure 7 (a) represents the time. Each row is split into M squaresalong the time axis which correspond to M time intervals. The lengthsof all intervals are the same and can be adjusted to explore the data at different granularities. Transactions of a seller which fall into the same time interval form a sub-group (level 2).\n* `Level Three` A subgroup is further divided into sections (level 3)according to the sales categories (e.g., “Books”). In Figure 7 (a), each square is segmented into K cells, each of which represents a section. Transactions in the same section are made by the same seller, take place in the same time interval, and belong to the same sales category.\n\n![图7](visual-organization.png)\n\n\n因为大部分卖家的交易量在一天的时间内可能很高，因此图7（a）所示矩阵中的交易密度可能非常稀疏。 另外，组N的数量可能很大（例如，100万）。 为了使探索更加有效，矩阵式布局应重新设计为更紧凑。\n\nVAET采用一个简单的两步启发式方案，对每个组进行操作。 \n\n1. 在第一步中，删除第一个非空子组之前和最后一个非空子组之后的空子组。 这个步骤导致许多组仅覆盖水平空间的一小部分，因为它们中的大多数具有短的时间跨度。\n\n1. 为了增加空间效率，在第二步中启发式优化组的布局。 迭代布局策略用于满足以下原则： \n    * 整洁：组不应重叠;\n    * 紧凑型：空间利用率高;\n    * 代表：重要群体应优先展示\n\nVAET employs a simple two-step heuristic scheme that operates on each group. In the first step, empty sub-groups before the first nonempty sub-group and after the last non-empty sub-group are removed. This step results in many groups that only cover a small portion of the horizontal space, because most of them have a short time span. To increase the space efficiency, the placement of the groups is heuristically optimized in the second step. An iterative layout strategy is used to satisfy the following principles:\n\n* Uncluttered: groups should not overlap;\n* Compact: space utilization should be high;\n* Representative: important groups should have a display priority\n\n分析人士指出， *这种设计（即图7）* 有几个主要缺点：\n\n* 由于部分可能包含数百个交易，可视化严重凌乱。 分析师建议在同一部分内汇总交易;\n* 分析师认为，紧凑的布局是空间效率高的必需品。 然而，他们很难从这个视图来识别同一卖家所做的交易。需要额外的视觉属性来强调这一重要关系;\n* 在此视图中没有提供有关交易的重要信息，如付款金额，交易是否缺少值，以及是否经常发生相同的交易。\n\nThe analysts pointed out that there were several major drawbacks in this design: (1) The visualization was seriously cluttered since a section may contain hundreds of transactions. The analysts suggested aggregating transactions within the same section; (2) The analysts agreed that the compact layout was necessary for high space efficiency. However, it was difficult for them to identify transactions made by the same seller from this view. Additional visual attributes were desired to emphasize this important relationship; (3) Important information about the transactions such as payment amount, whether a transaction had missing values, and if identical transactions occurred frequently, was not presented in this view.\n\n### KnotLines （结线）\n\n为了解决上述问题，我们设计了一个增强的视觉隐喻调用KnotLines。它受到音乐符号的启发，这可以被看作是一个改进的散点图，它沿着时间轴放置不同类型的点（音符）。它是时间序列（例如节拍和节奏）及其连接的复杂视觉表示。\n\n这里就不详细说明了，具体见表2。\n\n![图8](Knotlines.png)\n\n表2 是Knotlines的可视化各个部分的含义\n| 图形部分 | 含义|\n|----|----|\n| 视觉编码 | 交易数据|\n| 一个knotline | 同一卖家在不同时间的交易（一组）|\n| 一个knotbunch | 同一卖家在一段时间间隔内进行交易（一个子组）|\n| 茎长 | 在一段时间内同一卖家的交易总支付金额|\n| 一个结 | 在一段时间内，同一卖家与同名销售类别的交易（一节）|\n| 结的颜色 | 该结点的销售类别|\n| 结的大小 | 该结点的商品数量|\n| 一个未填充的结点 | 与卖方或买方位置异常的交易|\n\n![表2](Visual-Encoding.png)\n\n### Visual Exploration 可视化探索\n\n除了布局模式的规范和详细结点的调查之外，KnotLines还提供了一套用于分析多个结线的交互。\n\n* `显着调制` KnotLines视图中显示的每个事务都包含一个显着值。 分析师可以显示从2D TOS映射中选择的所有交易，或仅显示显着值大于给定阈值（例如，0.8）的所选交易。 当视图中显示许多节线时，此过滤操作非常有用，因此它支持T2和T3。 图9显示了显着性调制的影响。\n* `查看导航` KnotLines视图可以水平放大，以清楚说明，这对T2和T3有帮助。 时间间隔的长度将相应调整。 分析师可以垂直或水平滚动查看更多的knotlines。\n* `兴趣选择结` 我们可以通过单击或使用套索工具拖动来选择一组结。 指定结时，会以黄色的圆圈突出显示。 由同一买家制造的相关结也用灰色的圆环突出显示分析师的注意力（图1（b））。 将出现一个浮动文本框，显示所选结的详细信息，如卖方的位置，支付金额和销售类别。 分析员可以在详细视图（图1（e））中的所选结（部分）中检查交易的信息（例如，买方和卖方的位置，子类别和商品编号），其中 是为T2设计的。 对T4有帮助的统计视图（图1（f））用于提供所选结的统计信息，如交易频率和卖方支付金额的趋势。\n* `标签` 当特定交易被分析师识别为突出显示时，可以将其添加到标记数据中进行迭代视觉分析和探索。\n\n\n* `Saliency Modulation` Each transaction shown in the KnotLines view contains a saliency value. The analysts can show either all transactions selected from the 2D TOS map or only the selected transactions whose saliency values are larger than a given threshold (e.g., 0.8).This filtering operation is useful when there are many knotlines shown in the view, so it supports T2 and T3. Figure 9 demonstrates the effect of saliency modulation.\n\n* `View navigation` The KnotLines view can be zoomed horizontally for clear illustration, a function helpful for T2 and T3. The lengths of the time intervals will be adjusted accordingly. Analysts can scroll vertically or horizontally to see more knotlines.\n\n* `Knots of Interest Selection` We can select a set of knots by clicking, or dragging using a lasso tool. When a knot is specified, it is highlighted with a yellow ring. Related knots which are made by the same buyer are also highlighted with grey rings to draw the analysts’ attention (Figure 1 (b)). A floating text box will appear displaying the detailed information of the selected knot such as the location of the seller, the payment amount, and the sales category. Analysts can check the information of the transactions (e.g., the location of the buyer and the seller, the sub-category, and the commodity number) in the selected knot (section) in the detail view (Figure 1 (e)), which is designed for T2. A statistic view (Figure 1 (f)), which is helpful for T4, is used to present statistical information for the selected knot, such as the trend of the transaction frequency and the payment amount of the seller.\n\n* `Labeling` When a specific transaction is identified as salient by analysts,it can be added to the labeled data for iterative visual analysis and exploration.\n\n![图1](VAET-system.png)\n\n## CASE STUDY 案例研究\n\n`PS`: 这部分应该是论文作者讲述一次真实分析过程，里面有分析的思路与流程，还有该系统的使用特点。\n\n来自我们的客户 - 客户（C2C）零售业务的数据部门的分析师参与了这项研究。 该公司提供了一个数据集，其中包含2600万个在线电子交易，从中他们想要检测假交易。 约有930万卖家和买家参与了数据集。 他有兴趣通过与合作伙伴买家建立假交易来识别卖家何时积累信用。 异常交易行为的一些指标可能是异常大量的商品，支付金额的大幅变化，特定卖方和买方之间的频繁交易，以及价值超出其正常范围的属性。\n\n### Construction of Decision Tree 决策树构建\n\n计算每个时间间隔内的卖方的交易频率并将其用作`时间特征`。 根据由分析者提供并用作文本特征的敏感字典，提取了评论中的`关键词`和`短语`（例如“信用”）。我们标注了大约300笔交易，这些交易是使用分层抽样从每个类别中选出的。 我们用标记的数据训练了决策树。 将要分析的交易的提取特征描述作为决策树的`输入`，并为每个输入产生显着性值。\n\n我们使用`精确率`p和`召回率`r来评估决策树的效率：p = TP /（TP + FP）= 0.89，r = TP /（T P + FN）= 0.92，其中TP，TN，FP和FN 从训练数据的预测结果中计数（见表1）。\n`PS:` 这几个概念一般用于评估机器学习算法的性能等指标，也是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。 决策树算法在这里的作用只是用来找到显著性值。\n\n### Abnormal Frequency and Locations of Transactions 异常频率和交易地点\n\n分析师在简短的培训课程之后开始在TOS映射中进行勘探。他注意到一个具有`高度显着性的长长的地区`（图10）。随后，分析师指定了时间窗口，并放大到所需的区域。为了进一步研究交易行为，分析师选择了这个地区，发现许多交易在9月19日上午10点被分类为“图书”。分析师注意到连续的红色结在图1（b）的连线上连接。他告诉我们，*这种模式表明卖家在选定的时间间隔内频繁交易*。经查核详细资料后，分析师发现这些交易属于“充值卡”类别，并由*不同的买家*组成。他评论说，这可能是一个促销活动，因为他在这些交易中没有发现异常信息。分析师将显着阈值增加到0.8，`显着调制滑块`（Saliency Modulation）。*这使得分析师能够有效地过滤出许多不太显着的交易*。分析师立即找到多个未填充的结，指示具有缺失值的交易。他评论说，使用未填充的结来呈现缺失值的交易有效地吸引了他的注意。为了进一步调查这些记录是否表示促销或假交易，分析师进行了进一步分析。*当他点击这条结线中的一个未填充的结时，同一个结线中的许多其他结被突出显示*（图1（b）），表明这些结的大部分交易是由同一买方和卖方进行的。分析师注意到，详细信息视图中，买方的交货地址为空，通过查看此结线中的结的详细信息（图1（e））。他评论说这是可疑的，因为如果买方不填写他的地址，买家就不会买到这个商品。通过查看结的交易历史（图1（f）），分析师发现，卖方的销售额在一段时间内急剧增加。\n\n分析师认为这些交易可能与赚取`信用`有关。 该结论由数据提供商的商业智能部门的分析师进行了验证，他们检查了与交易相关的其他信息，如卖方和买方的IP地址。 他们解释说，这些交易是由一组帮助卖家增加`信用`的买家进行的，卖家没有真正交付产品。 分析师将这一结线中的交易标示为`显着`，并将它们添加到训练数据集中。\n\n![图10](salient-transactions.png)\n\n![图1](VAET-system.png)\n\n### Abnormal Attribute Values of Transactions 交易的异常属性值\n\n分析师在TOS映射中选择了另一个时间窗口。通过查看`条形图`视图中的销售类别信息（图11（a）），分析师发现，“电子配件”类别中销售的商品总数远远大于其他销售类别。*分析师认为，由于商品数量庞大，这将是促销活动*。他在`knotline`视图中调查了这个假设，但没有发现任何包含频繁连续的“电子配件”结。\n\n分析师在TOS映射中选择了此类别，以过滤掉不相关的类别。通过仔细检查剩余的结，分析师发现一个具有短茎的极大的结（图11（b）），表明一个较大的商品数量，总支付金额却较低。分析师告诉我们，“*通过这种knotline，我第一眼就注意到支付和商品数量之间的异常关系*”。结的详细视图（图11（c））显示，本节包含单笔交易，支付金额仅为10美分，商品却为22万件。通过进一步调查卖方的交易历史（图11（d）），分析师消除了销售促销的概率，因为卖方在一段时间内交易次数很少，表明销售商品很少。分析师认为这是一个事件，卖方试图根据已经出售的商品数量增加他们的互联网搜索排名。*分析师还将该交易标注为显着，并将其添加到训练数据集*。\n\n![图11](fig11.png)\n\n## USER STUDY 用户研究\n\n我们进行了用户研究，*以评估VAET支持低级别分析任务的能力*，即第3节中讨论的T1-T4。所使用的数据集是第8节（即上一节）中探讨的交易数据集。\n\n### Design 设计\n\n10名参与者（6名男性和4名女性）年龄介于21岁至35岁之间进行了用户研究。 其中两人是分析师，其他人则是研究生。 所有参与者都具有使用在线商务的经验，并且对电脑熟悉。 学生的专业包括计算机科学，设计，数学和生物学。 以前他们都没有使用过VAET。\n\n参与者一个接一个地参加研究。 对于每个参与者，在测试部分之前进行了短暂的训练。 在培训部分，教练首先向参与者介绍了VAET的25分钟演示。 在演示过程中，教练解释了VAET的视觉设计和功能。 在演示之后，参与者在教练的帮助下练习了VAET提供的互动5分钟。 在测试部分，参与者被要求完成9次练习，与实际分析中遇到的练习类似，无需教练帮助。 然后，他们被要求通过回答问卷并提供主观反馈来评估系统。\n\n这9个练习是针对三种不同的具体情况而设计的，其中两项是在第8节中描述的。每个低级任务都通过一项或多项练习进行评估。 他们评估的练习和任务如下（任务显示在括号中）：\n\n* E1 “使用TOS映射，从9月21日上午9点至10点选择具有最高显着性的销售类别。”目标：确定TOS映射（T1）中感兴趣的时间段和销售类别。\n\nE2和E3来自第8.3节所述的情况。\n\n* E2 “选择商品数量最大的销售类别”。目标：解释条形图并确定感兴趣的销售类别（T1）。\n\n* E3 “查找KnotLines中商品数量最多的交易。”目标：解释一个结的视觉编码，并识别具有特定属性（T2）的有趣模式的交易。\n\n要完成E4-E6，参加者将被要求在9月19日晚上18点至19点之间设置时间，并选择“充值卡”。\n\n* E4 “从KnotLines视图中找到具有最高交易频率的卖家（knotline）”。目标：解释knotline的视觉编码，并识别有趣的交易模式（T3）的卖家。\n\n* E5 “在KnotLines视图中，哪些卖方的交易模式不会发生？ （a）大量商品的单笔交易，但支付金额很小。 （b）低频连续交易。 （c）持续交易频率高，支付金额小。 （d）我不知道。“目标：解释这个knotlines和识别有趣的卖家交易模式（T3）。\n\n* E6 “E4中卖方交易历史的一个特征是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：以统计视角检查卖方的行为（T4）。\n\nE7 - E9与8.2节描述的情况相同。 \n\n* E7 “在KnotLines视图中查找未填充的结，并报告买方城市。”目标：使用详细信息视图（T2）检查事务的属性值。\n\n* E8 “E7中确定的卖方交易历史的主要特点是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：使用统计视图检查卖方的行为（T4）。\n\n* E9 “E7中确定的卖方的交易行为是什么？ （a）具有大量商品编号的单一交易。 （b）付款金额低的频繁交易。 （c）与异常购买城市频繁交易。“目标：解释和检查KnotLines（T4）的卖方交易模式。\n\nE1 “Choose the sales category with the highest saliency value from 9 am to 10 am on September 21 using the TOS map.” Objective: Identify time periods and sales categories of interest in the TOS map (T1).\n\nE2 and E3 were from the case described in Section 8.3.\n\nE2 “Choose the sales category with the largest commodity number.” Objective: Interpret the bar chart and identify sales categories of interest (T1).\n\nE3 “Find the transaction with the largest number of commodities in KnotLines.” Objective: Interpret the visual encoding of a knot and identify transactions with interesting patterns in specific attributes (T2).\n\nTo finish E4 - E6, participants were asked to set the time between 18 pm and 19 pm on September 19, and choose “Top-up Card”.\n\nE4 “Find the seller (knotline) with the highest transaction frequency from the KnotLines view.” Objective: Interpret the visual encoding of a knotline and identify sellers with interesting transaction patterns (T3).\n\nE5 “In the KnotLines view, which transaction pattern of the seller does not occur? (a) Single transaction with a large number of commodities but a small payment amount. (b) Continuous transactions with low frequency. (c) Continuous transactions with high frequency and a small payment amount. (d) I don’t know.” Objective: Interpret the knotlines and identify interesting seller transaction patterns (T3). \n\nE6 “Which is a feature of the seller transaction history of the knot in E4? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden, frequent transactions.” Objective: Examine the seller’s behavior in the statistic view (T4). \n\nE7 - E9 were the same case described in Section 8.2.\n\nE7 “Find unfilled knots in the KnotLines view and report the buyer cities of them.” Objective: Examine the attribute values of the transactions using the detailed information view (T2). \n\nE8 “What is the main feature of the seller’s transaction history of the knot identified in E7? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden ,frequent transactions.” Objective: Examine the seller’s behavior using the statistic view (T4).\n\nE9 “What is the transaction behavior of the seller identified in E7? (a) A single transaction with a large commodity number. (b) Frequent transactions with low payment amounts. (c) Frequent transactions with abnormal buyer cities.” Objective: Interpret and examine the seller’s transaction patterns from KnotLines (T4).\n\n练习结束后，参加者完成了由6个问题组成的调查问卷（Q1〜Q6）。 要求用1到5评估等级（1=非常简单或高效，5=非常困难或低效），*学习该VAET系统的难度和VAET的效率*。 这些问题也收集到主观反馈。 六个问题如下：\n\n1. 容易或难以学习TOS映射？\n2. 使用TOS映射探索显着数据是否有效？\n3. 单个结的`视觉编码`是否容易或难以解释？\n4. KnotLines的视觉编码和布局是否容易或难以解释？\n5. 使用KnotLines分析用户交易模式是否有效？\n6. 使用VAET整体分析多用户行为是否容易或困难？\n\n----\n\n1. Is it easy or hard to learn the TOS map?\n2. Is it efficient or not to explore salient data with the TOS map?\n3. Is it easy or hard to interpret the visual encoding of a single knot?\n4. Is it easy or hard to interpret the visual encoding and layout of KnotLines?\n5. Is it efficient or not to analyze the user transaction patterns with KnotLines?\n6. Is it easy or hard to analyze multi-user behavior with VAET as a whole?\n\n### Results 结果\n\n收集9次练习的准确性和时间进行评估\n\n总体来说，参加者完成了练习，在90次全部练习中产生5次错误（精准度为94.4％）。分析师正确回答了所有问题。对于学生参与者，其中两人在E5上出错，E8上有两个错，E9上有一个错。\n\n我们采访了E5的错误参与者。他们都说他们“只注意到knotlines的主要模式，忽略了发生较少的模式”。但是，他们没有解释用户行为的问题。回答E8的参与者错误地提到他们忘记检查统计视图中显示的卖家历史信息（图1（f）），而是根据KnotLines视图回答问题。在E9错误的参与者认为，零买家城市（null buyer cities）对于不需要交货地址的电子书等虚拟商品的交易是正常的。事实上，“图书”类别中的所有商品都是实物。虽然一些参与者有T3和T4的问题，但总体准确性表明VAET可以很好地支持任务。\n\nOverall, the participants completed the exercises, yielding 5 mistakes out of the 90 total exercises (94.4% accuracy). The analysts answered all questions correctly. As for the student participants, two of them erred on E5, two erred on E8 and one erred on E9. \n\nWe interviewed the participants who erred on E5. They both said that they “only noticed the main patterns of the knotlines and ignored the patterns with fewer occurrence”. However, they had no problem interpreting the user behavior from them. The participants who answered E8 incorrectly mentioned that they forgot to check the seller history information shown in the statistic view (Figure 1(f)) and answered the question based on the KnotLines view instead. The participant who erred on E9 thought that null buyer cities are normal for transactions of virtual commodities such as E-books, which do not need delivery addresses. In fact, all commodities in the “Books” category are real items. Although some participants had problems with T3 and T4, the overall accuracy indicates that VAET supports the tasks well.\n\n图12显示了每次锻炼的完成时间的平均值和标准偏差。 E3，E4和E7的时间比其他问题的时间长。 这三个练习要求参与者搜索具有特定特征的knotlines，这可能需要更多的时间仔细检查视图。 参与者能够快速完成其他6个问题。 完成时间为5.14s至44.22s。 分析师花费的时间远远少于学生参与者。 总体而言，VAET允许大多数参与者在90秒内完成复杂的练习和任务（如E4和T3）。 在考虑交易的各种属性以及它们之间的关系时，这是相当快的。\n\n![图12](fig12.png)\n\n\n分析师的反馈与讨论\n\n在用户研究结束时，我们采访了分析师和其他参与者。 两位分析师都对分类结果感到满意。 他们评论说，在分析不同类型的交易时，特征提取和决策树的集成是高效和灵活的。 我们要求他们将决策树与之前使用的逻辑回归进行比较。 他们认为我们的模型有几个优点：\n\n* 决策树对于分析师来说很简单易懂。\n* 在处理属性的缺失值时，决策树比逻辑回归更强大。\n* 使用决策树的分类比逻辑回归更快。 \n\n他认为我们可以通过使用更多的信息来改进我们的方法，比如今后买家和卖家的IP地址。\n\n他们评论说，TOS映射是直观的，勘探方便。一位分析师表示：“KnotLines的多用户行为的可视化是创造性和生动的。”*虽然一位分析师认为该系统很难学习，但很少参与者难以解释可视化*，大多数人能够在简短的培训会议后找到有趣的交易。两位分析师都提到，VAET能够帮助他们探索未被发现的交易模式。这是至关重要的，因为“欺骗人总是不断改变伎俩”。他们认为，VAET有能力找到新兴的交易模式，并帮助他们改进数据模型。分析师们渴望将VAET用于实际的多用户应用程序，在这些应用程序中，他们发现许多高维度事务之间的上下文和时间相关性。有趣的是，一些参与者最初认为使用我们的系统需要基本的音乐知识。其他与会者提到，他们对音乐笔记的了解影响了对设计的理解。例如，茎长度固定在音符中，但在我们的设计中是可变的。此外，有些人认为与其他knotbunches（类似于四分之一音符）没有连接的单个knotbunch持续比连接的knotbunch短（类似于第八个音符）。事实是，交易没有持续时间，因为它们都是立即在线发生的。与会者告诉我们，在他们学会如何解读设计之后，这种差异并没有妨碍他们的分析。\n\n## CONCLUSION 总结\n\n本文提出了一种用于识别基本交易数据和研究*大片碎片记录*的`时间`或`集体行为`的新型视觉探索方案。 在对KnotLines进行选择交易的详细探索和推理之前，执行决策树算法和TOS映射的过滤过程，以从大量记录中选择潜在有趣的交易。 案例研究和用户研究证实，VAET可以有效地支持大部分任务。 根据结果，一些任务如T3需要更好地解决，因为交易模式可以是`动态的`和`多层次的`。 为了使VAET更容易学习和使用，我们希望使TOS映射和KnotLines的设计更加直观。 对于未来的工作，我们也希望对更多的数据集进行扩展。\n\nThis paper presents a novel visual exploration scheme for identifying elementary transaction data and studying the temporal or collective behavior from large pieces of fragmented records. Prior to detailed exploration and reasoning of the chosen transactions with KnotLines, a decision tree algorithm and a filtering process by TOS map are performed to choose potentially interesting transactions from a huge amount of records. The case study and the user study verify that VAET can effectively support most of the tasks. According to the result, some tasks such as T3 need to be better addressed as the patterns of transactions can be dynamic and multi-level. To make VAET easier to learn and use, we would like to make the design of TOS map and KnotLines more intuitive. For future work, we also would like to extend our approach for more datasets.","slug":"VAET阅读稿","published":1,"updated":"2017-10-13T08:13:56.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y82000i6svsl7b0250y","content":"<h1 id=\"VAET-A-Visual-Analytics-Approach-for-E-transactions-Time-Series-电子交易时间序列的一种可视化分析方法\"><a href=\"#VAET-A-Visual-Analytics-Approach-for-E-transactions-Time-Series-电子交易时间序列的一种可视化分析方法\" class=\"headerlink\" title=\"VAET: A Visual Analytics Approach for E-transactions Time-Series  电子交易时间序列的一种可视化分析方法\"></a>VAET: A Visual Analytics Approach for E-transactions Time-Series  电子交易时间序列的一种可视化分析方法</h1><blockquote>\n<p>Cong Xie, Wei Chen, Member, IEEE, Xinxin Huang, Yueqi Hu, Scott Barlowe, and Jing Yang</p>\n</blockquote>\n<p>创新实践的论文阅读作业，翻译了主要内容，加上部分自己的理解并修改部分内容，保留了部分原文，有时候阅读原文更好理解。全文按照论文组织的方式编写，主要是为了理清楚论文的主要思想，并可以简单地给其他人做宏观上的解释，达到基本的教学目的。此文将作为ppt的前稿。</p>\n<hr>\n<a id=\"more\"></a>\n<p><img src=\"VAET-system.png\" alt=\"图1\"></p>\n<h2 id=\"INTRODUCTION-介绍\"><a href=\"#INTRODUCTION-介绍\" class=\"headerlink\" title=\"INTRODUCTION 介绍\"></a>INTRODUCTION 介绍</h2><p>The E-transaction time-series contains transactions among multiple users in a time range. Each record contains a time stamp, the IDs of the seller and buyer, and the associated attributes of the commodities. Each record is an atomic element representing an online transaction among a seller and a buyer.</p>\n<p>电子交易时间序列包含时间范围内的多个用户之间的交易。 每个记录都包含时间戳，卖方和买方的ID以及相关联的商品的属性。每个卖方和买方之间的网上交易记录都是一个原子元素。</p>\n<p><em>在时间上下文中分析电子交易时间序列至关重要了解交易行为，学习用户偏好和发现时间趋势。</em></p>\n<p>通过面试分析师发现以下一些问题常常很难回答：</p>\n<ul>\n<li>卖方的多个交易之间的时间和<code>上下文</code>关系是什么？比如短时间内有个卖家有大量的交易，而且可能来自某个买家，分析师需要发现这样的交易的各种属性。</li>\n<li>最常见的交易模式是什么？比如平时工作日交易比较稀疏，但是圣诞节交易比较频繁。</li>\n<li>如何识别<code>有趣</code>的交易？比如买家勾结来加速影响卖家的信用，一旦这样的模式定义好了，分析师需要在相关的大量数据集中找到特定属性值来挖掘这样的交易。</li>\n<li>如何在上下文检测某个交易？比如小额购买巨量的商品可能是个假的交易，利用它来提升卖家排名。为了确认交易是假的，分析师需要将交易与买方和卖方的信息关联。</li>\n</ul>\n<p>我们认为，自动数据挖掘过程在回答上述问题时并没有足够的灵活性和准确性。<br>因此迫切需要视觉分析方法，使分析人员能够通过集成计算能力，人类知觉能力和领域知识，通过即时视觉反馈灵活地形成和测试假设。</p>\n<p>目前还没有适用于上述情况的可视化方法。<br>多变量时间序列可视化的现有研究工作主要集中在总结多维度的全局和/或时间趋势或发现个体维度的模式，如Sparklines。</p>\n<p>因此提出了一种新颖的视觉分析系统，称为电子交易时间序列的视觉分析（VAET），旨在探索电子交易时间序列，以便在时间上下文中分析多个用户之间的交易模式。<br>VAET有如下2个主要的可视化分析组件：</p>\n<ul>\n<li>Overview: This component helps the analysts effectively identify salient transactions from a large dataset. 该组件帮助分析师在大量数据集中快速找到突出的交易。VAET使用概率决策树学习器首先计算每个交易的显着性值，以揭示其与分析目标的相关性（例如，作为假交易的可能性）。然后，显着值显示在一个称为<code>显着时间映射</code>（TOS）的像素方向的显示中。该映射提供了一个工作空间来探索和选择不同时间粒度的潜在有趣的交易;</li>\n<li>Detail view：This component allows the analysts to conduct detailed examination on interesting transactions for insights. 该组件允许分析人员对感兴趣的交易进行仔细检查，以获取见解。特别地，从概述中选择的交易使用称为<code>KnotLines</code>的新的视觉隐喻来显示。协调TOS映射和KnotLines，以便分析人员可以快速识别来自大型数据集的有趣事务。</li>\n</ul>\n<p>A case study and a user study with a real online transaction dataset demonstrated that VAET was effective in supporting a variety of analysis tasks.<br>真实在线交易数据集的案例研究和用户研究表明，VAET有效支持各种分析任务。</p>\n<p>VAET的主要贡献包括：</p>\n<ul>\n<li>视觉分析系统，允许分析人员在时间上有效地分析大型电子交易时间序列;</li>\n<li>从大型数据集中检测和可视化突出事务的方法;</li>\n<li>一种新颖的视觉隐喻，用于紧凑地放置和编码特征属性以及多用户事务的时间和上下文相关性</li>\n</ul>\n<h2 id=\"RELATED-WORK-相关工作\"><a href=\"#RELATED-WORK-相关工作\" class=\"headerlink\" title=\"RELATED WORK 相关工作\"></a>RELATED WORK 相关工作</h2><h3 id=\"Visual-Analysis-of-E-transaction-Data-电子交易数据的可视化分析\"><a href=\"#Visual-Analysis-of-E-transaction-Data-电子交易数据的可视化分析\" class=\"headerlink\" title=\"Visual Analysis of E-transaction Data 电子交易数据的可视化分析\"></a>Visual Analysis of E-transaction Data 电子交易数据的可视化分析</h3><p>以下是之前一些人做的过相关研究（寻找合适的可视化方法来展示交易数据）</p>\n<p>The transaction data contains various types of attributes, such as numerical, temporal and categorical. The Sparklines [23] can be used to visualize multiple trends in financial data. Liu et al. [11] proposed a visualization system called SellTrend for analyzing airline travel purchase requests. WireVis [3] was proposed to search on predefined patterns in large wire transaction datasets. Visual analytics approaches have been proposed to explore web clickstreams of online transactions [26]. Our approach is among the earliest visual analytics approaches for the exploration of temporal and contextual connections in multiuser transactions.</p>\n<p>Transaction data often have multi-dimensional attributes. Analyzing them often requires the integration of well-designed data mining models. <em>Probabilistic models are employed to model user behavior [12], resulting in user clusters. This scheme has been successfully applied to classify E-transaction data into different types [2].</em> Association analysis is another widely used model for transaction data. Hao et al. [7] proposed the DAV system to visualize the relationships of associated products.</p>\n<h3 id=\"Visual-Analysis-of-User-Behavior-Time-Series-用户行为时间序列的可视化分析\"><a href=\"#Visual-Analysis-of-User-Behavior-Time-Series-用户行为时间序列的可视化分析\" class=\"headerlink\" title=\"Visual Analysis of User Behavior Time-Series 用户行为时间序列的可视化分析\"></a>Visual Analysis of User Behavior Time-Series 用户行为时间序列的可视化分析</h3><p>以前有很多关于用户行为时间序列分析和可视化的作品。这里我们只总结最相关的一些，并将它们分类为分析个人行为，用户交互和组行为的技术。</p>\n<p><code>Temporal Individual Behavior Patterns</code> Many visualization approaches designed to analyze user behavior data are focused on exploring the temporal behavior patterns of individuals.<br>旨在分析用户行为数据的许多可视化方法都集中在探索个人的时间行为模式。<br>TimeSearcher [8] allows users to select interesting time-series using a rectangular query region. LifeLines [16] visualizes health-related incidents of patients along a timeline. Most previous works utilize high-dimensional visual exploration tools such as parallel coordinates [4] to explore extracted patterns. Density-based display techniques [6], [10] are capable of showing large time-series datasets for real-time monitoring. Additional visual exploration techniques include time trajectory [21] and [13].</p>\n<p><code>User Interaction Patterns</code> conventional solutions consider the user network as a social network and analyze its global structure<br>常规解决方案将用户网络视为社会网络，并分析其全局结构。<br>Sallaberry et al. [20] provide an overview of dynamic network evolution over time. Other approaches emphasize the user interaction characteristics such as email connections [25] and instant messages [27]. However, these methods are focused on the structural changes rather than the temporal variations of the interactions. Other approaches aim to reveal the relationships among multiple users in a temporal context. For instance, Storyline [22] shows the narrative threads that form a plot or a subplot in works of fiction. The history flow approach successfully reveals author collaboration patterns [24]. Code Swarm [15] visualizes the animated histories of software project evolution. VAET reveals both the temporal patterns of multi-user behavior and their atomic level correlations. It improves the above approaches by allowing the analysts to explore a large number of transactions at different granularities.</p>\n<h2 id=\"Problem-definition-问题定义\"><a href=\"#Problem-definition-问题定义\" class=\"headerlink\" title=\"Problem definition 问题定义\"></a>Problem definition 问题定义</h2><blockquote>\n<p>Multi-user transaction data is a special type of user behavior data with a focus on characterizing raw, detailed, and subtle inter-user transactions. An E-transaction time-series dataset contains information about each E-transaction, including information about transaction time, the buyer, and the seller. Each E-transaction records a transaction between a buyer and a seller.</p>\n</blockquote>\n<p>多用户事务数据是一种特殊类型的用户行为数据，重点是描述原始，详细和微妙的用户间交易。电子交易时间序列数据集包含每个电子交易的信息，包括有关交易时间，买方和卖方的信息。 每个电子交易记录买方和卖方之间的交易。</p>\n<p>一般来说，一个电子交易包含以下属性：</p>\n<ul>\n<li><p><code>User information</code> includes the IDs and other information about the buyer and the seller who make the transaction, e.g., their age group, gender, and location.</p>\n</li>\n<li><p><code>Transaction information</code> includes the time stamp and other information about the commodities, e.g., the payment amount, the number, and the sales category of the commodity.</p>\n</li>\n</ul>\n<p>The above attributes can be numerical, ordinal, categorical, textual, or temporal.<br>上述属性可以是数字，序数，分类，文本或时间。</p>\n<p>分析师通常通过一系列低级别任务进行复杂的任务。 这些任务通常关注卖方的行为，例如：</p>\n<ul>\n<li>识别感兴趣的时段和/或销售类别。</li>\n<li>识别具有特定属性的有趣模式的交易（例如，支付金额≥500）并检查其详细信息。</li>\n<li>识别具有有趣交易模式的卖家，例如卖家以小额付款金额进行频繁交易。</li>\n<li>检查特定卖家的交易模式</li>\n</ul>\n<p>The analysts usually conduct a complex task through a set of low level tasks. These tasks typically focus on the behavior of the seller, such as:</p>\n<ul>\n<li>T1 Identifying time periods and/or sales categories of interest.</li>\n<li>T2 Identifying transactions with interesting patterns in specific attributes(e.g., payment amount ≥ 500) and examining their detailed information.</li>\n<li>T3 Identifying sellers with interesting transaction patterns, such as a seller making frequent transactions with small payment amounts.</li>\n<li>T4 Examining the transaction patterns of a specific seller</li>\n</ul>\n<p>我们使用术语<code>显着</code>定量地描述交易与分析师定义的目标的相关程度。根据调查，识别和审查突出交易是电子交易时间序列探索中至关重要但具有挑战性的任务。通常，分析师需要通过迭代查询数据集并检查检索到的事务之间的属性值和关系来手动识别突出事务。此外，分析师经常需要检查突出交易以及用户的历史数据等信息，以证明其行为或揭示有趣的模式。这个过程通常是费力和乏味的。VAET旨在简化此过程，提高整体运行效率。（VAET is designed to ease this process and improve the overall operation efficiency.）</p>\n<h2 id=\"APPROACH-OVERVIEW-方法概览\"><a href=\"#APPROACH-OVERVIEW-方法概览\" class=\"headerlink\" title=\"APPROACH OVERVIEW 方法概览\"></a>APPROACH OVERVIEW 方法概览</h2><p>The goal of VAET is to identify and explore interesting transactions by selecting those with high saliency and studying them. This is accomplished by integrating the capabilities of both data mining and visualization techniques within the following iterative visual exploration pipeline.</p>\n<p>VAET的目标是通过选择具有高度显着性并研究它们来识别和探索有趣的交易。这是通过将数据挖掘和可视化技术的功能集成在以下迭代视觉探索流程中来实现的。</p>\n<ul>\n<li><p>步骤1，使用决策树的显着计算：从每个事务中提取一组特征。分析人员将某些交易的功能手动标记为训练数据。使用这些特征，在训练数据上构建概率决策树学习器。然后用它来产生每个未标记交易的显着值（图2（b））。</p>\n</li>\n<li><p>步骤2，使用TOS映射进行浏览和选择：所有事务的显着性值映射到紧凑的基于密度的生存时间（TOS）映射。在此映射中，交易按时间和类别排序，并以颜色对应于显着值的像素表示。分析师可以交互地探索映射，调查全球分布和地域格局，并选择根据这个观点的显着性值，有趣的交易。（图2（c））。</p>\n</li>\n<li><p>步骤3，使用KnotLines进行详细分析：分析师选择的交易通过一种新颖的视觉隐喻<code>KnotLines</code>可视化，允许研究多个属性和上下文连接（图2（d））。分析人员确定为突出事务的交易可以被标记并反馈到步骤1以继续迭代过程（图2（e））。</p>\n</li>\n</ul>\n<ul>\n<li>Step 1 Saliency computation with decision tree: A set of features are extracted from each transaction. The analysts manually label the features of some transactions as the training data. Using these features, a probabilistic decision tree learner is constructed upon the training data. It is then employed to produce the saliency values for each unlabeled transaction (Figure 2 (b)).</li>\n<li>Step 2 Browsing and selection using the TOS map: The saliencyvalues of all transactions are mapped to a compact, density-based Time-Of-Saliency (TOS) map. In this map, transactions are ordered by time and categories and represented by pixels whose colors correspond to saliency values. The analysts can interactively explore the map, investigate the global distribution and local patterns, and select interesting transactions according to the saliency values from this view. (Figure 2 (c)).</li>\n<li>Step 3 Detailed analysis using KnotLines: The analyst-selected transactions are visualized with a novel visual metaphor, KnotLines, that allows the study of multiple attributes and contextual connections (Figure 2 (d)). The transactions identified as salient by the analysts can be labeled and fed back into Step 1 to continue the iterative process (Figure 2 (e)).</li>\n</ul>\n<p>分析人员可以通过调整标记的数据集，导航映射和探索有趣的交易来迭代地循环上述步骤。 TOS映射和KnotLines可视化提供可扩展的探索，如时间间隔选择和详细审查。</p>\n<p><img src=\"VAET-overview.png\" alt=\"图2\"></p>\n<h2 id=\"SALIENCY-COMPUTATION-WITH-DECISION-TREE-决策树的显著性计算\"><a href=\"#SALIENCY-COMPUTATION-WITH-DECISION-TREE-决策树的显著性计算\" class=\"headerlink\" title=\"SALIENCY COMPUTATION WITH DECISION TREE 决策树的显著性计算\"></a>SALIENCY COMPUTATION WITH DECISION TREE 决策树的显著性计算</h2><p>计算显着性值本质上是上下文感知和任务定位的。 对于许多任务，显着性值不能直接从事务属性导出。 例如，当分析师搜索异常交易时，往往需要考虑卖方的交易频率。 让分析人员手动指定每个交易的显着性值也是不切实际的。 因此，我们建议通过定义和计算一组交易的特征来计算每个记录的显着性值。特别地，我们的方法通过<code>概率决策树</code>计算显着值作为概率估计问题。 我们选择决策树，因为它可以处理连续和分类的属性，很容易解释。 决策树最初由一组分析师确定的训练数据的特征构建。 将决策树应用于每个未标记事务的特征，产生的概率范围为0到1，用作底层事务的显着值。 分析师手动标记为交易的交易可以在随后的分析中添加到训练数据集中（图2（e））。</p>\n<h3 id=\"Feature-Extraction-特征提取\"><a href=\"#Feature-Extraction-特征提取\" class=\"headerlink\" title=\"Feature Extraction 特征提取\"></a>Feature Extraction 特征提取</h3><p>VAET计算一组分析师指定的每个事务的时间和上下文特征作为一组特征。 一般来说，定义了三种类型的特征：</p>\n<ul>\n<li><code>基本特征</code> 确定交易是否有趣的一个直接方法是使用指定属性的值作为基本特征，例如商品的支付金额。另外，分析人员可以定义新的属性。例如，如果卖家在分析师给出的有趣的列表中，则他或她被视为显着的卖家，如图3所示。这些属性的集合构成一组基本功能。</li>\n<li><code>文本功能</code> 交易可以包含文本信息，例如商品的评论。 VAET检查文本信息是否包含分析师指定列表中的敏感词。分析人员保留一个字典，用于从过去几个月手动收集敏感的词汇和短语。例如，在一种欺诈交易中，买家希望尽快回收现金。 “现金回馈”是一个敏感的短语。敏感词在不同的情况下有所不同，可以视为文字特征。</li>\n<li><p><code>时间特征</code> 交易序列的时间模式对于识别数据集中的有趣模式至关重要。例如，卖方在时间间隔内的交易金额表示他或她的受欢迎程度。然而，以传统的决策树方法难以发现面向时间的关系。为了解决这个问题，VAET使用卖方在每个时间间隔的交易频率作为衡量时间趋势。时间间隔的大小取决于数据收集配置。</p>\n</li>\n<li><p><code>Basic Features</code> One straightforward way to determine whether a transaction is interesting is to use the values of specified attributes as basic features, such as the payment amount of a commodity. In addition, the analysts can define new attributes. For example, if a seller is in the interesting list given by the analyst, he or she is considered as a salient seller, as shown in <em>Figure 3</em>. The collection of these attributes constructs a set of basic features. </p>\n</li>\n<li><code>Textual Features</code> A transaction may contain textual information, such as the comment of a commodity. VAET examines whether the textual information contains sensitive words in a analyst-specified list. The analysts keep a dictionary for sensitive words and phrases collected manually from the past several months. For example, in a kind of fraud transactions, the buyers want their cash back as soon as possible. “cash back” is a sensitive phrase here. Sensitive words vary in different situations, and can be regarded as textual features. </li>\n<li><code>Temporal Features</code> Temporal patterns of a sequence of transactions are essential for identifying interesting patterns in the datasets. For example, the transaction amount of a seller in a time interval indicates his or her popularity. However, time-oriented relations are difficult to discover with conventional decision tree approaches. To address this problem, VAET uses the transaction frequency of the seller in every time interval as a measure of the temporal trend. The size of the time interval depends on the data collection configuration.</li>\n</ul>\n<p><img src=\"feature-extraction.png\" alt=\"图3\"></p>\n<h3 id=\"Estimating-saliency-using-Probabilistic-Decision-Tree-使用概率决策树估计显着性\"><a href=\"#Estimating-saliency-using-Probabilistic-Decision-Tree-使用概率决策树估计显着性\" class=\"headerlink\" title=\"Estimating saliency using Probabilistic Decision Tree 使用概率决策树估计显着性\"></a>Estimating saliency using Probabilistic Decision Tree 使用概率决策树估计显着性</h3><p>决策树最初使用训练数据集构建，该数据集由分析师标记的交易的提取功能组成。 如图2（e）所示，可以通过添加分析员标识的事务，在可视化探索过程中手动更新训练数据集。 在我们的方法中，使用完善的C4.5算法从训练数据中自动构建决策树，其根据特征将训练集递归地分解为子集。 在决策树中（参见图4的示例），叶子节点表示类（显着或非显着2个类别），内部节点对应于特征。 在每个内部节点处，C4.5根据产生<code>最高归一化信息增益</code>（highest normalized information gain）的特征将样本分解为子集，并将特征分配给该节点</p>\n<p><img src=\"decision-tree.png\" alt=\"图4\"></p>\n<p>概率根据决策树叶上的交易进行估计。 我们将FP表示为叶上的假阳数，T P表示真阳数（见图5中的混淆矩阵）。 叶上的概率分布估计由下式给出:</p>\n<p>P(y|x) = TP / (TP + FP)</p>\n<p><img src=\"confusion-matrix.png\" alt=\"表1\"></p>\n<h2 id=\"TIME-OF-SALIENCY-MAP-BROWSING-A-LARGE-SET-OF-TRANSACTIONS-显著性时间映射：浏览大量交易集\"><a href=\"#TIME-OF-SALIENCY-MAP-BROWSING-A-LARGE-SET-OF-TRANSACTIONS-显著性时间映射：浏览大量交易集\" class=\"headerlink\" title=\"TIME-OF-SALIENCY MAP: BROWSING A LARGE SET OF TRANSACTIONS 显著性时间映射：浏览大量交易集\"></a>TIME-OF-SALIENCY MAP: BROWSING A LARGE SET OF TRANSACTIONS 显著性时间映射：浏览大量交易集</h2><p><img src=\"TOS-map.png\" alt=\"图5\"></p>\n<h3 id=\"Generation-of-Time-Of-Saliency-Map-生成显著性时间映射\"><a href=\"#Generation-of-Time-Of-Saliency-Map-生成显著性时间映射\" class=\"headerlink\" title=\"Generation of Time-Of-Saliency Map 生成显著性时间映射\"></a>Generation of Time-Of-Saliency Map 生成显著性时间映射</h3><p>TOS映射是基于2D密度的展示，沿着水平轴的时间和由销售类别（例如，“电子配件”和“衣服”）组织的垂直轴TOS映射均匀分割成行，每个行代表一个销售类别。在图（a）中，由蓝色框突出显示的颜色矩形提供了垂直轴上类别的视觉索引。此外，每行按照<em>时间间隔水平分割</em>。<em>根据其时间戳和销售类别</em>每个事务被投射到相应的单元。投射到同一个单元格的所有事务的显着值相加，并将总和映射到单元格的颜色。色彩映射可以使用默认颜色标度或分析器指定的色标。所得到的TOS映射可视化地为分析任务编码事务的相关性。<em>黑暗区域</em>意味着一组潜在有趣的交易。特别地，连续的暗带表示在一段时间内相应的销售类别中的高度突出的交易（参见图1（a）中的TOS映射中的所选区域）。</p>\n<h3 id=\"Time-Of-Saliency-Exploration-探索显著性时间映射\"><a href=\"#Time-Of-Saliency-Exploration-探索显著性时间映射\" class=\"headerlink\" title=\"Time-Of-Saliency Exploration 探索显著性时间映射\"></a>Time-Of-Saliency Exploration 探索显著性时间映射</h3><p>TOS映射视图中提供了以下交互，可用于完成第一个任务（即识别感兴趣的时段和/或销售类别。）</p>\n<ul>\n<li><p><code>时间窗口</code> TOS映射以分析人员<code>可调节的时间间隔</code>显示交易。可以使用额外的时间窗口小部件来定位视图的特定区域以进行进一步和详细的研究。分析师可以在<code>时间选择栏</code>上单击并拖动以设置TOS映射的时间窗口，如图5（a）中TOS映射顶部的突出显示。图5（b）显示了分析师设置时间窗口后的TOS映射。</p>\n</li>\n<li><p><code>感兴趣的区域</code> 分析师可以点击<code>类别索引</code>（图5（a）中的蓝框）来选择同一类别的交易。 也可以使用<code>套索工具</code>来选择有趣的区域。 当选择一个区域时，将出现一个<code>浮动文本框</code>以显示有关该区域的信息。 所选交易的详细信息可以在第7节中描述的KnotLines视图中进一步可视化和探索。此外，还提供了一个<code>条形图视图</code>（图1（c））以显示所选数据中的类别的销售量。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>Time Windowing</code> The TOS map shows the transactions in an analyst-adjustable time interval. An additional time windowing widget can be used to locate a specific region of the view for further and detailed study. Analysts can click and drag on the time selection bar to set the time window of the TOS map, as highlighted over the top of the TOS map in Figure 5 (a). Figure 5 (b) shows the TOS map after the analyst sets the time window. </p>\n</li>\n<li><p><code>Region-Of-Interest</code> Selection The analysts can click on the category index (the blue box in Figure 5 (a)) to choose the transactions of the same category. A lasso tool can also be used to select interesting regions. When a region is selected, a floating text box will appear to show the information about the region. The detailed information of selected transactions can be further visualized and explored in the KnotLines view described in Section 7. In addition, a bar chart view (Figure 1 (c)) is provided to show the sales volume of categories in the selected data.</p>\n</li>\n</ul>\n<h2 id=\"KNOTLINES-EXAMINING-TRANSACTIONS-IN-DETAIL-详细审查交易\"><a href=\"#KNOTLINES-EXAMINING-TRANSACTIONS-IN-DETAIL-详细审查交易\" class=\"headerlink\" title=\"KNOTLINES: EXAMINING TRANSACTIONS IN DETAIL 详细审查交易\"></a>KNOTLINES: EXAMINING TRANSACTIONS IN DETAIL 详细审查交易</h2><p>KnotLines允许分析师对从TOS映射中选择的显着交易进行详细分析。它旨在解决任务2到任务4。KnotLines可视化显示两种类型的信息：属性和交易的时间趋势。</p>\n<h3 id=\"Data-Organization-and-Visual-Layout-数据组织和视觉布局\"><a href=\"#Data-Organization-and-Visual-Layout-数据组织和视觉布局\" class=\"headerlink\" title=\"Data Organization and Visual Layout 数据组织和视觉布局\"></a>Data Organization and Visual Layout 数据组织和视觉布局</h3><p>为了研究交易之间的属性相似性和时间相关性，所选择的交易集被组织成一个三级分层树（图6）。 首先，我们使用矩阵表来可视化事务的组织，如图7（a）所示。</p>\n<p><img src=\"hierarchical-tree.png\" alt=\"图6\"></p>\n<ul>\n<li><code>一级</code> 整个选定的交易集根据不同的卖家分为N组（1级）。图7（a）中的<em>每一行代表一个组</em>。一组包含卖家的所有交易。这些组沿垂直轴从上到下列出。</li>\n<li><code>二级</code> 一组中的交易根据其时间戳进一步分为子组（2级）。图7（a）中的<em>水平轴表示时间</em>。每行分别对应于M个时间间隔的时间轴上的M个正方形。所有间隔的长度相同，可以调整以探索不同粒度的数据。属于相同时间间隔的卖方的交易形成一个子组（2级）。</li>\n<li><code>三级</code> 根据销售类别（例如，“图书”），将一个子组进一步分为（级别3）。在图7（a）中，每个正方形被分割成K个细胞，每个细胞代表一个部分。同一部分的交易由同一卖方作出，在同一时间间隔内进行，属于同一销售类别。</li>\n</ul>\n<p><code>PS</code>：即三级严格递增，一级是属于同一个卖家，二级属于同一个卖家某段时间，三级属于同一个卖家某段时间的某类销售类别。分别按行，按列，按细胞划分。这个是交易集逻辑上关系，而图7是一种为了方便分析而设计表示该关系的可视化方法。</p>\n<ul>\n<li><code>Level One</code> The whole selected transaction set is divided into N groups (level 1) according to different sellers. Each row in Figure 7 (a) represents a group. A group contains all transactions of a seller. The groups are listed from top to bottom along the vertical axis. </li>\n<li><code>Level Two</code> The transactions in a group are further divided into subgroups (level 2) according to their time stamps. The horizontal axisin Figure 7 (a) represents the time. Each row is split into M squaresalong the time axis which correspond to M time intervals. The lengthsof all intervals are the same and can be adjusted to explore the data at different granularities. Transactions of a seller which fall into the same time interval form a sub-group (level 2).</li>\n<li><code>Level Three</code> A subgroup is further divided into sections (level 3)according to the sales categories (e.g., “Books”). In Figure 7 (a), each square is segmented into K cells, each of which represents a section. Transactions in the same section are made by the same seller, take place in the same time interval, and belong to the same sales category.</li>\n</ul>\n<p><img src=\"visual-organization.png\" alt=\"图7\"></p>\n<p>因为大部分卖家的交易量在一天的时间内可能很高，因此图7（a）所示矩阵中的交易密度可能非常稀疏。 另外，组N的数量可能很大（例如，100万）。 为了使探索更加有效，矩阵式布局应重新设计为更紧凑。</p>\n<p>VAET采用一个简单的两步启发式方案，对每个组进行操作。 </p>\n<ol>\n<li><p>在第一步中，删除第一个非空子组之前和最后一个非空子组之后的空子组。 这个步骤导致许多组仅覆盖水平空间的一小部分，因为它们中的大多数具有短的时间跨度。</p>\n</li>\n<li><p>为了增加空间效率，在第二步中启发式优化组的布局。 迭代布局策略用于满足以下原则： </p>\n<ul>\n<li>整洁：组不应重叠;</li>\n<li>紧凑型：空间利用率高;</li>\n<li>代表：重要群体应优先展示</li>\n</ul>\n</li>\n</ol>\n<p>VAET employs a simple two-step heuristic scheme that operates on each group. In the first step, empty sub-groups before the first nonempty sub-group and after the last non-empty sub-group are removed. This step results in many groups that only cover a small portion of the horizontal space, because most of them have a short time span. To increase the space efficiency, the placement of the groups is heuristically optimized in the second step. An iterative layout strategy is used to satisfy the following principles:</p>\n<ul>\n<li>Uncluttered: groups should not overlap;</li>\n<li>Compact: space utilization should be high;</li>\n<li>Representative: important groups should have a display priority</li>\n</ul>\n<p>分析人士指出， <em>这种设计（即图7）</em> 有几个主要缺点：</p>\n<ul>\n<li>由于部分可能包含数百个交易，可视化严重凌乱。 分析师建议在同一部分内汇总交易;</li>\n<li>分析师认为，紧凑的布局是空间效率高的必需品。 然而，他们很难从这个视图来识别同一卖家所做的交易。需要额外的视觉属性来强调这一重要关系;</li>\n<li>在此视图中没有提供有关交易的重要信息，如付款金额，交易是否缺少值，以及是否经常发生相同的交易。</li>\n</ul>\n<p>The analysts pointed out that there were several major drawbacks in this design: (1) The visualization was seriously cluttered since a section may contain hundreds of transactions. The analysts suggested aggregating transactions within the same section; (2) The analysts agreed that the compact layout was necessary for high space efficiency. However, it was difficult for them to identify transactions made by the same seller from this view. Additional visual attributes were desired to emphasize this important relationship; (3) Important information about the transactions such as payment amount, whether a transaction had missing values, and if identical transactions occurred frequently, was not presented in this view.</p>\n<h3 id=\"KnotLines-（结线）\"><a href=\"#KnotLines-（结线）\" class=\"headerlink\" title=\"KnotLines （结线）\"></a>KnotLines （结线）</h3><p>为了解决上述问题，我们设计了一个增强的视觉隐喻调用KnotLines。它受到音乐符号的启发，这可以被看作是一个改进的散点图，它沿着时间轴放置不同类型的点（音符）。它是时间序列（例如节拍和节奏）及其连接的复杂视觉表示。</p>\n<p>这里就不详细说明了，具体见表2。</p>\n<p><img src=\"Knotlines.png\" alt=\"图8\"></p>\n<p>表2 是Knotlines的可视化各个部分的含义<br>| 图形部分 | 含义|<br>|—-|—-|<br>| 视觉编码 | 交易数据|<br>| 一个knotline | 同一卖家在不同时间的交易（一组）|<br>| 一个knotbunch | 同一卖家在一段时间间隔内进行交易（一个子组）|<br>| 茎长 | 在一段时间内同一卖家的交易总支付金额|<br>| 一个结 | 在一段时间内，同一卖家与同名销售类别的交易（一节）|<br>| 结的颜色 | 该结点的销售类别|<br>| 结的大小 | 该结点的商品数量|<br>| 一个未填充的结点 | 与卖方或买方位置异常的交易|</p>\n<p><img src=\"Visual-Encoding.png\" alt=\"表2\"></p>\n<h3 id=\"Visual-Exploration-可视化探索\"><a href=\"#Visual-Exploration-可视化探索\" class=\"headerlink\" title=\"Visual Exploration 可视化探索\"></a>Visual Exploration 可视化探索</h3><p>除了布局模式的规范和详细结点的调查之外，KnotLines还提供了一套用于分析多个结线的交互。</p>\n<ul>\n<li><code>显着调制</code> KnotLines视图中显示的每个事务都包含一个显着值。 分析师可以显示从2D TOS映射中选择的所有交易，或仅显示显着值大于给定阈值（例如，0.8）的所选交易。 当视图中显示许多节线时，此过滤操作非常有用，因此它支持T2和T3。 图9显示了显着性调制的影响。</li>\n<li><code>查看导航</code> KnotLines视图可以水平放大，以清楚说明，这对T2和T3有帮助。 时间间隔的长度将相应调整。 分析师可以垂直或水平滚动查看更多的knotlines。</li>\n<li><code>兴趣选择结</code> 我们可以通过单击或使用套索工具拖动来选择一组结。 指定结时，会以黄色的圆圈突出显示。 由同一买家制造的相关结也用灰色的圆环突出显示分析师的注意力（图1（b））。 将出现一个浮动文本框，显示所选结的详细信息，如卖方的位置，支付金额和销售类别。 分析员可以在详细视图（图1（e））中的所选结（部分）中检查交易的信息（例如，买方和卖方的位置，子类别和商品编号），其中 是为T2设计的。 对T4有帮助的统计视图（图1（f））用于提供所选结的统计信息，如交易频率和卖方支付金额的趋势。</li>\n<li><code>标签</code> 当特定交易被分析师识别为突出显示时，可以将其添加到标记数据中进行迭代视觉分析和探索。</li>\n</ul>\n<ul>\n<li><p><code>Saliency Modulation</code> Each transaction shown in the KnotLines view contains a saliency value. The analysts can show either all transactions selected from the 2D TOS map or only the selected transactions whose saliency values are larger than a given threshold (e.g., 0.8).This filtering operation is useful when there are many knotlines shown in the view, so it supports T2 and T3. Figure 9 demonstrates the effect of saliency modulation.</p>\n</li>\n<li><p><code>View navigation</code> The KnotLines view can be zoomed horizontally for clear illustration, a function helpful for T2 and T3. The lengths of the time intervals will be adjusted accordingly. Analysts can scroll vertically or horizontally to see more knotlines.</p>\n</li>\n<li><p><code>Knots of Interest Selection</code> We can select a set of knots by clicking, or dragging using a lasso tool. When a knot is specified, it is highlighted with a yellow ring. Related knots which are made by the same buyer are also highlighted with grey rings to draw the analysts’ attention (Figure 1 (b)). A floating text box will appear displaying the detailed information of the selected knot such as the location of the seller, the payment amount, and the sales category. Analysts can check the information of the transactions (e.g., the location of the buyer and the seller, the sub-category, and the commodity number) in the selected knot (section) in the detail view (Figure 1 (e)), which is designed for T2. A statistic view (Figure 1 (f)), which is helpful for T4, is used to present statistical information for the selected knot, such as the trend of the transaction frequency and the payment amount of the seller.</p>\n</li>\n<li><p><code>Labeling</code> When a specific transaction is identified as salient by analysts,it can be added to the labeled data for iterative visual analysis and exploration.</p>\n</li>\n</ul>\n<p><img src=\"VAET-system.png\" alt=\"图1\"></p>\n<h2 id=\"CASE-STUDY-案例研究\"><a href=\"#CASE-STUDY-案例研究\" class=\"headerlink\" title=\"CASE STUDY 案例研究\"></a>CASE STUDY 案例研究</h2><p><code>PS</code>: 这部分应该是论文作者讲述一次真实分析过程，里面有分析的思路与流程，还有该系统的使用特点。</p>\n<p>来自我们的客户 - 客户（C2C）零售业务的数据部门的分析师参与了这项研究。 该公司提供了一个数据集，其中包含2600万个在线电子交易，从中他们想要检测假交易。 约有930万卖家和买家参与了数据集。 他有兴趣通过与合作伙伴买家建立假交易来识别卖家何时积累信用。 异常交易行为的一些指标可能是异常大量的商品，支付金额的大幅变化，特定卖方和买方之间的频繁交易，以及价值超出其正常范围的属性。</p>\n<h3 id=\"Construction-of-Decision-Tree-决策树构建\"><a href=\"#Construction-of-Decision-Tree-决策树构建\" class=\"headerlink\" title=\"Construction of Decision Tree 决策树构建\"></a>Construction of Decision Tree 决策树构建</h3><p>计算每个时间间隔内的卖方的交易频率并将其用作<code>时间特征</code>。 根据由分析者提供并用作文本特征的敏感字典，提取了评论中的<code>关键词</code>和<code>短语</code>（例如“信用”）。我们标注了大约300笔交易，这些交易是使用分层抽样从每个类别中选出的。 我们用标记的数据训练了决策树。 将要分析的交易的提取特征描述作为决策树的<code>输入</code>，并为每个输入产生显着性值。</p>\n<p>我们使用<code>精确率</code>p和<code>召回率</code>r来评估决策树的效率：p = TP /（TP + FP）= 0.89，r = TP /（T P + FN）= 0.92，其中TP，TN，FP和FN 从训练数据的预测结果中计数（见表1）。<br><code>PS:</code> 这几个概念一般用于评估机器学习算法的性能等指标，也是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。 决策树算法在这里的作用只是用来找到显著性值。</p>\n<h3 id=\"Abnormal-Frequency-and-Locations-of-Transactions-异常频率和交易地点\"><a href=\"#Abnormal-Frequency-and-Locations-of-Transactions-异常频率和交易地点\" class=\"headerlink\" title=\"Abnormal Frequency and Locations of Transactions 异常频率和交易地点\"></a>Abnormal Frequency and Locations of Transactions 异常频率和交易地点</h3><p>分析师在简短的培训课程之后开始在TOS映射中进行勘探。他注意到一个具有<code>高度显着性的长长的地区</code>（图10）。随后，分析师指定了时间窗口，并放大到所需的区域。为了进一步研究交易行为，分析师选择了这个地区，发现许多交易在9月19日上午10点被分类为“图书”。分析师注意到连续的红色结在图1（b）的连线上连接。他告诉我们，<em>这种模式表明卖家在选定的时间间隔内频繁交易</em>。经查核详细资料后，分析师发现这些交易属于“充值卡”类别，并由<em>不同的买家</em>组成。他评论说，这可能是一个促销活动，因为他在这些交易中没有发现异常信息。分析师将显着阈值增加到0.8，<code>显着调制滑块</code>（Saliency Modulation）。<em>这使得分析师能够有效地过滤出许多不太显着的交易</em>。分析师立即找到多个未填充的结，指示具有缺失值的交易。他评论说，使用未填充的结来呈现缺失值的交易有效地吸引了他的注意。为了进一步调查这些记录是否表示促销或假交易，分析师进行了进一步分析。<em>当他点击这条结线中的一个未填充的结时，同一个结线中的许多其他结被突出显示</em>（图1（b）），表明这些结的大部分交易是由同一买方和卖方进行的。分析师注意到，详细信息视图中，买方的交货地址为空，通过查看此结线中的结的详细信息（图1（e））。他评论说这是可疑的，因为如果买方不填写他的地址，买家就不会买到这个商品。通过查看结的交易历史（图1（f）），分析师发现，卖方的销售额在一段时间内急剧增加。</p>\n<p>分析师认为这些交易可能与赚取<code>信用</code>有关。 该结论由数据提供商的商业智能部门的分析师进行了验证，他们检查了与交易相关的其他信息，如卖方和买方的IP地址。 他们解释说，这些交易是由一组帮助卖家增加<code>信用</code>的买家进行的，卖家没有真正交付产品。 分析师将这一结线中的交易标示为<code>显着</code>，并将它们添加到训练数据集中。</p>\n<p><img src=\"salient-transactions.png\" alt=\"图10\"></p>\n<p><img src=\"VAET-system.png\" alt=\"图1\"></p>\n<h3 id=\"Abnormal-Attribute-Values-of-Transactions-交易的异常属性值\"><a href=\"#Abnormal-Attribute-Values-of-Transactions-交易的异常属性值\" class=\"headerlink\" title=\"Abnormal Attribute Values of Transactions 交易的异常属性值\"></a>Abnormal Attribute Values of Transactions 交易的异常属性值</h3><p>分析师在TOS映射中选择了另一个时间窗口。通过查看<code>条形图</code>视图中的销售类别信息（图11（a）），分析师发现，“电子配件”类别中销售的商品总数远远大于其他销售类别。<em>分析师认为，由于商品数量庞大，这将是促销活动</em>。他在<code>knotline</code>视图中调查了这个假设，但没有发现任何包含频繁连续的“电子配件”结。</p>\n<p>分析师在TOS映射中选择了此类别，以过滤掉不相关的类别。通过仔细检查剩余的结，分析师发现一个具有短茎的极大的结（图11（b）），表明一个较大的商品数量，总支付金额却较低。分析师告诉我们，“<em>通过这种knotline，我第一眼就注意到支付和商品数量之间的异常关系</em>”。结的详细视图（图11（c））显示，本节包含单笔交易，支付金额仅为10美分，商品却为22万件。通过进一步调查卖方的交易历史（图11（d）），分析师消除了销售促销的概率，因为卖方在一段时间内交易次数很少，表明销售商品很少。分析师认为这是一个事件，卖方试图根据已经出售的商品数量增加他们的互联网搜索排名。<em>分析师还将该交易标注为显着，并将其添加到训练数据集</em>。</p>\n<p><img src=\"fig11.png\" alt=\"图11\"></p>\n<h2 id=\"USER-STUDY-用户研究\"><a href=\"#USER-STUDY-用户研究\" class=\"headerlink\" title=\"USER STUDY 用户研究\"></a>USER STUDY 用户研究</h2><p>我们进行了用户研究，<em>以评估VAET支持低级别分析任务的能力</em>，即第3节中讨论的T1-T4。所使用的数据集是第8节（即上一节）中探讨的交易数据集。</p>\n<h3 id=\"Design-设计\"><a href=\"#Design-设计\" class=\"headerlink\" title=\"Design 设计\"></a>Design 设计</h3><p>10名参与者（6名男性和4名女性）年龄介于21岁至35岁之间进行了用户研究。 其中两人是分析师，其他人则是研究生。 所有参与者都具有使用在线商务的经验，并且对电脑熟悉。 学生的专业包括计算机科学，设计，数学和生物学。 以前他们都没有使用过VAET。</p>\n<p>参与者一个接一个地参加研究。 对于每个参与者，在测试部分之前进行了短暂的训练。 在培训部分，教练首先向参与者介绍了VAET的25分钟演示。 在演示过程中，教练解释了VAET的视觉设计和功能。 在演示之后，参与者在教练的帮助下练习了VAET提供的互动5分钟。 在测试部分，参与者被要求完成9次练习，与实际分析中遇到的练习类似，无需教练帮助。 然后，他们被要求通过回答问卷并提供主观反馈来评估系统。</p>\n<p>这9个练习是针对三种不同的具体情况而设计的，其中两项是在第8节中描述的。每个低级任务都通过一项或多项练习进行评估。 他们评估的练习和任务如下（任务显示在括号中）：</p>\n<ul>\n<li>E1 “使用TOS映射，从9月21日上午9点至10点选择具有最高显着性的销售类别。”目标：确定TOS映射（T1）中感兴趣的时间段和销售类别。</li>\n</ul>\n<p>E2和E3来自第8.3节所述的情况。</p>\n<ul>\n<li><p>E2 “选择商品数量最大的销售类别”。目标：解释条形图并确定感兴趣的销售类别（T1）。</p>\n</li>\n<li><p>E3 “查找KnotLines中商品数量最多的交易。”目标：解释一个结的视觉编码，并识别具有特定属性（T2）的有趣模式的交易。</p>\n</li>\n</ul>\n<p>要完成E4-E6，参加者将被要求在9月19日晚上18点至19点之间设置时间，并选择“充值卡”。</p>\n<ul>\n<li><p>E4 “从KnotLines视图中找到具有最高交易频率的卖家（knotline）”。目标：解释knotline的视觉编码，并识别有趣的交易模式（T3）的卖家。</p>\n</li>\n<li><p>E5 “在KnotLines视图中，哪些卖方的交易模式不会发生？ （a）大量商品的单笔交易，但支付金额很小。 （b）低频连续交易。 （c）持续交易频率高，支付金额小。 （d）我不知道。“目标：解释这个knotlines和识别有趣的卖家交易模式（T3）。</p>\n</li>\n<li><p>E6 “E4中卖方交易历史的一个特征是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：以统计视角检查卖方的行为（T4）。</p>\n</li>\n</ul>\n<p>E7 - E9与8.2节描述的情况相同。 </p>\n<ul>\n<li><p>E7 “在KnotLines视图中查找未填充的结，并报告买方城市。”目标：使用详细信息视图（T2）检查事务的属性值。</p>\n</li>\n<li><p>E8 “E7中确定的卖方交易历史的主要特点是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：使用统计视图检查卖方的行为（T4）。</p>\n</li>\n<li><p>E9 “E7中确定的卖方的交易行为是什么？ （a）具有大量商品编号的单一交易。 （b）付款金额低的频繁交易。 （c）与异常购买城市频繁交易。“目标：解释和检查KnotLines（T4）的卖方交易模式。</p>\n</li>\n</ul>\n<p>E1 “Choose the sales category with the highest saliency value from 9 am to 10 am on September 21 using the TOS map.” Objective: Identify time periods and sales categories of interest in the TOS map (T1).</p>\n<p>E2 and E3 were from the case described in Section 8.3.</p>\n<p>E2 “Choose the sales category with the largest commodity number.” Objective: Interpret the bar chart and identify sales categories of interest (T1).</p>\n<p>E3 “Find the transaction with the largest number of commodities in KnotLines.” Objective: Interpret the visual encoding of a knot and identify transactions with interesting patterns in specific attributes (T2).</p>\n<p>To finish E4 - E6, participants were asked to set the time between 18 pm and 19 pm on September 19, and choose “Top-up Card”.</p>\n<p>E4 “Find the seller (knotline) with the highest transaction frequency from the KnotLines view.” Objective: Interpret the visual encoding of a knotline and identify sellers with interesting transaction patterns (T3).</p>\n<p>E5 “In the KnotLines view, which transaction pattern of the seller does not occur? (a) Single transaction with a large number of commodities but a small payment amount. (b) Continuous transactions with low frequency. (c) Continuous transactions with high frequency and a small payment amount. (d) I don’t know.” Objective: Interpret the knotlines and identify interesting seller transaction patterns (T3). </p>\n<p>E6 “Which is a feature of the seller transaction history of the knot in E4? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden, frequent transactions.” Objective: Examine the seller’s behavior in the statistic view (T4). </p>\n<p>E7 - E9 were the same case described in Section 8.2.</p>\n<p>E7 “Find unfilled knots in the KnotLines view and report the buyer cities of them.” Objective: Examine the attribute values of the transactions using the detailed information view (T2). </p>\n<p>E8 “What is the main feature of the seller’s transaction history of the knot identified in E7? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden ,frequent transactions.” Objective: Examine the seller’s behavior using the statistic view (T4).</p>\n<p>E9 “What is the transaction behavior of the seller identified in E7? (a) A single transaction with a large commodity number. (b) Frequent transactions with low payment amounts. (c) Frequent transactions with abnormal buyer cities.” Objective: Interpret and examine the seller’s transaction patterns from KnotLines (T4).</p>\n<p>练习结束后，参加者完成了由6个问题组成的调查问卷（Q1〜Q6）。 要求用1到5评估等级（1=非常简单或高效，5=非常困难或低效），<em>学习该VAET系统的难度和VAET的效率</em>。 这些问题也收集到主观反馈。 六个问题如下：</p>\n<ol>\n<li>容易或难以学习TOS映射？</li>\n<li>使用TOS映射探索显着数据是否有效？</li>\n<li>单个结的<code>视觉编码</code>是否容易或难以解释？</li>\n<li>KnotLines的视觉编码和布局是否容易或难以解释？</li>\n<li>使用KnotLines分析用户交易模式是否有效？</li>\n<li>使用VAET整体分析多用户行为是否容易或困难？</li>\n</ol>\n<hr>\n<ol>\n<li>Is it easy or hard to learn the TOS map?</li>\n<li>Is it efficient or not to explore salient data with the TOS map?</li>\n<li>Is it easy or hard to interpret the visual encoding of a single knot?</li>\n<li>Is it easy or hard to interpret the visual encoding and layout of KnotLines?</li>\n<li>Is it efficient or not to analyze the user transaction patterns with KnotLines?</li>\n<li>Is it easy or hard to analyze multi-user behavior with VAET as a whole?</li>\n</ol>\n<h3 id=\"Results-结果\"><a href=\"#Results-结果\" class=\"headerlink\" title=\"Results 结果\"></a>Results 结果</h3><p>收集9次练习的准确性和时间进行评估</p>\n<p>总体来说，参加者完成了练习，在90次全部练习中产生5次错误（精准度为94.4％）。分析师正确回答了所有问题。对于学生参与者，其中两人在E5上出错，E8上有两个错，E9上有一个错。</p>\n<p>我们采访了E5的错误参与者。他们都说他们“只注意到knotlines的主要模式，忽略了发生较少的模式”。但是，他们没有解释用户行为的问题。回答E8的参与者错误地提到他们忘记检查统计视图中显示的卖家历史信息（图1（f）），而是根据KnotLines视图回答问题。在E9错误的参与者认为，零买家城市（null buyer cities）对于不需要交货地址的电子书等虚拟商品的交易是正常的。事实上，“图书”类别中的所有商品都是实物。虽然一些参与者有T3和T4的问题，但总体准确性表明VAET可以很好地支持任务。</p>\n<p>Overall, the participants completed the exercises, yielding 5 mistakes out of the 90 total exercises (94.4% accuracy). The analysts answered all questions correctly. As for the student participants, two of them erred on E5, two erred on E8 and one erred on E9. </p>\n<p>We interviewed the participants who erred on E5. They both said that they “only noticed the main patterns of the knotlines and ignored the patterns with fewer occurrence”. However, they had no problem interpreting the user behavior from them. The participants who answered E8 incorrectly mentioned that they forgot to check the seller history information shown in the statistic view (Figure 1(f)) and answered the question based on the KnotLines view instead. The participant who erred on E9 thought that null buyer cities are normal for transactions of virtual commodities such as E-books, which do not need delivery addresses. In fact, all commodities in the “Books” category are real items. Although some participants had problems with T3 and T4, the overall accuracy indicates that VAET supports the tasks well.</p>\n<p>图12显示了每次锻炼的完成时间的平均值和标准偏差。 E3，E4和E7的时间比其他问题的时间长。 这三个练习要求参与者搜索具有特定特征的knotlines，这可能需要更多的时间仔细检查视图。 参与者能够快速完成其他6个问题。 完成时间为5.14s至44.22s。 分析师花费的时间远远少于学生参与者。 总体而言，VAET允许大多数参与者在90秒内完成复杂的练习和任务（如E4和T3）。 在考虑交易的各种属性以及它们之间的关系时，这是相当快的。</p>\n<p><img src=\"fig12.png\" alt=\"图12\"></p>\n<p>分析师的反馈与讨论</p>\n<p>在用户研究结束时，我们采访了分析师和其他参与者。 两位分析师都对分类结果感到满意。 他们评论说，在分析不同类型的交易时，特征提取和决策树的集成是高效和灵活的。 我们要求他们将决策树与之前使用的逻辑回归进行比较。 他们认为我们的模型有几个优点：</p>\n<ul>\n<li>决策树对于分析师来说很简单易懂。</li>\n<li>在处理属性的缺失值时，决策树比逻辑回归更强大。</li>\n<li>使用决策树的分类比逻辑回归更快。 </li>\n</ul>\n<p>他认为我们可以通过使用更多的信息来改进我们的方法，比如今后买家和卖家的IP地址。</p>\n<p>他们评论说，TOS映射是直观的，勘探方便。一位分析师表示：“KnotLines的多用户行为的可视化是创造性和生动的。”<em>虽然一位分析师认为该系统很难学习，但很少参与者难以解释可视化</em>，大多数人能够在简短的培训会议后找到有趣的交易。两位分析师都提到，VAET能够帮助他们探索未被发现的交易模式。这是至关重要的，因为“欺骗人总是不断改变伎俩”。他们认为，VAET有能力找到新兴的交易模式，并帮助他们改进数据模型。分析师们渴望将VAET用于实际的多用户应用程序，在这些应用程序中，他们发现许多高维度事务之间的上下文和时间相关性。有趣的是，一些参与者最初认为使用我们的系统需要基本的音乐知识。其他与会者提到，他们对音乐笔记的了解影响了对设计的理解。例如，茎长度固定在音符中，但在我们的设计中是可变的。此外，有些人认为与其他knotbunches（类似于四分之一音符）没有连接的单个knotbunch持续比连接的knotbunch短（类似于第八个音符）。事实是，交易没有持续时间，因为它们都是立即在线发生的。与会者告诉我们，在他们学会如何解读设计之后，这种差异并没有妨碍他们的分析。</p>\n<h2 id=\"CONCLUSION-总结\"><a href=\"#CONCLUSION-总结\" class=\"headerlink\" title=\"CONCLUSION 总结\"></a>CONCLUSION 总结</h2><p>本文提出了一种用于识别基本交易数据和研究<em>大片碎片记录</em>的<code>时间</code>或<code>集体行为</code>的新型视觉探索方案。 在对KnotLines进行选择交易的详细探索和推理之前，执行决策树算法和TOS映射的过滤过程，以从大量记录中选择潜在有趣的交易。 案例研究和用户研究证实，VAET可以有效地支持大部分任务。 根据结果，一些任务如T3需要更好地解决，因为交易模式可以是<code>动态的</code>和<code>多层次的</code>。 为了使VAET更容易学习和使用，我们希望使TOS映射和KnotLines的设计更加直观。 对于未来的工作，我们也希望对更多的数据集进行扩展。</p>\n<p>This paper presents a novel visual exploration scheme for identifying elementary transaction data and studying the temporal or collective behavior from large pieces of fragmented records. Prior to detailed exploration and reasoning of the chosen transactions with KnotLines, a decision tree algorithm and a filtering process by TOS map are performed to choose potentially interesting transactions from a huge amount of records. The case study and the user study verify that VAET can effectively support most of the tasks. According to the result, some tasks such as T3 need to be better addressed as the patterns of transactions can be dynamic and multi-level. To make VAET easier to learn and use, we would like to make the design of TOS map and KnotLines more intuitive. For future work, we also would like to extend our approach for more datasets.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"VAET-A-Visual-Analytics-Approach-for-E-transactions-Time-Series-电子交易时间序列的一种可视化分析方法\"><a href=\"#VAET-A-Visual-Analytics-Approach-for-E-transactions-Time-Series-电子交易时间序列的一种可视化分析方法\" class=\"headerlink\" title=\"VAET: A Visual Analytics Approach for E-transactions Time-Series  电子交易时间序列的一种可视化分析方法\"></a>VAET: A Visual Analytics Approach for E-transactions Time-Series  电子交易时间序列的一种可视化分析方法</h1><blockquote>\n<p>Cong Xie, Wei Chen, Member, IEEE, Xinxin Huang, Yueqi Hu, Scott Barlowe, and Jing Yang</p>\n</blockquote>\n<p>创新实践的论文阅读作业，翻译了主要内容，加上部分自己的理解并修改部分内容，保留了部分原文，有时候阅读原文更好理解。全文按照论文组织的方式编写，主要是为了理清楚论文的主要思想，并可以简单地给其他人做宏观上的解释，达到基本的教学目的。此文将作为ppt的前稿。</p>\n<hr>","more":"<p><img src=\"VAET-system.png\" alt=\"图1\"></p>\n<h2 id=\"INTRODUCTION-介绍\"><a href=\"#INTRODUCTION-介绍\" class=\"headerlink\" title=\"INTRODUCTION 介绍\"></a>INTRODUCTION 介绍</h2><p>The E-transaction time-series contains transactions among multiple users in a time range. Each record contains a time stamp, the IDs of the seller and buyer, and the associated attributes of the commodities. Each record is an atomic element representing an online transaction among a seller and a buyer.</p>\n<p>电子交易时间序列包含时间范围内的多个用户之间的交易。 每个记录都包含时间戳，卖方和买方的ID以及相关联的商品的属性。每个卖方和买方之间的网上交易记录都是一个原子元素。</p>\n<p><em>在时间上下文中分析电子交易时间序列至关重要了解交易行为，学习用户偏好和发现时间趋势。</em></p>\n<p>通过面试分析师发现以下一些问题常常很难回答：</p>\n<ul>\n<li>卖方的多个交易之间的时间和<code>上下文</code>关系是什么？比如短时间内有个卖家有大量的交易，而且可能来自某个买家，分析师需要发现这样的交易的各种属性。</li>\n<li>最常见的交易模式是什么？比如平时工作日交易比较稀疏，但是圣诞节交易比较频繁。</li>\n<li>如何识别<code>有趣</code>的交易？比如买家勾结来加速影响卖家的信用，一旦这样的模式定义好了，分析师需要在相关的大量数据集中找到特定属性值来挖掘这样的交易。</li>\n<li>如何在上下文检测某个交易？比如小额购买巨量的商品可能是个假的交易，利用它来提升卖家排名。为了确认交易是假的，分析师需要将交易与买方和卖方的信息关联。</li>\n</ul>\n<p>我们认为，自动数据挖掘过程在回答上述问题时并没有足够的灵活性和准确性。<br>因此迫切需要视觉分析方法，使分析人员能够通过集成计算能力，人类知觉能力和领域知识，通过即时视觉反馈灵活地形成和测试假设。</p>\n<p>目前还没有适用于上述情况的可视化方法。<br>多变量时间序列可视化的现有研究工作主要集中在总结多维度的全局和/或时间趋势或发现个体维度的模式，如Sparklines。</p>\n<p>因此提出了一种新颖的视觉分析系统，称为电子交易时间序列的视觉分析（VAET），旨在探索电子交易时间序列，以便在时间上下文中分析多个用户之间的交易模式。<br>VAET有如下2个主要的可视化分析组件：</p>\n<ul>\n<li>Overview: This component helps the analysts effectively identify salient transactions from a large dataset. 该组件帮助分析师在大量数据集中快速找到突出的交易。VAET使用概率决策树学习器首先计算每个交易的显着性值，以揭示其与分析目标的相关性（例如，作为假交易的可能性）。然后，显着值显示在一个称为<code>显着时间映射</code>（TOS）的像素方向的显示中。该映射提供了一个工作空间来探索和选择不同时间粒度的潜在有趣的交易;</li>\n<li>Detail view：This component allows the analysts to conduct detailed examination on interesting transactions for insights. 该组件允许分析人员对感兴趣的交易进行仔细检查，以获取见解。特别地，从概述中选择的交易使用称为<code>KnotLines</code>的新的视觉隐喻来显示。协调TOS映射和KnotLines，以便分析人员可以快速识别来自大型数据集的有趣事务。</li>\n</ul>\n<p>A case study and a user study with a real online transaction dataset demonstrated that VAET was effective in supporting a variety of analysis tasks.<br>真实在线交易数据集的案例研究和用户研究表明，VAET有效支持各种分析任务。</p>\n<p>VAET的主要贡献包括：</p>\n<ul>\n<li>视觉分析系统，允许分析人员在时间上有效地分析大型电子交易时间序列;</li>\n<li>从大型数据集中检测和可视化突出事务的方法;</li>\n<li>一种新颖的视觉隐喻，用于紧凑地放置和编码特征属性以及多用户事务的时间和上下文相关性</li>\n</ul>\n<h2 id=\"RELATED-WORK-相关工作\"><a href=\"#RELATED-WORK-相关工作\" class=\"headerlink\" title=\"RELATED WORK 相关工作\"></a>RELATED WORK 相关工作</h2><h3 id=\"Visual-Analysis-of-E-transaction-Data-电子交易数据的可视化分析\"><a href=\"#Visual-Analysis-of-E-transaction-Data-电子交易数据的可视化分析\" class=\"headerlink\" title=\"Visual Analysis of E-transaction Data 电子交易数据的可视化分析\"></a>Visual Analysis of E-transaction Data 电子交易数据的可视化分析</h3><p>以下是之前一些人做的过相关研究（寻找合适的可视化方法来展示交易数据）</p>\n<p>The transaction data contains various types of attributes, such as numerical, temporal and categorical. The Sparklines [23] can be used to visualize multiple trends in financial data. Liu et al. [11] proposed a visualization system called SellTrend for analyzing airline travel purchase requests. WireVis [3] was proposed to search on predefined patterns in large wire transaction datasets. Visual analytics approaches have been proposed to explore web clickstreams of online transactions [26]. Our approach is among the earliest visual analytics approaches for the exploration of temporal and contextual connections in multiuser transactions.</p>\n<p>Transaction data often have multi-dimensional attributes. Analyzing them often requires the integration of well-designed data mining models. <em>Probabilistic models are employed to model user behavior [12], resulting in user clusters. This scheme has been successfully applied to classify E-transaction data into different types [2].</em> Association analysis is another widely used model for transaction data. Hao et al. [7] proposed the DAV system to visualize the relationships of associated products.</p>\n<h3 id=\"Visual-Analysis-of-User-Behavior-Time-Series-用户行为时间序列的可视化分析\"><a href=\"#Visual-Analysis-of-User-Behavior-Time-Series-用户行为时间序列的可视化分析\" class=\"headerlink\" title=\"Visual Analysis of User Behavior Time-Series 用户行为时间序列的可视化分析\"></a>Visual Analysis of User Behavior Time-Series 用户行为时间序列的可视化分析</h3><p>以前有很多关于用户行为时间序列分析和可视化的作品。这里我们只总结最相关的一些，并将它们分类为分析个人行为，用户交互和组行为的技术。</p>\n<p><code>Temporal Individual Behavior Patterns</code> Many visualization approaches designed to analyze user behavior data are focused on exploring the temporal behavior patterns of individuals.<br>旨在分析用户行为数据的许多可视化方法都集中在探索个人的时间行为模式。<br>TimeSearcher [8] allows users to select interesting time-series using a rectangular query region. LifeLines [16] visualizes health-related incidents of patients along a timeline. Most previous works utilize high-dimensional visual exploration tools such as parallel coordinates [4] to explore extracted patterns. Density-based display techniques [6], [10] are capable of showing large time-series datasets for real-time monitoring. Additional visual exploration techniques include time trajectory [21] and [13].</p>\n<p><code>User Interaction Patterns</code> conventional solutions consider the user network as a social network and analyze its global structure<br>常规解决方案将用户网络视为社会网络，并分析其全局结构。<br>Sallaberry et al. [20] provide an overview of dynamic network evolution over time. Other approaches emphasize the user interaction characteristics such as email connections [25] and instant messages [27]. However, these methods are focused on the structural changes rather than the temporal variations of the interactions. Other approaches aim to reveal the relationships among multiple users in a temporal context. For instance, Storyline [22] shows the narrative threads that form a plot or a subplot in works of fiction. The history flow approach successfully reveals author collaboration patterns [24]. Code Swarm [15] visualizes the animated histories of software project evolution. VAET reveals both the temporal patterns of multi-user behavior and their atomic level correlations. It improves the above approaches by allowing the analysts to explore a large number of transactions at different granularities.</p>\n<h2 id=\"Problem-definition-问题定义\"><a href=\"#Problem-definition-问题定义\" class=\"headerlink\" title=\"Problem definition 问题定义\"></a>Problem definition 问题定义</h2><blockquote>\n<p>Multi-user transaction data is a special type of user behavior data with a focus on characterizing raw, detailed, and subtle inter-user transactions. An E-transaction time-series dataset contains information about each E-transaction, including information about transaction time, the buyer, and the seller. Each E-transaction records a transaction between a buyer and a seller.</p>\n</blockquote>\n<p>多用户事务数据是一种特殊类型的用户行为数据，重点是描述原始，详细和微妙的用户间交易。电子交易时间序列数据集包含每个电子交易的信息，包括有关交易时间，买方和卖方的信息。 每个电子交易记录买方和卖方之间的交易。</p>\n<p>一般来说，一个电子交易包含以下属性：</p>\n<ul>\n<li><p><code>User information</code> includes the IDs and other information about the buyer and the seller who make the transaction, e.g., their age group, gender, and location.</p>\n</li>\n<li><p><code>Transaction information</code> includes the time stamp and other information about the commodities, e.g., the payment amount, the number, and the sales category of the commodity.</p>\n</li>\n</ul>\n<p>The above attributes can be numerical, ordinal, categorical, textual, or temporal.<br>上述属性可以是数字，序数，分类，文本或时间。</p>\n<p>分析师通常通过一系列低级别任务进行复杂的任务。 这些任务通常关注卖方的行为，例如：</p>\n<ul>\n<li>识别感兴趣的时段和/或销售类别。</li>\n<li>识别具有特定属性的有趣模式的交易（例如，支付金额≥500）并检查其详细信息。</li>\n<li>识别具有有趣交易模式的卖家，例如卖家以小额付款金额进行频繁交易。</li>\n<li>检查特定卖家的交易模式</li>\n</ul>\n<p>The analysts usually conduct a complex task through a set of low level tasks. These tasks typically focus on the behavior of the seller, such as:</p>\n<ul>\n<li>T1 Identifying time periods and/or sales categories of interest.</li>\n<li>T2 Identifying transactions with interesting patterns in specific attributes(e.g., payment amount ≥ 500) and examining their detailed information.</li>\n<li>T3 Identifying sellers with interesting transaction patterns, such as a seller making frequent transactions with small payment amounts.</li>\n<li>T4 Examining the transaction patterns of a specific seller</li>\n</ul>\n<p>我们使用术语<code>显着</code>定量地描述交易与分析师定义的目标的相关程度。根据调查，识别和审查突出交易是电子交易时间序列探索中至关重要但具有挑战性的任务。通常，分析师需要通过迭代查询数据集并检查检索到的事务之间的属性值和关系来手动识别突出事务。此外，分析师经常需要检查突出交易以及用户的历史数据等信息，以证明其行为或揭示有趣的模式。这个过程通常是费力和乏味的。VAET旨在简化此过程，提高整体运行效率。（VAET is designed to ease this process and improve the overall operation efficiency.）</p>\n<h2 id=\"APPROACH-OVERVIEW-方法概览\"><a href=\"#APPROACH-OVERVIEW-方法概览\" class=\"headerlink\" title=\"APPROACH OVERVIEW 方法概览\"></a>APPROACH OVERVIEW 方法概览</h2><p>The goal of VAET is to identify and explore interesting transactions by selecting those with high saliency and studying them. This is accomplished by integrating the capabilities of both data mining and visualization techniques within the following iterative visual exploration pipeline.</p>\n<p>VAET的目标是通过选择具有高度显着性并研究它们来识别和探索有趣的交易。这是通过将数据挖掘和可视化技术的功能集成在以下迭代视觉探索流程中来实现的。</p>\n<ul>\n<li><p>步骤1，使用决策树的显着计算：从每个事务中提取一组特征。分析人员将某些交易的功能手动标记为训练数据。使用这些特征，在训练数据上构建概率决策树学习器。然后用它来产生每个未标记交易的显着值（图2（b））。</p>\n</li>\n<li><p>步骤2，使用TOS映射进行浏览和选择：所有事务的显着性值映射到紧凑的基于密度的生存时间（TOS）映射。在此映射中，交易按时间和类别排序，并以颜色对应于显着值的像素表示。分析师可以交互地探索映射，调查全球分布和地域格局，并选择根据这个观点的显着性值，有趣的交易。（图2（c））。</p>\n</li>\n<li><p>步骤3，使用KnotLines进行详细分析：分析师选择的交易通过一种新颖的视觉隐喻<code>KnotLines</code>可视化，允许研究多个属性和上下文连接（图2（d））。分析人员确定为突出事务的交易可以被标记并反馈到步骤1以继续迭代过程（图2（e））。</p>\n</li>\n</ul>\n<ul>\n<li>Step 1 Saliency computation with decision tree: A set of features are extracted from each transaction. The analysts manually label the features of some transactions as the training data. Using these features, a probabilistic decision tree learner is constructed upon the training data. It is then employed to produce the saliency values for each unlabeled transaction (Figure 2 (b)).</li>\n<li>Step 2 Browsing and selection using the TOS map: The saliencyvalues of all transactions are mapped to a compact, density-based Time-Of-Saliency (TOS) map. In this map, transactions are ordered by time and categories and represented by pixels whose colors correspond to saliency values. The analysts can interactively explore the map, investigate the global distribution and local patterns, and select interesting transactions according to the saliency values from this view. (Figure 2 (c)).</li>\n<li>Step 3 Detailed analysis using KnotLines: The analyst-selected transactions are visualized with a novel visual metaphor, KnotLines, that allows the study of multiple attributes and contextual connections (Figure 2 (d)). The transactions identified as salient by the analysts can be labeled and fed back into Step 1 to continue the iterative process (Figure 2 (e)).</li>\n</ul>\n<p>分析人员可以通过调整标记的数据集，导航映射和探索有趣的交易来迭代地循环上述步骤。 TOS映射和KnotLines可视化提供可扩展的探索，如时间间隔选择和详细审查。</p>\n<p><img src=\"VAET-overview.png\" alt=\"图2\"></p>\n<h2 id=\"SALIENCY-COMPUTATION-WITH-DECISION-TREE-决策树的显著性计算\"><a href=\"#SALIENCY-COMPUTATION-WITH-DECISION-TREE-决策树的显著性计算\" class=\"headerlink\" title=\"SALIENCY COMPUTATION WITH DECISION TREE 决策树的显著性计算\"></a>SALIENCY COMPUTATION WITH DECISION TREE 决策树的显著性计算</h2><p>计算显着性值本质上是上下文感知和任务定位的。 对于许多任务，显着性值不能直接从事务属性导出。 例如，当分析师搜索异常交易时，往往需要考虑卖方的交易频率。 让分析人员手动指定每个交易的显着性值也是不切实际的。 因此，我们建议通过定义和计算一组交易的特征来计算每个记录的显着性值。特别地，我们的方法通过<code>概率决策树</code>计算显着值作为概率估计问题。 我们选择决策树，因为它可以处理连续和分类的属性，很容易解释。 决策树最初由一组分析师确定的训练数据的特征构建。 将决策树应用于每个未标记事务的特征，产生的概率范围为0到1，用作底层事务的显着值。 分析师手动标记为交易的交易可以在随后的分析中添加到训练数据集中（图2（e））。</p>\n<h3 id=\"Feature-Extraction-特征提取\"><a href=\"#Feature-Extraction-特征提取\" class=\"headerlink\" title=\"Feature Extraction 特征提取\"></a>Feature Extraction 特征提取</h3><p>VAET计算一组分析师指定的每个事务的时间和上下文特征作为一组特征。 一般来说，定义了三种类型的特征：</p>\n<ul>\n<li><code>基本特征</code> 确定交易是否有趣的一个直接方法是使用指定属性的值作为基本特征，例如商品的支付金额。另外，分析人员可以定义新的属性。例如，如果卖家在分析师给出的有趣的列表中，则他或她被视为显着的卖家，如图3所示。这些属性的集合构成一组基本功能。</li>\n<li><code>文本功能</code> 交易可以包含文本信息，例如商品的评论。 VAET检查文本信息是否包含分析师指定列表中的敏感词。分析人员保留一个字典，用于从过去几个月手动收集敏感的词汇和短语。例如，在一种欺诈交易中，买家希望尽快回收现金。 “现金回馈”是一个敏感的短语。敏感词在不同的情况下有所不同，可以视为文字特征。</li>\n<li><p><code>时间特征</code> 交易序列的时间模式对于识别数据集中的有趣模式至关重要。例如，卖方在时间间隔内的交易金额表示他或她的受欢迎程度。然而，以传统的决策树方法难以发现面向时间的关系。为了解决这个问题，VAET使用卖方在每个时间间隔的交易频率作为衡量时间趋势。时间间隔的大小取决于数据收集配置。</p>\n</li>\n<li><p><code>Basic Features</code> One straightforward way to determine whether a transaction is interesting is to use the values of specified attributes as basic features, such as the payment amount of a commodity. In addition, the analysts can define new attributes. For example, if a seller is in the interesting list given by the analyst, he or she is considered as a salient seller, as shown in <em>Figure 3</em>. The collection of these attributes constructs a set of basic features. </p>\n</li>\n<li><code>Textual Features</code> A transaction may contain textual information, such as the comment of a commodity. VAET examines whether the textual information contains sensitive words in a analyst-specified list. The analysts keep a dictionary for sensitive words and phrases collected manually from the past several months. For example, in a kind of fraud transactions, the buyers want their cash back as soon as possible. “cash back” is a sensitive phrase here. Sensitive words vary in different situations, and can be regarded as textual features. </li>\n<li><code>Temporal Features</code> Temporal patterns of a sequence of transactions are essential for identifying interesting patterns in the datasets. For example, the transaction amount of a seller in a time interval indicates his or her popularity. However, time-oriented relations are difficult to discover with conventional decision tree approaches. To address this problem, VAET uses the transaction frequency of the seller in every time interval as a measure of the temporal trend. The size of the time interval depends on the data collection configuration.</li>\n</ul>\n<p><img src=\"feature-extraction.png\" alt=\"图3\"></p>\n<h3 id=\"Estimating-saliency-using-Probabilistic-Decision-Tree-使用概率决策树估计显着性\"><a href=\"#Estimating-saliency-using-Probabilistic-Decision-Tree-使用概率决策树估计显着性\" class=\"headerlink\" title=\"Estimating saliency using Probabilistic Decision Tree 使用概率决策树估计显着性\"></a>Estimating saliency using Probabilistic Decision Tree 使用概率决策树估计显着性</h3><p>决策树最初使用训练数据集构建，该数据集由分析师标记的交易的提取功能组成。 如图2（e）所示，可以通过添加分析员标识的事务，在可视化探索过程中手动更新训练数据集。 在我们的方法中，使用完善的C4.5算法从训练数据中自动构建决策树，其根据特征将训练集递归地分解为子集。 在决策树中（参见图4的示例），叶子节点表示类（显着或非显着2个类别），内部节点对应于特征。 在每个内部节点处，C4.5根据产生<code>最高归一化信息增益</code>（highest normalized information gain）的特征将样本分解为子集，并将特征分配给该节点</p>\n<p><img src=\"decision-tree.png\" alt=\"图4\"></p>\n<p>概率根据决策树叶上的交易进行估计。 我们将FP表示为叶上的假阳数，T P表示真阳数（见图5中的混淆矩阵）。 叶上的概率分布估计由下式给出:</p>\n<p>P(y|x) = TP / (TP + FP)</p>\n<p><img src=\"confusion-matrix.png\" alt=\"表1\"></p>\n<h2 id=\"TIME-OF-SALIENCY-MAP-BROWSING-A-LARGE-SET-OF-TRANSACTIONS-显著性时间映射：浏览大量交易集\"><a href=\"#TIME-OF-SALIENCY-MAP-BROWSING-A-LARGE-SET-OF-TRANSACTIONS-显著性时间映射：浏览大量交易集\" class=\"headerlink\" title=\"TIME-OF-SALIENCY MAP: BROWSING A LARGE SET OF TRANSACTIONS 显著性时间映射：浏览大量交易集\"></a>TIME-OF-SALIENCY MAP: BROWSING A LARGE SET OF TRANSACTIONS 显著性时间映射：浏览大量交易集</h2><p><img src=\"TOS-map.png\" alt=\"图5\"></p>\n<h3 id=\"Generation-of-Time-Of-Saliency-Map-生成显著性时间映射\"><a href=\"#Generation-of-Time-Of-Saliency-Map-生成显著性时间映射\" class=\"headerlink\" title=\"Generation of Time-Of-Saliency Map 生成显著性时间映射\"></a>Generation of Time-Of-Saliency Map 生成显著性时间映射</h3><p>TOS映射是基于2D密度的展示，沿着水平轴的时间和由销售类别（例如，“电子配件”和“衣服”）组织的垂直轴TOS映射均匀分割成行，每个行代表一个销售类别。在图（a）中，由蓝色框突出显示的颜色矩形提供了垂直轴上类别的视觉索引。此外，每行按照<em>时间间隔水平分割</em>。<em>根据其时间戳和销售类别</em>每个事务被投射到相应的单元。投射到同一个单元格的所有事务的显着值相加，并将总和映射到单元格的颜色。色彩映射可以使用默认颜色标度或分析器指定的色标。所得到的TOS映射可视化地为分析任务编码事务的相关性。<em>黑暗区域</em>意味着一组潜在有趣的交易。特别地，连续的暗带表示在一段时间内相应的销售类别中的高度突出的交易（参见图1（a）中的TOS映射中的所选区域）。</p>\n<h3 id=\"Time-Of-Saliency-Exploration-探索显著性时间映射\"><a href=\"#Time-Of-Saliency-Exploration-探索显著性时间映射\" class=\"headerlink\" title=\"Time-Of-Saliency Exploration 探索显著性时间映射\"></a>Time-Of-Saliency Exploration 探索显著性时间映射</h3><p>TOS映射视图中提供了以下交互，可用于完成第一个任务（即识别感兴趣的时段和/或销售类别。）</p>\n<ul>\n<li><p><code>时间窗口</code> TOS映射以分析人员<code>可调节的时间间隔</code>显示交易。可以使用额外的时间窗口小部件来定位视图的特定区域以进行进一步和详细的研究。分析师可以在<code>时间选择栏</code>上单击并拖动以设置TOS映射的时间窗口，如图5（a）中TOS映射顶部的突出显示。图5（b）显示了分析师设置时间窗口后的TOS映射。</p>\n</li>\n<li><p><code>感兴趣的区域</code> 分析师可以点击<code>类别索引</code>（图5（a）中的蓝框）来选择同一类别的交易。 也可以使用<code>套索工具</code>来选择有趣的区域。 当选择一个区域时，将出现一个<code>浮动文本框</code>以显示有关该区域的信息。 所选交易的详细信息可以在第7节中描述的KnotLines视图中进一步可视化和探索。此外，还提供了一个<code>条形图视图</code>（图1（c））以显示所选数据中的类别的销售量。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>Time Windowing</code> The TOS map shows the transactions in an analyst-adjustable time interval. An additional time windowing widget can be used to locate a specific region of the view for further and detailed study. Analysts can click and drag on the time selection bar to set the time window of the TOS map, as highlighted over the top of the TOS map in Figure 5 (a). Figure 5 (b) shows the TOS map after the analyst sets the time window. </p>\n</li>\n<li><p><code>Region-Of-Interest</code> Selection The analysts can click on the category index (the blue box in Figure 5 (a)) to choose the transactions of the same category. A lasso tool can also be used to select interesting regions. When a region is selected, a floating text box will appear to show the information about the region. The detailed information of selected transactions can be further visualized and explored in the KnotLines view described in Section 7. In addition, a bar chart view (Figure 1 (c)) is provided to show the sales volume of categories in the selected data.</p>\n</li>\n</ul>\n<h2 id=\"KNOTLINES-EXAMINING-TRANSACTIONS-IN-DETAIL-详细审查交易\"><a href=\"#KNOTLINES-EXAMINING-TRANSACTIONS-IN-DETAIL-详细审查交易\" class=\"headerlink\" title=\"KNOTLINES: EXAMINING TRANSACTIONS IN DETAIL 详细审查交易\"></a>KNOTLINES: EXAMINING TRANSACTIONS IN DETAIL 详细审查交易</h2><p>KnotLines允许分析师对从TOS映射中选择的显着交易进行详细分析。它旨在解决任务2到任务4。KnotLines可视化显示两种类型的信息：属性和交易的时间趋势。</p>\n<h3 id=\"Data-Organization-and-Visual-Layout-数据组织和视觉布局\"><a href=\"#Data-Organization-and-Visual-Layout-数据组织和视觉布局\" class=\"headerlink\" title=\"Data Organization and Visual Layout 数据组织和视觉布局\"></a>Data Organization and Visual Layout 数据组织和视觉布局</h3><p>为了研究交易之间的属性相似性和时间相关性，所选择的交易集被组织成一个三级分层树（图6）。 首先，我们使用矩阵表来可视化事务的组织，如图7（a）所示。</p>\n<p><img src=\"hierarchical-tree.png\" alt=\"图6\"></p>\n<ul>\n<li><code>一级</code> 整个选定的交易集根据不同的卖家分为N组（1级）。图7（a）中的<em>每一行代表一个组</em>。一组包含卖家的所有交易。这些组沿垂直轴从上到下列出。</li>\n<li><code>二级</code> 一组中的交易根据其时间戳进一步分为子组（2级）。图7（a）中的<em>水平轴表示时间</em>。每行分别对应于M个时间间隔的时间轴上的M个正方形。所有间隔的长度相同，可以调整以探索不同粒度的数据。属于相同时间间隔的卖方的交易形成一个子组（2级）。</li>\n<li><code>三级</code> 根据销售类别（例如，“图书”），将一个子组进一步分为（级别3）。在图7（a）中，每个正方形被分割成K个细胞，每个细胞代表一个部分。同一部分的交易由同一卖方作出，在同一时间间隔内进行，属于同一销售类别。</li>\n</ul>\n<p><code>PS</code>：即三级严格递增，一级是属于同一个卖家，二级属于同一个卖家某段时间，三级属于同一个卖家某段时间的某类销售类别。分别按行，按列，按细胞划分。这个是交易集逻辑上关系，而图7是一种为了方便分析而设计表示该关系的可视化方法。</p>\n<ul>\n<li><code>Level One</code> The whole selected transaction set is divided into N groups (level 1) according to different sellers. Each row in Figure 7 (a) represents a group. A group contains all transactions of a seller. The groups are listed from top to bottom along the vertical axis. </li>\n<li><code>Level Two</code> The transactions in a group are further divided into subgroups (level 2) according to their time stamps. The horizontal axisin Figure 7 (a) represents the time. Each row is split into M squaresalong the time axis which correspond to M time intervals. The lengthsof all intervals are the same and can be adjusted to explore the data at different granularities. Transactions of a seller which fall into the same time interval form a sub-group (level 2).</li>\n<li><code>Level Three</code> A subgroup is further divided into sections (level 3)according to the sales categories (e.g., “Books”). In Figure 7 (a), each square is segmented into K cells, each of which represents a section. Transactions in the same section are made by the same seller, take place in the same time interval, and belong to the same sales category.</li>\n</ul>\n<p><img src=\"visual-organization.png\" alt=\"图7\"></p>\n<p>因为大部分卖家的交易量在一天的时间内可能很高，因此图7（a）所示矩阵中的交易密度可能非常稀疏。 另外，组N的数量可能很大（例如，100万）。 为了使探索更加有效，矩阵式布局应重新设计为更紧凑。</p>\n<p>VAET采用一个简单的两步启发式方案，对每个组进行操作。 </p>\n<ol>\n<li><p>在第一步中，删除第一个非空子组之前和最后一个非空子组之后的空子组。 这个步骤导致许多组仅覆盖水平空间的一小部分，因为它们中的大多数具有短的时间跨度。</p>\n</li>\n<li><p>为了增加空间效率，在第二步中启发式优化组的布局。 迭代布局策略用于满足以下原则： </p>\n<ul>\n<li>整洁：组不应重叠;</li>\n<li>紧凑型：空间利用率高;</li>\n<li>代表：重要群体应优先展示</li>\n</ul>\n</li>\n</ol>\n<p>VAET employs a simple two-step heuristic scheme that operates on each group. In the first step, empty sub-groups before the first nonempty sub-group and after the last non-empty sub-group are removed. This step results in many groups that only cover a small portion of the horizontal space, because most of them have a short time span. To increase the space efficiency, the placement of the groups is heuristically optimized in the second step. An iterative layout strategy is used to satisfy the following principles:</p>\n<ul>\n<li>Uncluttered: groups should not overlap;</li>\n<li>Compact: space utilization should be high;</li>\n<li>Representative: important groups should have a display priority</li>\n</ul>\n<p>分析人士指出， <em>这种设计（即图7）</em> 有几个主要缺点：</p>\n<ul>\n<li>由于部分可能包含数百个交易，可视化严重凌乱。 分析师建议在同一部分内汇总交易;</li>\n<li>分析师认为，紧凑的布局是空间效率高的必需品。 然而，他们很难从这个视图来识别同一卖家所做的交易。需要额外的视觉属性来强调这一重要关系;</li>\n<li>在此视图中没有提供有关交易的重要信息，如付款金额，交易是否缺少值，以及是否经常发生相同的交易。</li>\n</ul>\n<p>The analysts pointed out that there were several major drawbacks in this design: (1) The visualization was seriously cluttered since a section may contain hundreds of transactions. The analysts suggested aggregating transactions within the same section; (2) The analysts agreed that the compact layout was necessary for high space efficiency. However, it was difficult for them to identify transactions made by the same seller from this view. Additional visual attributes were desired to emphasize this important relationship; (3) Important information about the transactions such as payment amount, whether a transaction had missing values, and if identical transactions occurred frequently, was not presented in this view.</p>\n<h3 id=\"KnotLines-（结线）\"><a href=\"#KnotLines-（结线）\" class=\"headerlink\" title=\"KnotLines （结线）\"></a>KnotLines （结线）</h3><p>为了解决上述问题，我们设计了一个增强的视觉隐喻调用KnotLines。它受到音乐符号的启发，这可以被看作是一个改进的散点图，它沿着时间轴放置不同类型的点（音符）。它是时间序列（例如节拍和节奏）及其连接的复杂视觉表示。</p>\n<p>这里就不详细说明了，具体见表2。</p>\n<p><img src=\"Knotlines.png\" alt=\"图8\"></p>\n<p>表2 是Knotlines的可视化各个部分的含义<br>| 图形部分 | 含义|<br>|—-|—-|<br>| 视觉编码 | 交易数据|<br>| 一个knotline | 同一卖家在不同时间的交易（一组）|<br>| 一个knotbunch | 同一卖家在一段时间间隔内进行交易（一个子组）|<br>| 茎长 | 在一段时间内同一卖家的交易总支付金额|<br>| 一个结 | 在一段时间内，同一卖家与同名销售类别的交易（一节）|<br>| 结的颜色 | 该结点的销售类别|<br>| 结的大小 | 该结点的商品数量|<br>| 一个未填充的结点 | 与卖方或买方位置异常的交易|</p>\n<p><img src=\"Visual-Encoding.png\" alt=\"表2\"></p>\n<h3 id=\"Visual-Exploration-可视化探索\"><a href=\"#Visual-Exploration-可视化探索\" class=\"headerlink\" title=\"Visual Exploration 可视化探索\"></a>Visual Exploration 可视化探索</h3><p>除了布局模式的规范和详细结点的调查之外，KnotLines还提供了一套用于分析多个结线的交互。</p>\n<ul>\n<li><code>显着调制</code> KnotLines视图中显示的每个事务都包含一个显着值。 分析师可以显示从2D TOS映射中选择的所有交易，或仅显示显着值大于给定阈值（例如，0.8）的所选交易。 当视图中显示许多节线时，此过滤操作非常有用，因此它支持T2和T3。 图9显示了显着性调制的影响。</li>\n<li><code>查看导航</code> KnotLines视图可以水平放大，以清楚说明，这对T2和T3有帮助。 时间间隔的长度将相应调整。 分析师可以垂直或水平滚动查看更多的knotlines。</li>\n<li><code>兴趣选择结</code> 我们可以通过单击或使用套索工具拖动来选择一组结。 指定结时，会以黄色的圆圈突出显示。 由同一买家制造的相关结也用灰色的圆环突出显示分析师的注意力（图1（b））。 将出现一个浮动文本框，显示所选结的详细信息，如卖方的位置，支付金额和销售类别。 分析员可以在详细视图（图1（e））中的所选结（部分）中检查交易的信息（例如，买方和卖方的位置，子类别和商品编号），其中 是为T2设计的。 对T4有帮助的统计视图（图1（f））用于提供所选结的统计信息，如交易频率和卖方支付金额的趋势。</li>\n<li><code>标签</code> 当特定交易被分析师识别为突出显示时，可以将其添加到标记数据中进行迭代视觉分析和探索。</li>\n</ul>\n<ul>\n<li><p><code>Saliency Modulation</code> Each transaction shown in the KnotLines view contains a saliency value. The analysts can show either all transactions selected from the 2D TOS map or only the selected transactions whose saliency values are larger than a given threshold (e.g., 0.8).This filtering operation is useful when there are many knotlines shown in the view, so it supports T2 and T3. Figure 9 demonstrates the effect of saliency modulation.</p>\n</li>\n<li><p><code>View navigation</code> The KnotLines view can be zoomed horizontally for clear illustration, a function helpful for T2 and T3. The lengths of the time intervals will be adjusted accordingly. Analysts can scroll vertically or horizontally to see more knotlines.</p>\n</li>\n<li><p><code>Knots of Interest Selection</code> We can select a set of knots by clicking, or dragging using a lasso tool. When a knot is specified, it is highlighted with a yellow ring. Related knots which are made by the same buyer are also highlighted with grey rings to draw the analysts’ attention (Figure 1 (b)). A floating text box will appear displaying the detailed information of the selected knot such as the location of the seller, the payment amount, and the sales category. Analysts can check the information of the transactions (e.g., the location of the buyer and the seller, the sub-category, and the commodity number) in the selected knot (section) in the detail view (Figure 1 (e)), which is designed for T2. A statistic view (Figure 1 (f)), which is helpful for T4, is used to present statistical information for the selected knot, such as the trend of the transaction frequency and the payment amount of the seller.</p>\n</li>\n<li><p><code>Labeling</code> When a specific transaction is identified as salient by analysts,it can be added to the labeled data for iterative visual analysis and exploration.</p>\n</li>\n</ul>\n<p><img src=\"VAET-system.png\" alt=\"图1\"></p>\n<h2 id=\"CASE-STUDY-案例研究\"><a href=\"#CASE-STUDY-案例研究\" class=\"headerlink\" title=\"CASE STUDY 案例研究\"></a>CASE STUDY 案例研究</h2><p><code>PS</code>: 这部分应该是论文作者讲述一次真实分析过程，里面有分析的思路与流程，还有该系统的使用特点。</p>\n<p>来自我们的客户 - 客户（C2C）零售业务的数据部门的分析师参与了这项研究。 该公司提供了一个数据集，其中包含2600万个在线电子交易，从中他们想要检测假交易。 约有930万卖家和买家参与了数据集。 他有兴趣通过与合作伙伴买家建立假交易来识别卖家何时积累信用。 异常交易行为的一些指标可能是异常大量的商品，支付金额的大幅变化，特定卖方和买方之间的频繁交易，以及价值超出其正常范围的属性。</p>\n<h3 id=\"Construction-of-Decision-Tree-决策树构建\"><a href=\"#Construction-of-Decision-Tree-决策树构建\" class=\"headerlink\" title=\"Construction of Decision Tree 决策树构建\"></a>Construction of Decision Tree 决策树构建</h3><p>计算每个时间间隔内的卖方的交易频率并将其用作<code>时间特征</code>。 根据由分析者提供并用作文本特征的敏感字典，提取了评论中的<code>关键词</code>和<code>短语</code>（例如“信用”）。我们标注了大约300笔交易，这些交易是使用分层抽样从每个类别中选出的。 我们用标记的数据训练了决策树。 将要分析的交易的提取特征描述作为决策树的<code>输入</code>，并为每个输入产生显着性值。</p>\n<p>我们使用<code>精确率</code>p和<code>召回率</code>r来评估决策树的效率：p = TP /（TP + FP）= 0.89，r = TP /（T P + FN）= 0.92，其中TP，TN，FP和FN 从训练数据的预测结果中计数（见表1）。<br><code>PS:</code> 这几个概念一般用于评估机器学习算法的性能等指标，也是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。 决策树算法在这里的作用只是用来找到显著性值。</p>\n<h3 id=\"Abnormal-Frequency-and-Locations-of-Transactions-异常频率和交易地点\"><a href=\"#Abnormal-Frequency-and-Locations-of-Transactions-异常频率和交易地点\" class=\"headerlink\" title=\"Abnormal Frequency and Locations of Transactions 异常频率和交易地点\"></a>Abnormal Frequency and Locations of Transactions 异常频率和交易地点</h3><p>分析师在简短的培训课程之后开始在TOS映射中进行勘探。他注意到一个具有<code>高度显着性的长长的地区</code>（图10）。随后，分析师指定了时间窗口，并放大到所需的区域。为了进一步研究交易行为，分析师选择了这个地区，发现许多交易在9月19日上午10点被分类为“图书”。分析师注意到连续的红色结在图1（b）的连线上连接。他告诉我们，<em>这种模式表明卖家在选定的时间间隔内频繁交易</em>。经查核详细资料后，分析师发现这些交易属于“充值卡”类别，并由<em>不同的买家</em>组成。他评论说，这可能是一个促销活动，因为他在这些交易中没有发现异常信息。分析师将显着阈值增加到0.8，<code>显着调制滑块</code>（Saliency Modulation）。<em>这使得分析师能够有效地过滤出许多不太显着的交易</em>。分析师立即找到多个未填充的结，指示具有缺失值的交易。他评论说，使用未填充的结来呈现缺失值的交易有效地吸引了他的注意。为了进一步调查这些记录是否表示促销或假交易，分析师进行了进一步分析。<em>当他点击这条结线中的一个未填充的结时，同一个结线中的许多其他结被突出显示</em>（图1（b）），表明这些结的大部分交易是由同一买方和卖方进行的。分析师注意到，详细信息视图中，买方的交货地址为空，通过查看此结线中的结的详细信息（图1（e））。他评论说这是可疑的，因为如果买方不填写他的地址，买家就不会买到这个商品。通过查看结的交易历史（图1（f）），分析师发现，卖方的销售额在一段时间内急剧增加。</p>\n<p>分析师认为这些交易可能与赚取<code>信用</code>有关。 该结论由数据提供商的商业智能部门的分析师进行了验证，他们检查了与交易相关的其他信息，如卖方和买方的IP地址。 他们解释说，这些交易是由一组帮助卖家增加<code>信用</code>的买家进行的，卖家没有真正交付产品。 分析师将这一结线中的交易标示为<code>显着</code>，并将它们添加到训练数据集中。</p>\n<p><img src=\"salient-transactions.png\" alt=\"图10\"></p>\n<p><img src=\"VAET-system.png\" alt=\"图1\"></p>\n<h3 id=\"Abnormal-Attribute-Values-of-Transactions-交易的异常属性值\"><a href=\"#Abnormal-Attribute-Values-of-Transactions-交易的异常属性值\" class=\"headerlink\" title=\"Abnormal Attribute Values of Transactions 交易的异常属性值\"></a>Abnormal Attribute Values of Transactions 交易的异常属性值</h3><p>分析师在TOS映射中选择了另一个时间窗口。通过查看<code>条形图</code>视图中的销售类别信息（图11（a）），分析师发现，“电子配件”类别中销售的商品总数远远大于其他销售类别。<em>分析师认为，由于商品数量庞大，这将是促销活动</em>。他在<code>knotline</code>视图中调查了这个假设，但没有发现任何包含频繁连续的“电子配件”结。</p>\n<p>分析师在TOS映射中选择了此类别，以过滤掉不相关的类别。通过仔细检查剩余的结，分析师发现一个具有短茎的极大的结（图11（b）），表明一个较大的商品数量，总支付金额却较低。分析师告诉我们，“<em>通过这种knotline，我第一眼就注意到支付和商品数量之间的异常关系</em>”。结的详细视图（图11（c））显示，本节包含单笔交易，支付金额仅为10美分，商品却为22万件。通过进一步调查卖方的交易历史（图11（d）），分析师消除了销售促销的概率，因为卖方在一段时间内交易次数很少，表明销售商品很少。分析师认为这是一个事件，卖方试图根据已经出售的商品数量增加他们的互联网搜索排名。<em>分析师还将该交易标注为显着，并将其添加到训练数据集</em>。</p>\n<p><img src=\"fig11.png\" alt=\"图11\"></p>\n<h2 id=\"USER-STUDY-用户研究\"><a href=\"#USER-STUDY-用户研究\" class=\"headerlink\" title=\"USER STUDY 用户研究\"></a>USER STUDY 用户研究</h2><p>我们进行了用户研究，<em>以评估VAET支持低级别分析任务的能力</em>，即第3节中讨论的T1-T4。所使用的数据集是第8节（即上一节）中探讨的交易数据集。</p>\n<h3 id=\"Design-设计\"><a href=\"#Design-设计\" class=\"headerlink\" title=\"Design 设计\"></a>Design 设计</h3><p>10名参与者（6名男性和4名女性）年龄介于21岁至35岁之间进行了用户研究。 其中两人是分析师，其他人则是研究生。 所有参与者都具有使用在线商务的经验，并且对电脑熟悉。 学生的专业包括计算机科学，设计，数学和生物学。 以前他们都没有使用过VAET。</p>\n<p>参与者一个接一个地参加研究。 对于每个参与者，在测试部分之前进行了短暂的训练。 在培训部分，教练首先向参与者介绍了VAET的25分钟演示。 在演示过程中，教练解释了VAET的视觉设计和功能。 在演示之后，参与者在教练的帮助下练习了VAET提供的互动5分钟。 在测试部分，参与者被要求完成9次练习，与实际分析中遇到的练习类似，无需教练帮助。 然后，他们被要求通过回答问卷并提供主观反馈来评估系统。</p>\n<p>这9个练习是针对三种不同的具体情况而设计的，其中两项是在第8节中描述的。每个低级任务都通过一项或多项练习进行评估。 他们评估的练习和任务如下（任务显示在括号中）：</p>\n<ul>\n<li>E1 “使用TOS映射，从9月21日上午9点至10点选择具有最高显着性的销售类别。”目标：确定TOS映射（T1）中感兴趣的时间段和销售类别。</li>\n</ul>\n<p>E2和E3来自第8.3节所述的情况。</p>\n<ul>\n<li><p>E2 “选择商品数量最大的销售类别”。目标：解释条形图并确定感兴趣的销售类别（T1）。</p>\n</li>\n<li><p>E3 “查找KnotLines中商品数量最多的交易。”目标：解释一个结的视觉编码，并识别具有特定属性（T2）的有趣模式的交易。</p>\n</li>\n</ul>\n<p>要完成E4-E6，参加者将被要求在9月19日晚上18点至19点之间设置时间，并选择“充值卡”。</p>\n<ul>\n<li><p>E4 “从KnotLines视图中找到具有最高交易频率的卖家（knotline）”。目标：解释knotline的视觉编码，并识别有趣的交易模式（T3）的卖家。</p>\n</li>\n<li><p>E5 “在KnotLines视图中，哪些卖方的交易模式不会发生？ （a）大量商品的单笔交易，但支付金额很小。 （b）低频连续交易。 （c）持续交易频率高，支付金额小。 （d）我不知道。“目标：解释这个knotlines和识别有趣的卖家交易模式（T3）。</p>\n</li>\n<li><p>E6 “E4中卖方交易历史的一个特征是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：以统计视角检查卖方的行为（T4）。</p>\n</li>\n</ul>\n<p>E7 - E9与8.2节描述的情况相同。 </p>\n<ul>\n<li><p>E7 “在KnotLines视图中查找未填充的结，并报告买方城市。”目标：使用详细信息视图（T2）检查事务的属性值。</p>\n</li>\n<li><p>E8 “E7中确定的卖方交易历史的主要特点是什么？ （a）持续，频繁的交易。 （b）偶尔交易。 （c）突然，频繁的交易。“目标：使用统计视图检查卖方的行为（T4）。</p>\n</li>\n<li><p>E9 “E7中确定的卖方的交易行为是什么？ （a）具有大量商品编号的单一交易。 （b）付款金额低的频繁交易。 （c）与异常购买城市频繁交易。“目标：解释和检查KnotLines（T4）的卖方交易模式。</p>\n</li>\n</ul>\n<p>E1 “Choose the sales category with the highest saliency value from 9 am to 10 am on September 21 using the TOS map.” Objective: Identify time periods and sales categories of interest in the TOS map (T1).</p>\n<p>E2 and E3 were from the case described in Section 8.3.</p>\n<p>E2 “Choose the sales category with the largest commodity number.” Objective: Interpret the bar chart and identify sales categories of interest (T1).</p>\n<p>E3 “Find the transaction with the largest number of commodities in KnotLines.” Objective: Interpret the visual encoding of a knot and identify transactions with interesting patterns in specific attributes (T2).</p>\n<p>To finish E4 - E6, participants were asked to set the time between 18 pm and 19 pm on September 19, and choose “Top-up Card”.</p>\n<p>E4 “Find the seller (knotline) with the highest transaction frequency from the KnotLines view.” Objective: Interpret the visual encoding of a knotline and identify sellers with interesting transaction patterns (T3).</p>\n<p>E5 “In the KnotLines view, which transaction pattern of the seller does not occur? (a) Single transaction with a large number of commodities but a small payment amount. (b) Continuous transactions with low frequency. (c) Continuous transactions with high frequency and a small payment amount. (d) I don’t know.” Objective: Interpret the knotlines and identify interesting seller transaction patterns (T3). </p>\n<p>E6 “Which is a feature of the seller transaction history of the knot in E4? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden, frequent transactions.” Objective: Examine the seller’s behavior in the statistic view (T4). </p>\n<p>E7 - E9 were the same case described in Section 8.2.</p>\n<p>E7 “Find unfilled knots in the KnotLines view and report the buyer cities of them.” Objective: Examine the attribute values of the transactions using the detailed information view (T2). </p>\n<p>E8 “What is the main feature of the seller’s transaction history of the knot identified in E7? (a) Continuous, frequent transactions. (b) Occasional transactions. (c) Sudden ,frequent transactions.” Objective: Examine the seller’s behavior using the statistic view (T4).</p>\n<p>E9 “What is the transaction behavior of the seller identified in E7? (a) A single transaction with a large commodity number. (b) Frequent transactions with low payment amounts. (c) Frequent transactions with abnormal buyer cities.” Objective: Interpret and examine the seller’s transaction patterns from KnotLines (T4).</p>\n<p>练习结束后，参加者完成了由6个问题组成的调查问卷（Q1〜Q6）。 要求用1到5评估等级（1=非常简单或高效，5=非常困难或低效），<em>学习该VAET系统的难度和VAET的效率</em>。 这些问题也收集到主观反馈。 六个问题如下：</p>\n<ol>\n<li>容易或难以学习TOS映射？</li>\n<li>使用TOS映射探索显着数据是否有效？</li>\n<li>单个结的<code>视觉编码</code>是否容易或难以解释？</li>\n<li>KnotLines的视觉编码和布局是否容易或难以解释？</li>\n<li>使用KnotLines分析用户交易模式是否有效？</li>\n<li>使用VAET整体分析多用户行为是否容易或困难？</li>\n</ol>\n<hr>\n<ol>\n<li>Is it easy or hard to learn the TOS map?</li>\n<li>Is it efficient or not to explore salient data with the TOS map?</li>\n<li>Is it easy or hard to interpret the visual encoding of a single knot?</li>\n<li>Is it easy or hard to interpret the visual encoding and layout of KnotLines?</li>\n<li>Is it efficient or not to analyze the user transaction patterns with KnotLines?</li>\n<li>Is it easy or hard to analyze multi-user behavior with VAET as a whole?</li>\n</ol>\n<h3 id=\"Results-结果\"><a href=\"#Results-结果\" class=\"headerlink\" title=\"Results 结果\"></a>Results 结果</h3><p>收集9次练习的准确性和时间进行评估</p>\n<p>总体来说，参加者完成了练习，在90次全部练习中产生5次错误（精准度为94.4％）。分析师正确回答了所有问题。对于学生参与者，其中两人在E5上出错，E8上有两个错，E9上有一个错。</p>\n<p>我们采访了E5的错误参与者。他们都说他们“只注意到knotlines的主要模式，忽略了发生较少的模式”。但是，他们没有解释用户行为的问题。回答E8的参与者错误地提到他们忘记检查统计视图中显示的卖家历史信息（图1（f）），而是根据KnotLines视图回答问题。在E9错误的参与者认为，零买家城市（null buyer cities）对于不需要交货地址的电子书等虚拟商品的交易是正常的。事实上，“图书”类别中的所有商品都是实物。虽然一些参与者有T3和T4的问题，但总体准确性表明VAET可以很好地支持任务。</p>\n<p>Overall, the participants completed the exercises, yielding 5 mistakes out of the 90 total exercises (94.4% accuracy). The analysts answered all questions correctly. As for the student participants, two of them erred on E5, two erred on E8 and one erred on E9. </p>\n<p>We interviewed the participants who erred on E5. They both said that they “only noticed the main patterns of the knotlines and ignored the patterns with fewer occurrence”. However, they had no problem interpreting the user behavior from them. The participants who answered E8 incorrectly mentioned that they forgot to check the seller history information shown in the statistic view (Figure 1(f)) and answered the question based on the KnotLines view instead. The participant who erred on E9 thought that null buyer cities are normal for transactions of virtual commodities such as E-books, which do not need delivery addresses. In fact, all commodities in the “Books” category are real items. Although some participants had problems with T3 and T4, the overall accuracy indicates that VAET supports the tasks well.</p>\n<p>图12显示了每次锻炼的完成时间的平均值和标准偏差。 E3，E4和E7的时间比其他问题的时间长。 这三个练习要求参与者搜索具有特定特征的knotlines，这可能需要更多的时间仔细检查视图。 参与者能够快速完成其他6个问题。 完成时间为5.14s至44.22s。 分析师花费的时间远远少于学生参与者。 总体而言，VAET允许大多数参与者在90秒内完成复杂的练习和任务（如E4和T3）。 在考虑交易的各种属性以及它们之间的关系时，这是相当快的。</p>\n<p><img src=\"fig12.png\" alt=\"图12\"></p>\n<p>分析师的反馈与讨论</p>\n<p>在用户研究结束时，我们采访了分析师和其他参与者。 两位分析师都对分类结果感到满意。 他们评论说，在分析不同类型的交易时，特征提取和决策树的集成是高效和灵活的。 我们要求他们将决策树与之前使用的逻辑回归进行比较。 他们认为我们的模型有几个优点：</p>\n<ul>\n<li>决策树对于分析师来说很简单易懂。</li>\n<li>在处理属性的缺失值时，决策树比逻辑回归更强大。</li>\n<li>使用决策树的分类比逻辑回归更快。 </li>\n</ul>\n<p>他认为我们可以通过使用更多的信息来改进我们的方法，比如今后买家和卖家的IP地址。</p>\n<p>他们评论说，TOS映射是直观的，勘探方便。一位分析师表示：“KnotLines的多用户行为的可视化是创造性和生动的。”<em>虽然一位分析师认为该系统很难学习，但很少参与者难以解释可视化</em>，大多数人能够在简短的培训会议后找到有趣的交易。两位分析师都提到，VAET能够帮助他们探索未被发现的交易模式。这是至关重要的，因为“欺骗人总是不断改变伎俩”。他们认为，VAET有能力找到新兴的交易模式，并帮助他们改进数据模型。分析师们渴望将VAET用于实际的多用户应用程序，在这些应用程序中，他们发现许多高维度事务之间的上下文和时间相关性。有趣的是，一些参与者最初认为使用我们的系统需要基本的音乐知识。其他与会者提到，他们对音乐笔记的了解影响了对设计的理解。例如，茎长度固定在音符中，但在我们的设计中是可变的。此外，有些人认为与其他knotbunches（类似于四分之一音符）没有连接的单个knotbunch持续比连接的knotbunch短（类似于第八个音符）。事实是，交易没有持续时间，因为它们都是立即在线发生的。与会者告诉我们，在他们学会如何解读设计之后，这种差异并没有妨碍他们的分析。</p>\n<h2 id=\"CONCLUSION-总结\"><a href=\"#CONCLUSION-总结\" class=\"headerlink\" title=\"CONCLUSION 总结\"></a>CONCLUSION 总结</h2><p>本文提出了一种用于识别基本交易数据和研究<em>大片碎片记录</em>的<code>时间</code>或<code>集体行为</code>的新型视觉探索方案。 在对KnotLines进行选择交易的详细探索和推理之前，执行决策树算法和TOS映射的过滤过程，以从大量记录中选择潜在有趣的交易。 案例研究和用户研究证实，VAET可以有效地支持大部分任务。 根据结果，一些任务如T3需要更好地解决，因为交易模式可以是<code>动态的</code>和<code>多层次的</code>。 为了使VAET更容易学习和使用，我们希望使TOS映射和KnotLines的设计更加直观。 对于未来的工作，我们也希望对更多的数据集进行扩展。</p>\n<p>This paper presents a novel visual exploration scheme for identifying elementary transaction data and studying the temporal or collective behavior from large pieces of fragmented records. Prior to detailed exploration and reasoning of the chosen transactions with KnotLines, a decision tree algorithm and a filtering process by TOS map are performed to choose potentially interesting transactions from a huge amount of records. The case study and the user study verify that VAET can effectively support most of the tasks. According to the result, some tasks such as T3 need to be better addressed as the patterns of transactions can be dynamic and multi-level. To make VAET easier to learn and use, we would like to make the design of TOS map and KnotLines more intuitive. For future work, we also would like to extend our approach for more datasets.</p>"},{"title":"JS函数式编程笔记2","date":"2018-02-07T06:27:31.000Z","_content":"\n# JS函数式编程\n\n笔记里面常常依赖一些库和之前的代码，而且可能存在理论上的代码和未实现的函数，阅读时，需要仔细。\n\n下面部分经常的东西后面经常用到，我先导入。\n\n```js\nconst curry = require('lodash/curry')\nconst _ = require('lodash')\nconst fp = require('lodash/fp')\nconst moment = require('moment')\n\nlet compose = function(f, g){\n    return function(x){\n        return f(g(x))\n    }\n}\n\nlet toUpperCase = function(str){\n    return str.toUpperCase()\n}\n\nlet toLowerCase = function(str){\n    return str.toLowerCase()\n}\n```\n\n## Hindley-Milner 类型签名\n\n### 初识类型\n\n刚接触函数式编程的人很容易深陷类型签名（type signatures）的泥淖。类型（type）是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的。\n\n类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理（free theorems）” 的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。类型签名不但可以用于编译时检测（compile timechecks），还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色——重要程度远远超出你的想象。\n\n<!-- more -->\n\n```js\n// capitalize :: String -> String\nlet capitalize = function(s){\n   return toUpperCase(head(s)) + toLowerCase(tail(s))\n}\n\nconsole.log(capitalize(\"hello\"))\n```\n\n在 Hindley-Milner 系统中，函数都写成类似 a -> b 这个样子，其中 a 和 b是任意类型的变量。因此， capitalize 函数的类型签名可以理解为“一个接受String 返回 String 的函数”。换句话说，它接受一个 String 类型作为输入，并返回一个 String 类型的输出、\n\n*PS：Haskell里面HM类型签名作为类型约束语法（type constraints）是很常见的。*\n\n```js\n// strLength :: String -> Number\nlet strLength = function(s){\n   return s.length\n}\n\n// join :: String -> [String] -> String\nlet join = curry(function(what, xs){\n   xs.join(what)\n})\n\n// match :: Regex -> String -> [String]\nlet match = curry(function(reg, s){\n   return s.match(reg)\n})\n\n// replace :: Regex -> String -> String -> String\nlet replace = curry(function(reg, sub, s){\n    return s.replace(reg, sub)\n})\nconsole.log(replace(/world/ig)('JS')('hello world'))\n```\n\nstrLength 和 capitalize 类似：接受一个 String 然后返回一个Number 。至于其他的，第一眼看起来可能会比较疑惑。不过在还不完全了解细节的情况下，你尽可能把最后一个类型视作返回值。那么 match 函数就可以这么理解：它接受一个 Regex 和一个 String ，返回一个 [String] 。\n\n这里有一个非常有趣的地方，对于 match 函数，我们完全可以把它的类型签名这样分组 \n```js\n// match :: Regex -> (String -> [String])\nlet match = curry(function(reg, s){\n    return s.match(reg)\n })\n```\n\n是的，把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出match 这个函数接受一个 Regex 作为参数，返回一个从 String 到 [String] 的函数。因为 curry，造成的结果就是这样：给 match 函数一个Regex ，得到一个新函数，能够处理其 String 参数。当然了，我们并非一定要这么看待这个过程，但这样思考有助于理解为何最后一个类型是返回值。\n\n```js\n// onHoliday :: String -> [String]\nlet onHoliday = match(/holiday/ig)\nconsole.log(onHoliday('hello holiday'))\n```\n\n每传一个参数，就会弹出类型签名最前面的那个类型。所以 onHoliday 就是已经有了 Regex 参数的 match 。\n\nPS：我最近刚开始学习Haskell，Haskell里面所有函数都是auto-curried的。配合HM签名效果感觉很强大。\n\n```js\n// replace :: Regex -> (String -> (String -> String))\nlet replace = curry(function(reg, sub, s){\n    return s.replace(reg, sub);\n})\n```\n\n但是在这段代码中，就像你看到的那样，为 replace 加上这么多括号未免有些多余。所以这里的括号是完全可以省略的，如果我们愿意，可以一次性把所有的参数都传进来；所以，一种更简单的思路是： replace 接受三个参数，分别是 Regex 、 String 和另一个 String ，返回的还是一个 String 。\n\n```js\n// id :: a -> a\nlet id = function(x){ return x }\n// map :: (a -> b) -> [a] -> [b]\nlet map = curry(function(f, xs){\n    return xs.map(f)\n})\n\nconsole.log(map((x) => x * 2)([1,2,3]))\n```\n\n这里的 id 函数接受任意类型的 a 并返回同一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 a 和 b 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的一个原则，所以我们必须重申： a -> b 可以是从任意类型的 a 到任意类型的 b ，但是 a -> a 必须是同一个类型。例如， id 可以是 String -> String ，也可以是 Number -> Number ，但不能是 String -> Bool 。\n\n相似地， map 也使用了变量，只不过这里的 b 可能与 a 类型相同，也可能不相同。我们可以这么理解： map 接受两个参数，第一个是从任意类型 a 到任意类型 b 的函数；第二个是一个数组，元素是任意类型的 a ； map 最后返回的是一个类型 b 的数组。\n\n辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。\n\n```js\n// head :: [a] -> a\nlet head = function(xs){ return xs[0]}\n\n// filter :: (a -> Bool) -> [a] -> [a]\nlet filter = curry(function(f, xs){\n    return xs.filter(f)\n})\n\n// reduce :: (b -> a -> b) -> b -> [a] -> b\nlet reduce = curry(function(f, x, xs){\n    return xs.reduce(f, x)\n})\n```\n\n注意看 reduce 的签名，可以看到它的第一个参数是个函数，这个函数接受一个 b 和一个 a 并返回一个 b 。那么这些 a 和 b 是从哪来的呢？很简单，签名中的第二个和第三个参数就是 b 和元素为 a 的数组，所以唯一合理的假设就是这里的 b 和每一个 a 都将传给前面说的函数作为参数。我们还可以看到， reduce 函数最后返回的结果是一个b ，也就是说， reduce 的第一个参数函数的输出就是 reduce 函数的输出。知道了 reduce 的含义，我们才敢说上面关于类型签名的推理是正确的。\n\n```js\nconsole.log(reduce((b, a) => a * b)(3)([1, 2, 3]))\nconsole.log([1, 2, 3].reduce((b, a) => a * b, 3))\n```\n\n### 缩小可能性范围\n\n一旦引入一个类型变量，就会出现一个奇怪的特性叫做 parametricity（http://en.wikipedia.org/wiki/Parametricity ）。这个特性表明，函数将会以一种统一的行为作用于所有的类型。\n\na 告诉我们它不是一个特定的类型，这意味着它可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一。这就是 parametricity 的含义。\n\n这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 Hoogle 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。\n\n*PS: Hoogle是Haskell官网中搜索文档的搜索引擎。*\n\n### 自由定理\n\n类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理（free theorems）。\n```js\n// head :: [a] -> a\ncompose(f, head) == compose(head, map(f));\n// filter :: (a -> Bool) -> [a] -> [a]\ncompose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));\n```\n\n不用写一行代码你也能理解这些定理，它们直接来自于类型本身。\n\n*PS: 这些函数是纯的才能成立。*\n\n第一个例子中，等式左边说的是，先获取数组的第一个元素，然后对它调用函数 f ；等式右边说的是，先对数组中的每一个元素调用 f ，然后再取其返回结果的头部 。这两个表达式的作用是相等的，但是前者要快得多。\n\n第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，然后再通过 map 实际调用 f （别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；等式右边是说，先用 map 调用 f ，然后再根据 p 过滤元素。这两者也是相等的。\n\n### 类型约束\n\n最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。\n\n```js\n// sort :: Ord a => [a] -> [a]\n```\n\n胖箭头左边表明的是这样一个事实： a 一定是个 Ord 对象。也就是说， a 必须要实现 Ord 接口。 Ord 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 a 的更多信息，了解 sort 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束（type constraints）。\n\nPS：Haskell里面存在Ord类型类，Rust里面也有类似的东西。\n\n```js\n// assertEqual :: (Eq a, Show a) => a -> a -> Assertion\n```\n\n### 总结\n\nHindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更需要花点时间了。\n\n\n## 特百惠\n\n### 强大的容器\n\n我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？\n\n首先我们将创建一个容器（container）。这个容器必须能够装载任意类型的值。这个容器将会是一个对象，但我们不会为它添加面向对象观念下的属性和方法。\n\n```js\nlet Container = function(x) {\n    this.__value = x\n}\n\nContainer.of = function(x) {\n    return new Container(x)\n}\n```\n\n\n我们将使用 Container.of 作为构造器（constructor），这样就不用到处去写糟糕的 new 关键字了，非常省心。 实际上不能这么简单地看待 of 函数，但暂时先认为它是把值放到容器里的一种方式。\n\n```js\nContainer.of(3)\n//=> Container(3)\nContainer.of(\"hotdogs\")\n//=> Container(\"hotdogs\")\nContainer.of(Container.of({name: \"yoda\"}))\n//=> Container(Container({name: \"yoda\" }))\n```\n\n在继续后面的内容之前，先澄清几点：\nContainer 是个只有一个属性的对象。尽管容器可以有不止一个的属性，但大多数容器还是只有一个。我们很随意地把 Container 的这个属性命名为 __value。__value 不能是某个特定的类型，不然 Container 就对不起它这个名字了。数据一旦存放到 Container ，就会一直待在那儿。我们可以用 .__value 获取到数据，但这样做有悖初衷。\n\n### 第一个 functor(函子)\n\n一旦容器里有了值，不管这个值是什么，我们就需要一种方法来让别的函数能够操作它。\n\n```js\n// (a -> b) -> Container a -> Container b\nContainer.prototype.map = function(f) {\n    return Container.of(f(Container.__value))\n}\n\n// 这个 map 跟数组那个著名的 map 一样，除了前者的参数是 Container a 而后者是 [a] 。它们的使用方式也几乎一致\nconsole.log(Container.of(2).map(num => num + 2))\nconsole.log(Container.of('hello').map(str => str.toUpperCase()))\n```\n\n为什么要使用这样一种方法？因为我们能够在不离开 Container 的情况下操作容器里面的值。这是非常了不起的一件事情。 Container 里的值传递给 map 函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的 Container。这样做的结果是，我们能连续地调用 map ，运行任何我们想运行的函数，甚至还可以改变值的类型。\n\n如果我们能一直调用 map ，那它不就是个组合（composition）么！这里边是有什么数学魔法在起作用？是 `functor`。各位，这个数学魔法就是 functor。\n\n*functor 是实现了 map 函数并遵守一些特定规则的容器类型。*\n\n没错，functor 就是一个签了合约的接口。functor 是范畴学里的概念。\n\n把值装进一个容器，而且只能使用 map 来处理它，这么做的理由到底是什么呢？如果我们换种方式来问，答案就很明显了：让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。\n\n### 薛定谔的 Maybe\n\n说实话 Container 挺无聊的，而且通常我们称它为 Identity ，与 id 函数的作用相同（这里也是有数学上的联系的）。除此之外，还有另外一种 functor，那就是实现了 map 函数的类似容器的数据类型，这种 functor 在调用 map 的时候能够提供非常有用的行为。现在让我们来定义一个这样的 functor。\n\n\n```js\nlet Maybe = function(x) {\n    this.__value = x\n}\n\nMaybe.of = function(x) {\n    return new Maybe(x)\n}\n\nMaybe.prototype.isNothing = function() {\n    return (this.__value === null) || (this.__value === undefined)\n}\n\nMaybe.prototype.map = function(f) {\n    return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value))\n}\n```\n\nMaybe 会先检查自己的值是否为空，然后才调用传进来的函数。这样我们在使用 map 的时候就能避免恼人的空值了（这个实现出于教学目的做了简化）。\n\n```js\nconsole.log(Maybe.of('Malkovich Malkovich').map(match(/a/ig)))\nconsole.log(Maybe.of(null).map(match(/a/ig)))\nconsole.log(Maybe.of({name: \"Dinah\", age: 14}).map(_.property('age')))\n```\n\n当传给 map 的值是 null 时，代码并没有爆出错误。这是因为每一次 Maybe 要调用函数的时候，都会先检查它自己的值是否为空。\n\n这种点记法（dot notation syntax）已经足够函数式了，但是正如在第 1 部分指出的那样，我们更想保持一种 pointfree 的风格。碰巧的是， map 完全有能力以 curry 函数的方式来“代理”任何 functor。\n\n```js\n// map :: Functor f => (a -> b) -> f a -> f b\nmap = curry(function(f, any_functor_at_all) {\n    return any_functor_at_all.map(f)\n})\n```\n\n这样我们就可以像平常一样使用组合，同时也能正常使用 map 了，非常振奋人心。`ramda` 的 map 也是这样。后面的，我们将在点记法更有教育意义的时候使用点记法，在方便使用 pointfree 模式的时候就用 pointfree。你注意到了么？我在类型标签中偷偷引入了一个额外的标记： Functor f => 。这个标记告诉我们 f 必须是一个 functor。\n\n用例\n\n```js\n// safeHead :: [a] -> Maybe(a)\nlet safeHead = function(xs) {\n    return Maybe.of(xs[0])\n}\n\nlet streetName = compose(compose(map(_.property('street')), safeHead), _.property('addresses'))\n\nconsole.log(streetName({addresses:[]}))\n// Maybe(null)\n\nconsole.log(streetName({addresses: [{street: \"Shady Ln.\", number: 4201}]}))\n// Maybe(\"Shady Ln.\")\n\n```\n\nsafeHead 与一般的 _.head 类似，但是增加了类型安全保证。引入 Maybe 会发生一件非常有意思的事情，那就是我们被迫要与狡猾的 null 打交道了。 safeHead 函数能够诚实地预告它可能的失败,然后返回一个 Maybe 来通知我们相关信息。实际上不仅仅是通知，因为毕竟我们想要的值深藏在 Maybe 对象中，而且只能通过 map 来操作它。*本质上，这是一种由 safeHead 强制执行的空值检查。* 类似这样的 API 能够把一个像纸糊起来的、脆弱的应用升级为实实在在的、健壮的应用，这样的 API 保证了更加安全的软件。\n\n有时候函数可以明确返回一个 Maybe(null) 来表明失败\n\n```js\n// withdraw :: Number -> Account -> Maybe(Account)\nlet withdraw = curry(function(amount, account){\n    return account.balance >= account ?\n        Maybe.of({account: account.balance - account}) :\n        Maybe.of(null)\n})\n\n// finishTransaction :: Account -> String\nlet finishTransaction = compose(remainingBalance, updateLedger)\n// <- 假定这两个函数已经在别处定义好了\n\n// getTwenty :: Account -> Maybe(String)\nlet getTwenty = compose(map(finishTransaction), withdraw(20))\n\ngetTwenty({ balance: 200.00})\n// Maybe(\"Your balance is $180.00\")\n\ngetTwenty({ balance: 10.00})\n// Maybe(null)\n```\n\nwithdraw 也显示出了它的多变性，使得我们后续的操作只能用 map 来进行。这个例子与前面例子不同的地方在于，这里的 null 是有意的。我们不用 Maybe(String) ，而是用 Maybe(null)来发送失败的信号，这样程序在收到信号后就能立刻停止执行。这一点很重要：如果 withdraw 失败了，map 就会切断后续代码的执行，因为它根本就不会运行传递给它的函数，即finishTransaction 。这正是预期的效果：如果取款失败，我们并不想更新或者显示账户余额。\n\n### 释放容器里的值\n\n人们经常忽略的一个事实是：任何事物都有个最终尽头。那些会产生作用的函数，不管它们是发送 JSON 数据，还是在屏幕上打印东西，还是更改文件系统，还是别的什么，都要有一个结束。但是我们无法通过 return 把输出传递到外部世界，必须要运行这样或那样的函数才能传递出去。\n\n应用程序所做的工作就是获取、更改和保存数据直到不再需要它们，对数据做这些操作的函数有可能被 map 调用，这样的话数据就可以不用离开它温暖舒适的容器。讽刺的是，有一种常见的错误就是试图以各种方法删除 Maybe 里的值，好像这个不确定的值是魔鬼，删除它就能让它突然显形，然后一切罪恶都会得到宽恕似的（此处原文应该是源自圣经）。要知道，我们的值没有完成它的使命，很有可能是其他代码分支造成的。我们的代码，就像薛定谔的猫一样，在某个特定的时间点有两种状态，而且应该保持这种状况不变直到最后一个函数为止。这样，哪怕代码有很多逻辑性的分支，也能保证一种线性的工作流。\n\n不过，对容器里的值来说，还是有个逃生口可以出去。也就是说，如果我们想返回一个自定义的值然后还能继续执行后面的代码的话，是可以做到的；要达到这一目的，可以借助一个帮助函数 maybe ：\n\n```js\n// maybe :: b -> (a -> b) -> Maybe a -> b\nlet maybe = _.curry(function(x, f, m){\n    return m.isNothing() ? x : f(m.__value)\n})\n\n// getTwenty :: Account -> String\nlet getTwenty = compose(maybe(\"You're broke!\", finishTransaction), withdraw(20))\n\ngetTwenty({ balance: 200.00});\n// \"Your balance is $180.00\"\ngetTwenty({ balance: 10.00});\n// \"You're broke!\"\n```\n\n这样就可以要么返回一个静态值（与 finishTransaction 返回值的类型一致），要么继续愉快地在没有 Maybe 的情况下完成交易。 maybe 使我们得以避免普通 map 那种命令式的 if/else 语句： if(x !== null) { return f(x) } 。\n\n引入 Maybe 可能会在初期造成一些不适。Swift 和 Scala 用户知道我在说什么，因为这两门语言的核心库里就有 Maybe 的概念，只不过伪装成 Option(al) 罢了。\n\n*PS：Haskell 里面有Maybe，Rust里面也是类似伪装成 Option。*\n\n被迫在任何情况下都进行空值检查，的确让大部分人头疼不已。然而随着时间推移，空值检查会成为第二本能，不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。\n\nMaybe 能够非常有效地帮助我们增加函数的安全性。\n\n有一点我必须要提及，否则就太不负责任了，那就是 Maybe 的“真正”实现会把它分为两种类型：一种是非空值，另一种是空值。这种实现允许我们遵守 map 的 parametricity 特性，因此 null 和 undefined 能够依然被 map 调用，functor 里的值所需的那种普遍性条件也能得到满足。所以你会经常看到 Some(x) / None 或者 Just(x) / Nothing 这样的容器类型在做空值检查，而不是Maybe 。\n\n### “纯”错误处理\n\n说出来可能会让你震惊， throw/catch 并不十分“纯”。当一个错误抛出的时候，我们没有收到返回值，反而是得到了一个警告！\n\n有了 Either 这个新朋友，我们就能以一种好得多的方式来处理错误，那就是返回一条非常礼貌的消息作为回应。\n\n```js\nlet Left = function(x) {\n    this.__value = x\n}\n\nLeft.of = function(x) {\n    return new Left(x)\n}\n\nLeft.prototype.map = function(f) {\n    return this\n}\n\nlet Right = function(x) {\n    this.__value = x\n}\n\nRight.of = function(x) {\n    return new Right(x)\n}\n\nRight.prototype.map = function(f) {\n    return Right.of(f(this.__value))\n}\n\n// Left 和 Right 是我们称之为 Either 的抽象类型的两个子类。\nlet right = Right.of(\"rain\").map(function(str) {\n    return \"b\" + str\n})\n// Right(\"brain\")\n\nlet left = Left.of(\"rain\").map(function(str) {\n    return \"b\" + str\n})\n// Left(\"rain\")\n\nconsole.log(Right.of({host: 'localhost', port:80}).map(_.property('host')))\n// Right('localhost')\n\nconsole.log(Left.of(\"rolls eyes...\").map(_.property('host')))\n// Left('rolls eyes...')\n```\n\nLeft 就像是青春期少年那样无视我们要 map 它的请求。 Right 的作用就像是一个 Container （也就是 Identity）。这里强大的地方在于， Left 有能力在它内部嵌入一个错误消息。\n\n假设有一个可能会失败的函数，就拿根据生日计算年龄来说好了。的确，我们可以用 Maybe(null) 来表示失败并把程序引向另一个分支，但是这并没有告诉我们太多信息。很有可能我们想知道失败的原因是什么。\n\n```js\nlet getAge = curry(function(now, user) {\n    let birthdate = moment(user.birthdate, 'YYYY-MM-DD')\n    if(!birthdate.isValid()) {\n        return Left.of(\"Birth date could not be parsed\")\n    }\n    return Right.of(now.diff(birthdate, 'years'))\n})\n\nconsole.log(getAge(moment(), {birthdate: '1996-12-30'}))\n// Right(21)\nconsole.log(getAge(moment(), {birthdate: '12-30'}))\n// Left(\"Birth date could not be parsed\")\n```\n\n这么一来，就像 Maybe(null) ，当返回一个 Left 的时候就直接让程序短路。跟 Maybe(null) 不同的是，现在我们对程序为何脱离原先轨道至少有了一点头绪。有一件事要注意，这里返回的是 Either(String, Number) ，意味着我们这个 Either 左边Left的值是 String，右边Right，也就是正确的值，是 Number 。这个类型签名不是很正式，因为我们并没有定义一个真正的 Either父类；但我们还是从这个类型那里了解到不少东西。它告诉我们，我们得到的要么是一条错误消息，要么就是正确的值。\n\nPS：Rust里面也有类似的概念，对应于Result enum里的Ok，Err。\n\n```js\n// map 如之前所实现，会调用container的map方法\n// zoltar :: User -> Either(String, _)\nlet zoltar = compose(map(console.log), getAge(moment()))\n\nconsole.log(zoltar({birthdate: '1996-12-30'}))\n// 21\n// Right(undefined)\nconsole.log(zoltar({birthdate: 'balloons!'}))\n// Left(\"Birth date could not be parsed\")\n```\n\n如果 birthdate 合法，这个程序就会把它神秘的命运打印在屏幕上让我们见证；如果不合法，我们就会收到一个有着清清楚楚的错误消息的 Left ，尽管这个消息是稳稳当当地待在它的容器里的。这种行为就像，虽然我们在抛错，但是是以一种平静温和的方式抛错，而不是像一个小孩子那样，有什么不对劲就闹脾气大喊大叫。\n\n我们根据 birthdate 的合法性来控制代码的逻辑分支，同时又让代码进行从右到左的直线运动，而不用爬过各种条件语句的大括号。\n\n我们在 Right 分支的类型签名中使用 _ 表示一个应该忽略的值（在有些浏览器中，你必须要 console.log.bind(console) 才能把 console.log 当作一等公民使用）。\n\n这个例子中，尽管 fortune 使用了 Either ，它对每一个 functor 到底要干什么却是毫不知情的。通俗点来讲，一个函数在调用的时候，如果被map 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数。*我们把这个过程叫做 lift。*\n\n一般情况下，普通函数更适合操作普通的数据类型而不是容器类型，在必要的时候再通过 lift 变为合适的容器去操作容器类型。这样做的好处是能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor。\n\nEither 并不仅仅只对合法性检查这种一般性的错误作用非凡，对一些更严重的、能够中断程序执行的错误比如文件丢失或者 socket 连接断开等， Either 同样效果显著。\n\n它的能耐远不止于此。比如，它表示了逻辑或（也就是||）。再比如，它体现了范畴学里 coproduct 的概念。还比如，它是标准的 sum type（或者叫不交并集，disjoint union of sets），因为它含有的所有可能的值的总数就是它包含的那两种类型的总数。\n\nEither 能做的事情多着呢，但是作为一个 functor，我们就用它处理错误。\n\n就像 Maybe 可以有个 maybe 一样， Either 也可以有一个 either 。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。这两个函数的返回值类型一致：\n\n```js\nlet either = curry(function(f, g, e) {\n    switch(e.constructor) {\n        case Left: return f(e.__value)\n        case Right: return g(e.__value)\n    }\n})\n\nconst localStorage = Object.create(null)\n\n// getFromStorage :: String -> (_ -> String)\nlet getFromStorage = function(key) {\n    return function() {\n        return localStorage[key]\n    }\n}\n```\n\n要是我们没把 getFromStorage 包在另一个函数里，它的输出值就是不定的，会随外部环境变化而变化。有了这个结实的包裹函数（wrapper），同一个输入就总能返回同一个输出：一个从 localStorage 里取出某个特定的元素的函数。\n\n然而，这并没有多大的用处。就像是你收藏的全新未拆封的玩偶，不能拿出来玩有什么意思。所以要是能有办法进到这个容器里面，拿到它藏在那儿的东西就好了...办法是有的，请看 `IO`。\n\n```js\nlet IO = function(f) {\n    this.__value = f\n}\n\nIO.of = function(x) {\n    return new IO(function() {\n        return x\n    })\n}\n\nIO.prototype.map = function(f) {\n    return new IO(compose(f, this.__value))\n}\n```\n\nIO 跟之前的 functor 不同的地方在于，它的 __value 总是一个函数。不过我们不把它当作一个函数——实现的细节我们最好先不管。这里发生的事情跟我们在getFromStorage 那里看到的一模一样： IO 把非纯执行动作（impure action）捕获到包裹函数里，目的是延迟执行这个非纯动作。就这一点而言，我们认为 IO 包含的是被包裹的执行动作的返回值，而不是包裹函数本身。\n这在 of 函数里很明显： IO(function(){ return x }) 仅仅是为了延迟执行，其实我们得到的是 IO(x) 。\n\n```js\nlet io_window = new IO(function() {\n    return window\n})\n\nio_window.map(function(win) {\n    return window.innerWidth\n})\n// IO(1430)\n\nio_window2 = io_window.map(_.property('location'))\n        .map(_.property('href'))\n        .map(_.split('/'))\n// IO([\"http:\", \"\", \"localhost:8000\", \"blog\", \"posts\"])\n```\n\n这里， io_window 是一个真正的 IO ，我们可以直接对它使用 map 。我把这里的返回值都写成了概念性的，这样就更加直观；不过实际的返回值是 { __value: [Function] } 。当调用 IO 的 map 的时候，我们把传进来的函数放在了 map 函数里的组合的最末端（也就是最左边），反过来这个函数就成为了新的 IO 的新 value ，并继续下去。传给 map 的函数并没有运行，我们只是把它们压到一个“运行栈”的最末端而已，一个函数紧挨着另一个函数，就像小心摆放的多米诺骨牌一样，让人不敢轻易推倒。这种情形很容易叫人联想起“四人帮”（《设计模式》一书作者）提出的命令模式（command pattern）或者队列（queue）。\n\nIO 的 value 并不是它包含的值，也不是像两个下划线暗示那样是一个私有属性。value 是手榴弹的弹栓，只应该被调用者以最公开的方式拉动。为了提醒用户它的变化无常，我们把它重命名为 unsafePerformIO 看看\n\n```js\nlet IO = function(f) {\n    this.unsafePerformIO = f\n}\n\nIO.of = function(x) {\n    return new IO(function() {\n        return x\n    })\n}\n\nIO.prototype.map = function(f) {\n    return new IO(compose(f, this.unsafePerformIO))\n}\n```\n\n现在调用的代码对于应用程序的用户简直就直白得不能再直白了。\n\n之后我们将学习一种跟 IO 在精神上相似，但是用法上又千差万别的类型。\n\n### 异步任务\n\n处理异步代码，我们有一种更好的方式，它的名字以“F”开头。这种方式的内部机制过于复杂，复杂得哪怕我唾沫横飞也很难讲清楚。所以我们就直接用 Quildreen Motta 的 Folktale 里的 Data.Task。\n\n```js\nconst Folktale = require('folktale')\nconst Task = Folktale.concurrency.task\n\n// Node readfile example:\n//=======================\nconst fs = require('fs');\n// readFile :: String -> Task(Error, JSON)\nlet readFile = function(filename) {\n    return new Task(function(reject, result) {\n        fs.readFile(filename, 'utf-8', function(err, data) {\n            err ? reject(err) : result(data);\n        });\n    });\n};\nreadFile(\"metamorphosis\").map(split('\\n')).map(head);\n// Task(\"One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that\n\n// in bed he had been changed into a monstrous verminous bug.\")\n\n// jQuery getJSON example:\n//========================\n// getJSON :: String -> {} -> Task(Error, JSON)\nlet getJSON = curry(function(url, params) {\n    return new Task(function(reject, result) {\n        $.getJSON(url, params, result).fail(reject);\n    });\n});\n\ngetJSON('/video', {id: 10}).map(_.prop('title'));\n// Task(\"Family Matters ep 15\")\n// 传入普通的实际值也没问题\nTask.of(3).map(function(three){ return three + 1 });\n// Task(4)\n```\n\n例子中的 reject 和 result 函数分别是失败和成功的回调。正如你看到的，我们只是简单地调用 Task 的 map 函数，就能操作将来的值，好像这个值就在那儿似的。\n\n如果熟悉 promise 的话，你该能认出来 map 就是 then ， Task 就是一个promise。\n\n与 IO 类似， Task 在我们给它绿灯之前是不会运行的。事实上，正因为它要等我们的命令， IO 实际就被纳入到了 Task 名下，代表所有的异步操作—— readFile 和 getJSON 并不需要一个额外的 IO 容器来变纯。更重要的是，当我们调用它的 map 的时候， Task 工作的方式与 IO 几无差别：都是把对未来的操作的指示放在一个时间胶囊里，就像家务列表（chore chart）那样——\n真是一种精密的拖延术。\n\n我们必须调用 fork 方法才能运行 Task ，这种机制与 unsafePerformIO 类似。但也有不同，不同之处就像 fork 这个名称表明的那样，它会 fork 一个子进程运行它接收到的参数代码，其他部分的执行不受影响，主线程也不会阻塞。当然这种效果也可以用其他一些技术比如线程实现，但这里的这种方法工作起来就像是一个普通的异步调用，而且 event loop 能够不受影响地继续运转。\n\n```js\n// Pure application\n//=====================\n// blogTemplate :: String\n// blogPage :: Posts -> HTML\nlet blogPage = Handlebars.compile(blogTemplate);\n// renderPage :: Posts -> HTML\nlet renderPage = compose(blogPage, sortBy('date'));\n// blog :: Params -> Task(Error, HTML)\nlet blog = compose(map(renderPage), getJSON('/posts'));\n// Impure calling code\n//=====================\nblog({}).fork(\nfunction(error){ $(\"#error\").html(error.message); },\nfunction(page){ $(\"#main\").html(page); }\n);\n$('#spinner').show();\n```\n\n调用 fork 之后， Task 就赶紧跑去找一些文章，渲染到页面上。与此同时，我们在页面上展示一个 spinner，因为 fork 不会等收到响应了才执行它后面的代码。最后，我们要么把文章展示在页面上，要么就显示一个出错信息，视getJSON 请求是否成功而定。\n\n我们只需要从下读到上，从右读到左就能理解代码，即便这段程序实际上会在执行过程中到处跳来跳去。这种方式使得阅读和理解应用程序的代码比那种要在各种回调和错误处理代码块之间跳跃的方式容易得多。\n\n### 一点理论\n\nfunctor 的概念来自于范畴学，并满足一些定律。\n\n```js\n// identity\nmap(id) === id;\n// composition\ncompose(map(f), map(g)) === map(compose(f, g));\n```\n\n同一律很简单，但是也很重要。因为这些定律都是可运行的代码，所以我们完全可以在我们自己的 functor 上试验它们，验证它们是否成立。\n\n在范畴学中，functor 接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（identity），也一定能够组合态射；我们无须验证这一点，前面提到的定律保证这些东西会在映射后得到保留。\n\n可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。如果一个对象 a 属于源范畴 C ，那么通过 `functor F` 把 a 映射到目标范畴 D 上之后，就可以使用 `F a` 来指代 a 对象。\n\n![functor映射](functor映射.png)\n\n比如， Maybe 就把类型和函数的范畴映射到这样一个范畴：即每个对象都有可能不存在，每个态射都有空值检查的范畴。这个结果在代码中的实现方式是用 map 包裹每一个函数，用 functor 包裹每一个类型。这样就能保证每个普通的类型和函数都能在新环境下继续使用组合。\n\n从技术上讲，代码中的 functor 实际上是把范畴映射到了一个包含类型和函数的子范畴（sub category）上，使得这些 functor 成为了一种新的特殊的 endofunctor。可以用一张图来表示这种态射及其对象的映射。\n\n![functor映射2](functor映射2.png)\n\n这张图除了能表示态射借助 functor F 完成从一个范畴到另一个范畴的映射之外，我们发现它还符合交换律，也就是说，顺着箭头的方向往前，形成的每一个路径都指向同一个结果。不同的路径意味着不同的行为，但最终都会得到同一个数据类型。这种形式化给了我们原则性的方式去思考代码——无须分析和评估每一个单独的场景，只管可以大胆地应用公式即可。\n\n```js\n// topRoute :: String -> Maybe(String)\nlet topRoute = compose(Maybe.of, safeHead);\n\n// bottomRoute :: String -> Maybe(String) \nlet bottomRoute = compose(map(safeHead), Maybe.of);\n\nconsole.log(topRoute('hi'));\n// Maybe('h')\n\nconsole.log(bottomRoute('hi'));\n// Maybe('h')\n\n// topRoute :: String -> Maybe(String)\nlet topRoute = compose(Maybe.of, reverse);\n// bottomRoute :: String -> Maybe(String)\nlet bottomRoute = compose(map(reverse), Maybe.of);\n\ntopRoute(\"hi\");\n// Maybe(\"ih\")\nbottomRoute(\"hi\");\n// Maybe(\"ih\")\n```\n\n![functor映射实例](functor映射实例.png)\n\n根据所有 functor 都有的特性，我们可以立即理解代码，重构代码。\n\nfunctor 也能嵌套使用\n\n```js\nlet nested = Task.of([Right.of(\"pillows\"), Left.of(\"no sleep for you\")]);\n\nmap(map(map(toUpperCase)), nested);\n\nTask([Right(\"PILLOWS\"), Left(\"no sleep for you\")])\n\n```\nnested 是一个将来的数组，数组的元素有可能是程序抛出的错误。我们使用map 剥开每一层的嵌套，然后对数组的元素调用传递进去的函数。可以看到，这中间没有回调、 if/else 语句和 for 循环，只有一个明确的上下文。的确，我们必须要 map(map(map(f))) 才能最终运行函数。不想这么做的话，可以组合 functor。\n\n```js\nlet Compose = function(f_g_x) {\n    this.getCompose = f_g_x;\n}\n\nCompose.prototype.map = function(f) {\n    return new Compose(map(map(f), this.getCompose));\n}\n```\n\nfunctor 组合是符合结合律的，而且之前我们定义的 Container 实际上是一个叫 Identity 的 functor。identity 和可结合的组合也能产生一个范畴，这个特殊的范畴的对象是其他范畴，态射是 functor。\n\n### 总结\n\n我们已经认识了几个不同的 functor，但它们的数量其实是无限的。有一些值得注意的可迭代数据类型（iterable data structure）我们没有介绍，像 tree、list、map 和 pair 等，以及所有你能说出来的。eventstream 和 observable 也都是 functor。其他的 functor 可能就是拿来做封装或者仅仅是模拟类型。我们身边到处都有 functor的身影。\n\n用多个 functor 参数调用一个函数怎么样呢？处理一个由不纯的或者异步的操作组成的有序序列怎么样呢？要应对这个什么都装在盒子里的世界，目前我们工具箱里的工具还不全。下一章，我们将直奔 monad 而去。\n\n## 自我总结\n\nPS里面是自己的话。\n\n这部分的其实还有挺多的东西没有搞懂，书中许多代码其实是无法运行的，或者依赖很多编写成本很大。书里面还有一些题目，我也没有花时间进去。个人觉得这本书比一般的函数式书要深入，当然估计在Haskell书里，这些知识都很常规。其他的东西大部分都是书中的内容，我自己进行了少量地修改和较多地删减。\n\n最近在学习Rust和Haskell，打算寒假精力主要放在学习这2门语言特有的特性，说白了，就是安全性和函数式。\n但是这2门语言门槛其实都不低，2018年平时可能会投入一些精力去学习。寒假如果顺利，希望能用这些语言来复习数据结构的知识。\n下个学期特意选了一些偏实战专业课，打算把新学到的语言、特性和思想用起来。\n\n这本书最后还有2章，如果有机会，想在寒假看完。","source":"_posts/JS函数式编程笔记2.md","raw":"---\ntitle: JS函数式编程笔记2\ndate: 2018-2-7 14:27:31\ntags: [JS, FP]\ncategory: study\n---\n\n# JS函数式编程\n\n笔记里面常常依赖一些库和之前的代码，而且可能存在理论上的代码和未实现的函数，阅读时，需要仔细。\n\n下面部分经常的东西后面经常用到，我先导入。\n\n```js\nconst curry = require('lodash/curry')\nconst _ = require('lodash')\nconst fp = require('lodash/fp')\nconst moment = require('moment')\n\nlet compose = function(f, g){\n    return function(x){\n        return f(g(x))\n    }\n}\n\nlet toUpperCase = function(str){\n    return str.toUpperCase()\n}\n\nlet toLowerCase = function(str){\n    return str.toLowerCase()\n}\n```\n\n## Hindley-Milner 类型签名\n\n### 初识类型\n\n刚接触函数式编程的人很容易深陷类型签名（type signatures）的泥淖。类型（type）是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的。\n\n类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理（free theorems）” 的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。类型签名不但可以用于编译时检测（compile timechecks），还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色——重要程度远远超出你的想象。\n\n<!-- more -->\n\n```js\n// capitalize :: String -> String\nlet capitalize = function(s){\n   return toUpperCase(head(s)) + toLowerCase(tail(s))\n}\n\nconsole.log(capitalize(\"hello\"))\n```\n\n在 Hindley-Milner 系统中，函数都写成类似 a -> b 这个样子，其中 a 和 b是任意类型的变量。因此， capitalize 函数的类型签名可以理解为“一个接受String 返回 String 的函数”。换句话说，它接受一个 String 类型作为输入，并返回一个 String 类型的输出、\n\n*PS：Haskell里面HM类型签名作为类型约束语法（type constraints）是很常见的。*\n\n```js\n// strLength :: String -> Number\nlet strLength = function(s){\n   return s.length\n}\n\n// join :: String -> [String] -> String\nlet join = curry(function(what, xs){\n   xs.join(what)\n})\n\n// match :: Regex -> String -> [String]\nlet match = curry(function(reg, s){\n   return s.match(reg)\n})\n\n// replace :: Regex -> String -> String -> String\nlet replace = curry(function(reg, sub, s){\n    return s.replace(reg, sub)\n})\nconsole.log(replace(/world/ig)('JS')('hello world'))\n```\n\nstrLength 和 capitalize 类似：接受一个 String 然后返回一个Number 。至于其他的，第一眼看起来可能会比较疑惑。不过在还不完全了解细节的情况下，你尽可能把最后一个类型视作返回值。那么 match 函数就可以这么理解：它接受一个 Regex 和一个 String ，返回一个 [String] 。\n\n这里有一个非常有趣的地方，对于 match 函数，我们完全可以把它的类型签名这样分组 \n```js\n// match :: Regex -> (String -> [String])\nlet match = curry(function(reg, s){\n    return s.match(reg)\n })\n```\n\n是的，把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出match 这个函数接受一个 Regex 作为参数，返回一个从 String 到 [String] 的函数。因为 curry，造成的结果就是这样：给 match 函数一个Regex ，得到一个新函数，能够处理其 String 参数。当然了，我们并非一定要这么看待这个过程，但这样思考有助于理解为何最后一个类型是返回值。\n\n```js\n// onHoliday :: String -> [String]\nlet onHoliday = match(/holiday/ig)\nconsole.log(onHoliday('hello holiday'))\n```\n\n每传一个参数，就会弹出类型签名最前面的那个类型。所以 onHoliday 就是已经有了 Regex 参数的 match 。\n\nPS：我最近刚开始学习Haskell，Haskell里面所有函数都是auto-curried的。配合HM签名效果感觉很强大。\n\n```js\n// replace :: Regex -> (String -> (String -> String))\nlet replace = curry(function(reg, sub, s){\n    return s.replace(reg, sub);\n})\n```\n\n但是在这段代码中，就像你看到的那样，为 replace 加上这么多括号未免有些多余。所以这里的括号是完全可以省略的，如果我们愿意，可以一次性把所有的参数都传进来；所以，一种更简单的思路是： replace 接受三个参数，分别是 Regex 、 String 和另一个 String ，返回的还是一个 String 。\n\n```js\n// id :: a -> a\nlet id = function(x){ return x }\n// map :: (a -> b) -> [a] -> [b]\nlet map = curry(function(f, xs){\n    return xs.map(f)\n})\n\nconsole.log(map((x) => x * 2)([1,2,3]))\n```\n\n这里的 id 函数接受任意类型的 a 并返回同一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 a 和 b 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的一个原则，所以我们必须重申： a -> b 可以是从任意类型的 a 到任意类型的 b ，但是 a -> a 必须是同一个类型。例如， id 可以是 String -> String ，也可以是 Number -> Number ，但不能是 String -> Bool 。\n\n相似地， map 也使用了变量，只不过这里的 b 可能与 a 类型相同，也可能不相同。我们可以这么理解： map 接受两个参数，第一个是从任意类型 a 到任意类型 b 的函数；第二个是一个数组，元素是任意类型的 a ； map 最后返回的是一个类型 b 的数组。\n\n辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。\n\n```js\n// head :: [a] -> a\nlet head = function(xs){ return xs[0]}\n\n// filter :: (a -> Bool) -> [a] -> [a]\nlet filter = curry(function(f, xs){\n    return xs.filter(f)\n})\n\n// reduce :: (b -> a -> b) -> b -> [a] -> b\nlet reduce = curry(function(f, x, xs){\n    return xs.reduce(f, x)\n})\n```\n\n注意看 reduce 的签名，可以看到它的第一个参数是个函数，这个函数接受一个 b 和一个 a 并返回一个 b 。那么这些 a 和 b 是从哪来的呢？很简单，签名中的第二个和第三个参数就是 b 和元素为 a 的数组，所以唯一合理的假设就是这里的 b 和每一个 a 都将传给前面说的函数作为参数。我们还可以看到， reduce 函数最后返回的结果是一个b ，也就是说， reduce 的第一个参数函数的输出就是 reduce 函数的输出。知道了 reduce 的含义，我们才敢说上面关于类型签名的推理是正确的。\n\n```js\nconsole.log(reduce((b, a) => a * b)(3)([1, 2, 3]))\nconsole.log([1, 2, 3].reduce((b, a) => a * b, 3))\n```\n\n### 缩小可能性范围\n\n一旦引入一个类型变量，就会出现一个奇怪的特性叫做 parametricity（http://en.wikipedia.org/wiki/Parametricity ）。这个特性表明，函数将会以一种统一的行为作用于所有的类型。\n\na 告诉我们它不是一个特定的类型，这意味着它可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一。这就是 parametricity 的含义。\n\n这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 Hoogle 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。\n\n*PS: Hoogle是Haskell官网中搜索文档的搜索引擎。*\n\n### 自由定理\n\n类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理（free theorems）。\n```js\n// head :: [a] -> a\ncompose(f, head) == compose(head, map(f));\n// filter :: (a -> Bool) -> [a] -> [a]\ncompose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));\n```\n\n不用写一行代码你也能理解这些定理，它们直接来自于类型本身。\n\n*PS: 这些函数是纯的才能成立。*\n\n第一个例子中，等式左边说的是，先获取数组的第一个元素，然后对它调用函数 f ；等式右边说的是，先对数组中的每一个元素调用 f ，然后再取其返回结果的头部 。这两个表达式的作用是相等的，但是前者要快得多。\n\n第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，然后再通过 map 实际调用 f （别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；等式右边是说，先用 map 调用 f ，然后再根据 p 过滤元素。这两者也是相等的。\n\n### 类型约束\n\n最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。\n\n```js\n// sort :: Ord a => [a] -> [a]\n```\n\n胖箭头左边表明的是这样一个事实： a 一定是个 Ord 对象。也就是说， a 必须要实现 Ord 接口。 Ord 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 a 的更多信息，了解 sort 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束（type constraints）。\n\nPS：Haskell里面存在Ord类型类，Rust里面也有类似的东西。\n\n```js\n// assertEqual :: (Eq a, Show a) => a -> a -> Assertion\n```\n\n### 总结\n\nHindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更需要花点时间了。\n\n\n## 特百惠\n\n### 强大的容器\n\n我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？\n\n首先我们将创建一个容器（container）。这个容器必须能够装载任意类型的值。这个容器将会是一个对象，但我们不会为它添加面向对象观念下的属性和方法。\n\n```js\nlet Container = function(x) {\n    this.__value = x\n}\n\nContainer.of = function(x) {\n    return new Container(x)\n}\n```\n\n\n我们将使用 Container.of 作为构造器（constructor），这样就不用到处去写糟糕的 new 关键字了，非常省心。 实际上不能这么简单地看待 of 函数，但暂时先认为它是把值放到容器里的一种方式。\n\n```js\nContainer.of(3)\n//=> Container(3)\nContainer.of(\"hotdogs\")\n//=> Container(\"hotdogs\")\nContainer.of(Container.of({name: \"yoda\"}))\n//=> Container(Container({name: \"yoda\" }))\n```\n\n在继续后面的内容之前，先澄清几点：\nContainer 是个只有一个属性的对象。尽管容器可以有不止一个的属性，但大多数容器还是只有一个。我们很随意地把 Container 的这个属性命名为 __value。__value 不能是某个特定的类型，不然 Container 就对不起它这个名字了。数据一旦存放到 Container ，就会一直待在那儿。我们可以用 .__value 获取到数据，但这样做有悖初衷。\n\n### 第一个 functor(函子)\n\n一旦容器里有了值，不管这个值是什么，我们就需要一种方法来让别的函数能够操作它。\n\n```js\n// (a -> b) -> Container a -> Container b\nContainer.prototype.map = function(f) {\n    return Container.of(f(Container.__value))\n}\n\n// 这个 map 跟数组那个著名的 map 一样，除了前者的参数是 Container a 而后者是 [a] 。它们的使用方式也几乎一致\nconsole.log(Container.of(2).map(num => num + 2))\nconsole.log(Container.of('hello').map(str => str.toUpperCase()))\n```\n\n为什么要使用这样一种方法？因为我们能够在不离开 Container 的情况下操作容器里面的值。这是非常了不起的一件事情。 Container 里的值传递给 map 函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的 Container。这样做的结果是，我们能连续地调用 map ，运行任何我们想运行的函数，甚至还可以改变值的类型。\n\n如果我们能一直调用 map ，那它不就是个组合（composition）么！这里边是有什么数学魔法在起作用？是 `functor`。各位，这个数学魔法就是 functor。\n\n*functor 是实现了 map 函数并遵守一些特定规则的容器类型。*\n\n没错，functor 就是一个签了合约的接口。functor 是范畴学里的概念。\n\n把值装进一个容器，而且只能使用 map 来处理它，这么做的理由到底是什么呢？如果我们换种方式来问，答案就很明显了：让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。\n\n### 薛定谔的 Maybe\n\n说实话 Container 挺无聊的，而且通常我们称它为 Identity ，与 id 函数的作用相同（这里也是有数学上的联系的）。除此之外，还有另外一种 functor，那就是实现了 map 函数的类似容器的数据类型，这种 functor 在调用 map 的时候能够提供非常有用的行为。现在让我们来定义一个这样的 functor。\n\n\n```js\nlet Maybe = function(x) {\n    this.__value = x\n}\n\nMaybe.of = function(x) {\n    return new Maybe(x)\n}\n\nMaybe.prototype.isNothing = function() {\n    return (this.__value === null) || (this.__value === undefined)\n}\n\nMaybe.prototype.map = function(f) {\n    return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value))\n}\n```\n\nMaybe 会先检查自己的值是否为空，然后才调用传进来的函数。这样我们在使用 map 的时候就能避免恼人的空值了（这个实现出于教学目的做了简化）。\n\n```js\nconsole.log(Maybe.of('Malkovich Malkovich').map(match(/a/ig)))\nconsole.log(Maybe.of(null).map(match(/a/ig)))\nconsole.log(Maybe.of({name: \"Dinah\", age: 14}).map(_.property('age')))\n```\n\n当传给 map 的值是 null 时，代码并没有爆出错误。这是因为每一次 Maybe 要调用函数的时候，都会先检查它自己的值是否为空。\n\n这种点记法（dot notation syntax）已经足够函数式了，但是正如在第 1 部分指出的那样，我们更想保持一种 pointfree 的风格。碰巧的是， map 完全有能力以 curry 函数的方式来“代理”任何 functor。\n\n```js\n// map :: Functor f => (a -> b) -> f a -> f b\nmap = curry(function(f, any_functor_at_all) {\n    return any_functor_at_all.map(f)\n})\n```\n\n这样我们就可以像平常一样使用组合，同时也能正常使用 map 了，非常振奋人心。`ramda` 的 map 也是这样。后面的，我们将在点记法更有教育意义的时候使用点记法，在方便使用 pointfree 模式的时候就用 pointfree。你注意到了么？我在类型标签中偷偷引入了一个额外的标记： Functor f => 。这个标记告诉我们 f 必须是一个 functor。\n\n用例\n\n```js\n// safeHead :: [a] -> Maybe(a)\nlet safeHead = function(xs) {\n    return Maybe.of(xs[0])\n}\n\nlet streetName = compose(compose(map(_.property('street')), safeHead), _.property('addresses'))\n\nconsole.log(streetName({addresses:[]}))\n// Maybe(null)\n\nconsole.log(streetName({addresses: [{street: \"Shady Ln.\", number: 4201}]}))\n// Maybe(\"Shady Ln.\")\n\n```\n\nsafeHead 与一般的 _.head 类似，但是增加了类型安全保证。引入 Maybe 会发生一件非常有意思的事情，那就是我们被迫要与狡猾的 null 打交道了。 safeHead 函数能够诚实地预告它可能的失败,然后返回一个 Maybe 来通知我们相关信息。实际上不仅仅是通知，因为毕竟我们想要的值深藏在 Maybe 对象中，而且只能通过 map 来操作它。*本质上，这是一种由 safeHead 强制执行的空值检查。* 类似这样的 API 能够把一个像纸糊起来的、脆弱的应用升级为实实在在的、健壮的应用，这样的 API 保证了更加安全的软件。\n\n有时候函数可以明确返回一个 Maybe(null) 来表明失败\n\n```js\n// withdraw :: Number -> Account -> Maybe(Account)\nlet withdraw = curry(function(amount, account){\n    return account.balance >= account ?\n        Maybe.of({account: account.balance - account}) :\n        Maybe.of(null)\n})\n\n// finishTransaction :: Account -> String\nlet finishTransaction = compose(remainingBalance, updateLedger)\n// <- 假定这两个函数已经在别处定义好了\n\n// getTwenty :: Account -> Maybe(String)\nlet getTwenty = compose(map(finishTransaction), withdraw(20))\n\ngetTwenty({ balance: 200.00})\n// Maybe(\"Your balance is $180.00\")\n\ngetTwenty({ balance: 10.00})\n// Maybe(null)\n```\n\nwithdraw 也显示出了它的多变性，使得我们后续的操作只能用 map 来进行。这个例子与前面例子不同的地方在于，这里的 null 是有意的。我们不用 Maybe(String) ，而是用 Maybe(null)来发送失败的信号，这样程序在收到信号后就能立刻停止执行。这一点很重要：如果 withdraw 失败了，map 就会切断后续代码的执行，因为它根本就不会运行传递给它的函数，即finishTransaction 。这正是预期的效果：如果取款失败，我们并不想更新或者显示账户余额。\n\n### 释放容器里的值\n\n人们经常忽略的一个事实是：任何事物都有个最终尽头。那些会产生作用的函数，不管它们是发送 JSON 数据，还是在屏幕上打印东西，还是更改文件系统，还是别的什么，都要有一个结束。但是我们无法通过 return 把输出传递到外部世界，必须要运行这样或那样的函数才能传递出去。\n\n应用程序所做的工作就是获取、更改和保存数据直到不再需要它们，对数据做这些操作的函数有可能被 map 调用，这样的话数据就可以不用离开它温暖舒适的容器。讽刺的是，有一种常见的错误就是试图以各种方法删除 Maybe 里的值，好像这个不确定的值是魔鬼，删除它就能让它突然显形，然后一切罪恶都会得到宽恕似的（此处原文应该是源自圣经）。要知道，我们的值没有完成它的使命，很有可能是其他代码分支造成的。我们的代码，就像薛定谔的猫一样，在某个特定的时间点有两种状态，而且应该保持这种状况不变直到最后一个函数为止。这样，哪怕代码有很多逻辑性的分支，也能保证一种线性的工作流。\n\n不过，对容器里的值来说，还是有个逃生口可以出去。也就是说，如果我们想返回一个自定义的值然后还能继续执行后面的代码的话，是可以做到的；要达到这一目的，可以借助一个帮助函数 maybe ：\n\n```js\n// maybe :: b -> (a -> b) -> Maybe a -> b\nlet maybe = _.curry(function(x, f, m){\n    return m.isNothing() ? x : f(m.__value)\n})\n\n// getTwenty :: Account -> String\nlet getTwenty = compose(maybe(\"You're broke!\", finishTransaction), withdraw(20))\n\ngetTwenty({ balance: 200.00});\n// \"Your balance is $180.00\"\ngetTwenty({ balance: 10.00});\n// \"You're broke!\"\n```\n\n这样就可以要么返回一个静态值（与 finishTransaction 返回值的类型一致），要么继续愉快地在没有 Maybe 的情况下完成交易。 maybe 使我们得以避免普通 map 那种命令式的 if/else 语句： if(x !== null) { return f(x) } 。\n\n引入 Maybe 可能会在初期造成一些不适。Swift 和 Scala 用户知道我在说什么，因为这两门语言的核心库里就有 Maybe 的概念，只不过伪装成 Option(al) 罢了。\n\n*PS：Haskell 里面有Maybe，Rust里面也是类似伪装成 Option。*\n\n被迫在任何情况下都进行空值检查，的确让大部分人头疼不已。然而随着时间推移，空值检查会成为第二本能，不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。\n\nMaybe 能够非常有效地帮助我们增加函数的安全性。\n\n有一点我必须要提及，否则就太不负责任了，那就是 Maybe 的“真正”实现会把它分为两种类型：一种是非空值，另一种是空值。这种实现允许我们遵守 map 的 parametricity 特性，因此 null 和 undefined 能够依然被 map 调用，functor 里的值所需的那种普遍性条件也能得到满足。所以你会经常看到 Some(x) / None 或者 Just(x) / Nothing 这样的容器类型在做空值检查，而不是Maybe 。\n\n### “纯”错误处理\n\n说出来可能会让你震惊， throw/catch 并不十分“纯”。当一个错误抛出的时候，我们没有收到返回值，反而是得到了一个警告！\n\n有了 Either 这个新朋友，我们就能以一种好得多的方式来处理错误，那就是返回一条非常礼貌的消息作为回应。\n\n```js\nlet Left = function(x) {\n    this.__value = x\n}\n\nLeft.of = function(x) {\n    return new Left(x)\n}\n\nLeft.prototype.map = function(f) {\n    return this\n}\n\nlet Right = function(x) {\n    this.__value = x\n}\n\nRight.of = function(x) {\n    return new Right(x)\n}\n\nRight.prototype.map = function(f) {\n    return Right.of(f(this.__value))\n}\n\n// Left 和 Right 是我们称之为 Either 的抽象类型的两个子类。\nlet right = Right.of(\"rain\").map(function(str) {\n    return \"b\" + str\n})\n// Right(\"brain\")\n\nlet left = Left.of(\"rain\").map(function(str) {\n    return \"b\" + str\n})\n// Left(\"rain\")\n\nconsole.log(Right.of({host: 'localhost', port:80}).map(_.property('host')))\n// Right('localhost')\n\nconsole.log(Left.of(\"rolls eyes...\").map(_.property('host')))\n// Left('rolls eyes...')\n```\n\nLeft 就像是青春期少年那样无视我们要 map 它的请求。 Right 的作用就像是一个 Container （也就是 Identity）。这里强大的地方在于， Left 有能力在它内部嵌入一个错误消息。\n\n假设有一个可能会失败的函数，就拿根据生日计算年龄来说好了。的确，我们可以用 Maybe(null) 来表示失败并把程序引向另一个分支，但是这并没有告诉我们太多信息。很有可能我们想知道失败的原因是什么。\n\n```js\nlet getAge = curry(function(now, user) {\n    let birthdate = moment(user.birthdate, 'YYYY-MM-DD')\n    if(!birthdate.isValid()) {\n        return Left.of(\"Birth date could not be parsed\")\n    }\n    return Right.of(now.diff(birthdate, 'years'))\n})\n\nconsole.log(getAge(moment(), {birthdate: '1996-12-30'}))\n// Right(21)\nconsole.log(getAge(moment(), {birthdate: '12-30'}))\n// Left(\"Birth date could not be parsed\")\n```\n\n这么一来，就像 Maybe(null) ，当返回一个 Left 的时候就直接让程序短路。跟 Maybe(null) 不同的是，现在我们对程序为何脱离原先轨道至少有了一点头绪。有一件事要注意，这里返回的是 Either(String, Number) ，意味着我们这个 Either 左边Left的值是 String，右边Right，也就是正确的值，是 Number 。这个类型签名不是很正式，因为我们并没有定义一个真正的 Either父类；但我们还是从这个类型那里了解到不少东西。它告诉我们，我们得到的要么是一条错误消息，要么就是正确的值。\n\nPS：Rust里面也有类似的概念，对应于Result enum里的Ok，Err。\n\n```js\n// map 如之前所实现，会调用container的map方法\n// zoltar :: User -> Either(String, _)\nlet zoltar = compose(map(console.log), getAge(moment()))\n\nconsole.log(zoltar({birthdate: '1996-12-30'}))\n// 21\n// Right(undefined)\nconsole.log(zoltar({birthdate: 'balloons!'}))\n// Left(\"Birth date could not be parsed\")\n```\n\n如果 birthdate 合法，这个程序就会把它神秘的命运打印在屏幕上让我们见证；如果不合法，我们就会收到一个有着清清楚楚的错误消息的 Left ，尽管这个消息是稳稳当当地待在它的容器里的。这种行为就像，虽然我们在抛错，但是是以一种平静温和的方式抛错，而不是像一个小孩子那样，有什么不对劲就闹脾气大喊大叫。\n\n我们根据 birthdate 的合法性来控制代码的逻辑分支，同时又让代码进行从右到左的直线运动，而不用爬过各种条件语句的大括号。\n\n我们在 Right 分支的类型签名中使用 _ 表示一个应该忽略的值（在有些浏览器中，你必须要 console.log.bind(console) 才能把 console.log 当作一等公民使用）。\n\n这个例子中，尽管 fortune 使用了 Either ，它对每一个 functor 到底要干什么却是毫不知情的。通俗点来讲，一个函数在调用的时候，如果被map 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数。*我们把这个过程叫做 lift。*\n\n一般情况下，普通函数更适合操作普通的数据类型而不是容器类型，在必要的时候再通过 lift 变为合适的容器去操作容器类型。这样做的好处是能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor。\n\nEither 并不仅仅只对合法性检查这种一般性的错误作用非凡，对一些更严重的、能够中断程序执行的错误比如文件丢失或者 socket 连接断开等， Either 同样效果显著。\n\n它的能耐远不止于此。比如，它表示了逻辑或（也就是||）。再比如，它体现了范畴学里 coproduct 的概念。还比如，它是标准的 sum type（或者叫不交并集，disjoint union of sets），因为它含有的所有可能的值的总数就是它包含的那两种类型的总数。\n\nEither 能做的事情多着呢，但是作为一个 functor，我们就用它处理错误。\n\n就像 Maybe 可以有个 maybe 一样， Either 也可以有一个 either 。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。这两个函数的返回值类型一致：\n\n```js\nlet either = curry(function(f, g, e) {\n    switch(e.constructor) {\n        case Left: return f(e.__value)\n        case Right: return g(e.__value)\n    }\n})\n\nconst localStorage = Object.create(null)\n\n// getFromStorage :: String -> (_ -> String)\nlet getFromStorage = function(key) {\n    return function() {\n        return localStorage[key]\n    }\n}\n```\n\n要是我们没把 getFromStorage 包在另一个函数里，它的输出值就是不定的，会随外部环境变化而变化。有了这个结实的包裹函数（wrapper），同一个输入就总能返回同一个输出：一个从 localStorage 里取出某个特定的元素的函数。\n\n然而，这并没有多大的用处。就像是你收藏的全新未拆封的玩偶，不能拿出来玩有什么意思。所以要是能有办法进到这个容器里面，拿到它藏在那儿的东西就好了...办法是有的，请看 `IO`。\n\n```js\nlet IO = function(f) {\n    this.__value = f\n}\n\nIO.of = function(x) {\n    return new IO(function() {\n        return x\n    })\n}\n\nIO.prototype.map = function(f) {\n    return new IO(compose(f, this.__value))\n}\n```\n\nIO 跟之前的 functor 不同的地方在于，它的 __value 总是一个函数。不过我们不把它当作一个函数——实现的细节我们最好先不管。这里发生的事情跟我们在getFromStorage 那里看到的一模一样： IO 把非纯执行动作（impure action）捕获到包裹函数里，目的是延迟执行这个非纯动作。就这一点而言，我们认为 IO 包含的是被包裹的执行动作的返回值，而不是包裹函数本身。\n这在 of 函数里很明显： IO(function(){ return x }) 仅仅是为了延迟执行，其实我们得到的是 IO(x) 。\n\n```js\nlet io_window = new IO(function() {\n    return window\n})\n\nio_window.map(function(win) {\n    return window.innerWidth\n})\n// IO(1430)\n\nio_window2 = io_window.map(_.property('location'))\n        .map(_.property('href'))\n        .map(_.split('/'))\n// IO([\"http:\", \"\", \"localhost:8000\", \"blog\", \"posts\"])\n```\n\n这里， io_window 是一个真正的 IO ，我们可以直接对它使用 map 。我把这里的返回值都写成了概念性的，这样就更加直观；不过实际的返回值是 { __value: [Function] } 。当调用 IO 的 map 的时候，我们把传进来的函数放在了 map 函数里的组合的最末端（也就是最左边），反过来这个函数就成为了新的 IO 的新 value ，并继续下去。传给 map 的函数并没有运行，我们只是把它们压到一个“运行栈”的最末端而已，一个函数紧挨着另一个函数，就像小心摆放的多米诺骨牌一样，让人不敢轻易推倒。这种情形很容易叫人联想起“四人帮”（《设计模式》一书作者）提出的命令模式（command pattern）或者队列（queue）。\n\nIO 的 value 并不是它包含的值，也不是像两个下划线暗示那样是一个私有属性。value 是手榴弹的弹栓，只应该被调用者以最公开的方式拉动。为了提醒用户它的变化无常，我们把它重命名为 unsafePerformIO 看看\n\n```js\nlet IO = function(f) {\n    this.unsafePerformIO = f\n}\n\nIO.of = function(x) {\n    return new IO(function() {\n        return x\n    })\n}\n\nIO.prototype.map = function(f) {\n    return new IO(compose(f, this.unsafePerformIO))\n}\n```\n\n现在调用的代码对于应用程序的用户简直就直白得不能再直白了。\n\n之后我们将学习一种跟 IO 在精神上相似，但是用法上又千差万别的类型。\n\n### 异步任务\n\n处理异步代码，我们有一种更好的方式，它的名字以“F”开头。这种方式的内部机制过于复杂，复杂得哪怕我唾沫横飞也很难讲清楚。所以我们就直接用 Quildreen Motta 的 Folktale 里的 Data.Task。\n\n```js\nconst Folktale = require('folktale')\nconst Task = Folktale.concurrency.task\n\n// Node readfile example:\n//=======================\nconst fs = require('fs');\n// readFile :: String -> Task(Error, JSON)\nlet readFile = function(filename) {\n    return new Task(function(reject, result) {\n        fs.readFile(filename, 'utf-8', function(err, data) {\n            err ? reject(err) : result(data);\n        });\n    });\n};\nreadFile(\"metamorphosis\").map(split('\\n')).map(head);\n// Task(\"One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that\n\n// in bed he had been changed into a monstrous verminous bug.\")\n\n// jQuery getJSON example:\n//========================\n// getJSON :: String -> {} -> Task(Error, JSON)\nlet getJSON = curry(function(url, params) {\n    return new Task(function(reject, result) {\n        $.getJSON(url, params, result).fail(reject);\n    });\n});\n\ngetJSON('/video', {id: 10}).map(_.prop('title'));\n// Task(\"Family Matters ep 15\")\n// 传入普通的实际值也没问题\nTask.of(3).map(function(three){ return three + 1 });\n// Task(4)\n```\n\n例子中的 reject 和 result 函数分别是失败和成功的回调。正如你看到的，我们只是简单地调用 Task 的 map 函数，就能操作将来的值，好像这个值就在那儿似的。\n\n如果熟悉 promise 的话，你该能认出来 map 就是 then ， Task 就是一个promise。\n\n与 IO 类似， Task 在我们给它绿灯之前是不会运行的。事实上，正因为它要等我们的命令， IO 实际就被纳入到了 Task 名下，代表所有的异步操作—— readFile 和 getJSON 并不需要一个额外的 IO 容器来变纯。更重要的是，当我们调用它的 map 的时候， Task 工作的方式与 IO 几无差别：都是把对未来的操作的指示放在一个时间胶囊里，就像家务列表（chore chart）那样——\n真是一种精密的拖延术。\n\n我们必须调用 fork 方法才能运行 Task ，这种机制与 unsafePerformIO 类似。但也有不同，不同之处就像 fork 这个名称表明的那样，它会 fork 一个子进程运行它接收到的参数代码，其他部分的执行不受影响，主线程也不会阻塞。当然这种效果也可以用其他一些技术比如线程实现，但这里的这种方法工作起来就像是一个普通的异步调用，而且 event loop 能够不受影响地继续运转。\n\n```js\n// Pure application\n//=====================\n// blogTemplate :: String\n// blogPage :: Posts -> HTML\nlet blogPage = Handlebars.compile(blogTemplate);\n// renderPage :: Posts -> HTML\nlet renderPage = compose(blogPage, sortBy('date'));\n// blog :: Params -> Task(Error, HTML)\nlet blog = compose(map(renderPage), getJSON('/posts'));\n// Impure calling code\n//=====================\nblog({}).fork(\nfunction(error){ $(\"#error\").html(error.message); },\nfunction(page){ $(\"#main\").html(page); }\n);\n$('#spinner').show();\n```\n\n调用 fork 之后， Task 就赶紧跑去找一些文章，渲染到页面上。与此同时，我们在页面上展示一个 spinner，因为 fork 不会等收到响应了才执行它后面的代码。最后，我们要么把文章展示在页面上，要么就显示一个出错信息，视getJSON 请求是否成功而定。\n\n我们只需要从下读到上，从右读到左就能理解代码，即便这段程序实际上会在执行过程中到处跳来跳去。这种方式使得阅读和理解应用程序的代码比那种要在各种回调和错误处理代码块之间跳跃的方式容易得多。\n\n### 一点理论\n\nfunctor 的概念来自于范畴学，并满足一些定律。\n\n```js\n// identity\nmap(id) === id;\n// composition\ncompose(map(f), map(g)) === map(compose(f, g));\n```\n\n同一律很简单，但是也很重要。因为这些定律都是可运行的代码，所以我们完全可以在我们自己的 functor 上试验它们，验证它们是否成立。\n\n在范畴学中，functor 接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（identity），也一定能够组合态射；我们无须验证这一点，前面提到的定律保证这些东西会在映射后得到保留。\n\n可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。如果一个对象 a 属于源范畴 C ，那么通过 `functor F` 把 a 映射到目标范畴 D 上之后，就可以使用 `F a` 来指代 a 对象。\n\n![functor映射](functor映射.png)\n\n比如， Maybe 就把类型和函数的范畴映射到这样一个范畴：即每个对象都有可能不存在，每个态射都有空值检查的范畴。这个结果在代码中的实现方式是用 map 包裹每一个函数，用 functor 包裹每一个类型。这样就能保证每个普通的类型和函数都能在新环境下继续使用组合。\n\n从技术上讲，代码中的 functor 实际上是把范畴映射到了一个包含类型和函数的子范畴（sub category）上，使得这些 functor 成为了一种新的特殊的 endofunctor。可以用一张图来表示这种态射及其对象的映射。\n\n![functor映射2](functor映射2.png)\n\n这张图除了能表示态射借助 functor F 完成从一个范畴到另一个范畴的映射之外，我们发现它还符合交换律，也就是说，顺着箭头的方向往前，形成的每一个路径都指向同一个结果。不同的路径意味着不同的行为，但最终都会得到同一个数据类型。这种形式化给了我们原则性的方式去思考代码——无须分析和评估每一个单独的场景，只管可以大胆地应用公式即可。\n\n```js\n// topRoute :: String -> Maybe(String)\nlet topRoute = compose(Maybe.of, safeHead);\n\n// bottomRoute :: String -> Maybe(String) \nlet bottomRoute = compose(map(safeHead), Maybe.of);\n\nconsole.log(topRoute('hi'));\n// Maybe('h')\n\nconsole.log(bottomRoute('hi'));\n// Maybe('h')\n\n// topRoute :: String -> Maybe(String)\nlet topRoute = compose(Maybe.of, reverse);\n// bottomRoute :: String -> Maybe(String)\nlet bottomRoute = compose(map(reverse), Maybe.of);\n\ntopRoute(\"hi\");\n// Maybe(\"ih\")\nbottomRoute(\"hi\");\n// Maybe(\"ih\")\n```\n\n![functor映射实例](functor映射实例.png)\n\n根据所有 functor 都有的特性，我们可以立即理解代码，重构代码。\n\nfunctor 也能嵌套使用\n\n```js\nlet nested = Task.of([Right.of(\"pillows\"), Left.of(\"no sleep for you\")]);\n\nmap(map(map(toUpperCase)), nested);\n\nTask([Right(\"PILLOWS\"), Left(\"no sleep for you\")])\n\n```\nnested 是一个将来的数组，数组的元素有可能是程序抛出的错误。我们使用map 剥开每一层的嵌套，然后对数组的元素调用传递进去的函数。可以看到，这中间没有回调、 if/else 语句和 for 循环，只有一个明确的上下文。的确，我们必须要 map(map(map(f))) 才能最终运行函数。不想这么做的话，可以组合 functor。\n\n```js\nlet Compose = function(f_g_x) {\n    this.getCompose = f_g_x;\n}\n\nCompose.prototype.map = function(f) {\n    return new Compose(map(map(f), this.getCompose));\n}\n```\n\nfunctor 组合是符合结合律的，而且之前我们定义的 Container 实际上是一个叫 Identity 的 functor。identity 和可结合的组合也能产生一个范畴，这个特殊的范畴的对象是其他范畴，态射是 functor。\n\n### 总结\n\n我们已经认识了几个不同的 functor，但它们的数量其实是无限的。有一些值得注意的可迭代数据类型（iterable data structure）我们没有介绍，像 tree、list、map 和 pair 等，以及所有你能说出来的。eventstream 和 observable 也都是 functor。其他的 functor 可能就是拿来做封装或者仅仅是模拟类型。我们身边到处都有 functor的身影。\n\n用多个 functor 参数调用一个函数怎么样呢？处理一个由不纯的或者异步的操作组成的有序序列怎么样呢？要应对这个什么都装在盒子里的世界，目前我们工具箱里的工具还不全。下一章，我们将直奔 monad 而去。\n\n## 自我总结\n\nPS里面是自己的话。\n\n这部分的其实还有挺多的东西没有搞懂，书中许多代码其实是无法运行的，或者依赖很多编写成本很大。书里面还有一些题目，我也没有花时间进去。个人觉得这本书比一般的函数式书要深入，当然估计在Haskell书里，这些知识都很常规。其他的东西大部分都是书中的内容，我自己进行了少量地修改和较多地删减。\n\n最近在学习Rust和Haskell，打算寒假精力主要放在学习这2门语言特有的特性，说白了，就是安全性和函数式。\n但是这2门语言门槛其实都不低，2018年平时可能会投入一些精力去学习。寒假如果顺利，希望能用这些语言来复习数据结构的知识。\n下个学期特意选了一些偏实战专业课，打算把新学到的语言、特性和思想用起来。\n\n这本书最后还有2章，如果有机会，想在寒假看完。","slug":"JS函数式编程笔记2","published":1,"updated":"2018-02-07T10:28:30.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y8b000k6svsz3hvktfo","content":"<h1 id=\"JS函数式编程\"><a href=\"#JS函数式编程\" class=\"headerlink\" title=\"JS函数式编程\"></a>JS函数式编程</h1><p>笔记里面常常依赖一些库和之前的代码，而且可能存在理论上的代码和未实现的函数，阅读时，需要仔细。</p>\n<p>下面部分经常的东西后面经常用到，我先导入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash/curry'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> fp = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash/fp'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">'moment'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f(g(x))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> toUpperCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toUpperCase()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> toLowerCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toLowerCase()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Hindley-Milner-类型签名\"><a href=\"#Hindley-Milner-类型签名\" class=\"headerlink\" title=\"Hindley-Milner 类型签名\"></a>Hindley-Milner 类型签名</h2><h3 id=\"初识类型\"><a href=\"#初识类型\" class=\"headerlink\" title=\"初识类型\"></a>初识类型</h3><p>刚接触函数式编程的人很容易深陷类型签名（type signatures）的泥淖。类型（type）是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的。</p>\n<p>类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理（free theorems）” 的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。类型签名不但可以用于编译时检测（compile timechecks），还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色——重要程度远远超出你的想象。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// capitalize :: String -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> capitalize = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> toUpperCase(head(s)) + toLowerCase(tail(s))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(capitalize(<span class=\"string\">\"hello\"</span>))</div></pre></td></tr></table></figure>\n<p>在 Hindley-Milner 系统中，函数都写成类似 a -&gt; b 这个样子，其中 a 和 b是任意类型的变量。因此， capitalize 函数的类型签名可以理解为“一个接受String 返回 String 的函数”。换句话说，它接受一个 String 类型作为输入，并返回一个 String 类型的输出、</p>\n<p><em>PS：Haskell里面HM类型签名作为类型约束语法（type constraints）是很常见的。</em></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// strLength :: String -&gt; Number</span></div><div class=\"line\"><span class=\"keyword\">let</span> strLength = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> s.length</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// join :: String -&gt; [String] -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> join = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">what, xs</span>)</span>&#123;</div><div class=\"line\">   xs.join(what)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// match :: Regex -&gt; String -&gt; [String]</span></div><div class=\"line\"><span class=\"keyword\">let</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, s</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> s.match(reg)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// replace :: Regex -&gt; String -&gt; String -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> replace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, sub, s</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s.replace(reg, sub)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(replace(<span class=\"regexp\">/world/ig</span>)(<span class=\"string\">'JS'</span>)(<span class=\"string\">'hello world'</span>))</div></pre></td></tr></table></figure>\n<p>strLength 和 capitalize 类似：接受一个 String 然后返回一个Number 。至于其他的，第一眼看起来可能会比较疑惑。不过在还不完全了解细节的情况下，你尽可能把最后一个类型视作返回值。那么 match 函数就可以这么理解：它接受一个 Regex 和一个 String ，返回一个 [String] 。</p>\n<p>这里有一个非常有趣的地方，对于 match 函数，我们完全可以把它的类型签名这样分组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// match :: Regex -&gt; (String -&gt; [String])</span></div><div class=\"line\"><span class=\"keyword\">let</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, s</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s.match(reg)</div><div class=\"line\"> &#125;)</div></pre></td></tr></table></figure></p>\n<p>是的，把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出match 这个函数接受一个 Regex 作为参数，返回一个从 String 到 [String] 的函数。因为 curry，造成的结果就是这样：给 match 函数一个Regex ，得到一个新函数，能够处理其 String 参数。当然了，我们并非一定要这么看待这个过程，但这样思考有助于理解为何最后一个类型是返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// onHoliday :: String -&gt; [String]</span></div><div class=\"line\"><span class=\"keyword\">let</span> onHoliday = match(<span class=\"regexp\">/holiday/ig</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(onHoliday(<span class=\"string\">'hello holiday'</span>))</div></pre></td></tr></table></figure>\n<p>每传一个参数，就会弹出类型签名最前面的那个类型。所以 onHoliday 就是已经有了 Regex 参数的 match 。</p>\n<p>PS：我最近刚开始学习Haskell，Haskell里面所有函数都是auto-curried的。配合HM签名效果感觉很强大。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// replace :: Regex -&gt; (String -&gt; (String -&gt; String))</span></div><div class=\"line\"><span class=\"keyword\">let</span> replace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, sub, s</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s.replace(reg, sub);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>但是在这段代码中，就像你看到的那样，为 replace 加上这么多括号未免有些多余。所以这里的括号是完全可以省略的，如果我们愿意，可以一次性把所有的参数都传进来；所以，一种更简单的思路是： replace 接受三个参数，分别是 Regex 、 String 和另一个 String ，返回的还是一个 String 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// id :: a -&gt; a</span></div><div class=\"line\"><span class=\"keyword\">let</span> id = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x &#125;</div><div class=\"line\"><span class=\"comment\">// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></div><div class=\"line\"><span class=\"keyword\">let</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, xs</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> xs.map(f)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(map(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * <span class=\"number\">2</span>)([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]))</div></pre></td></tr></table></figure>\n<p>这里的 id 函数接受任意类型的 a 并返回同一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 a 和 b 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的一个原则，所以我们必须重申： a -&gt; b 可以是从任意类型的 a 到任意类型的 b ，但是 a -&gt; a 必须是同一个类型。例如， id 可以是 String -&gt; String ，也可以是 Number -&gt; Number ，但不能是 String -&gt; Bool 。</p>\n<p>相似地， map 也使用了变量，只不过这里的 b 可能与 a 类型相同，也可能不相同。我们可以这么理解： map 接受两个参数，第一个是从任意类型 a 到任意类型 b 的函数；第二个是一个数组，元素是任意类型的 a ； map 最后返回的是一个类型 b 的数组。</p>\n<p>辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></div><div class=\"line\"><span class=\"keyword\">let</span> head = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>)</span>&#123; <span class=\"keyword\">return</span> xs[<span class=\"number\">0</span>]&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></div><div class=\"line\"><span class=\"keyword\">let</span> filter = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, xs</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> xs.filter(f)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></div><div class=\"line\"><span class=\"keyword\">let</span> reduce = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, x, xs</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> xs.reduce(f, x)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意看 reduce 的签名，可以看到它的第一个参数是个函数，这个函数接受一个 b 和一个 a 并返回一个 b 。那么这些 a 和 b 是从哪来的呢？很简单，签名中的第二个和第三个参数就是 b 和元素为 a 的数组，所以唯一合理的假设就是这里的 b 和每一个 a 都将传给前面说的函数作为参数。我们还可以看到， reduce 函数最后返回的结果是一个b ，也就是说， reduce 的第一个参数函数的输出就是 reduce 函数的输出。知道了 reduce 的含义，我们才敢说上面关于类型签名的推理是正确的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(reduce(<span class=\"function\">(<span class=\"params\">b, a</span>) =&gt;</span> a * b)(<span class=\"number\">3</span>)([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]))</div><div class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].reduce(<span class=\"function\">(<span class=\"params\">b, a</span>) =&gt;</span> a * b, <span class=\"number\">3</span>))</div></pre></td></tr></table></figure>\n<h3 id=\"缩小可能性范围\"><a href=\"#缩小可能性范围\" class=\"headerlink\" title=\"缩小可能性范围\"></a>缩小可能性范围</h3><p>一旦引入一个类型变量，就会出现一个奇怪的特性叫做 parametricity（<a href=\"http://en.wikipedia.org/wiki/Parametricity\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Parametricity</a> ）。这个特性表明，函数将会以一种统一的行为作用于所有的类型。</p>\n<p>a 告诉我们它不是一个特定的类型，这意味着它可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一。这就是 parametricity 的含义。</p>\n<p>这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 Hoogle 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。</p>\n<p><em>PS: Hoogle是Haskell官网中搜索文档的搜索引擎。</em></p>\n<h3 id=\"自由定理\"><a href=\"#自由定理\" class=\"headerlink\" title=\"自由定理\"></a>自由定理</h3><p>类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理（free theorems）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></div><div class=\"line\">compose(f, head) == compose(head, map(f));</div><div class=\"line\"><span class=\"comment\">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></div><div class=\"line\">compose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));</div></pre></td></tr></table></figure></p>\n<p>不用写一行代码你也能理解这些定理，它们直接来自于类型本身。</p>\n<p><em>PS: 这些函数是纯的才能成立。</em></p>\n<p>第一个例子中，等式左边说的是，先获取数组的第一个元素，然后对它调用函数 f ；等式右边说的是，先对数组中的每一个元素调用 f ，然后再取其返回结果的头部 。这两个表达式的作用是相等的，但是前者要快得多。</p>\n<p>第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，然后再通过 map 实际调用 f （别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；等式右边是说，先用 map 调用 f ，然后再根据 p 过滤元素。这两者也是相等的。</p>\n<h3 id=\"类型约束\"><a href=\"#类型约束\" class=\"headerlink\" title=\"类型约束\"></a>类型约束</h3><p>最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sort :: Ord a =&gt; [a] -&gt; [a]</span></div></pre></td></tr></table></figure>\n<p>胖箭头左边表明的是这样一个事实： a 一定是个 Ord 对象。也就是说， a 必须要实现 Ord 接口。 Ord 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 a 的更多信息，了解 sort 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束（type constraints）。</p>\n<p>PS：Haskell里面存在Ord类型类，Rust里面也有类似的东西。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// assertEqual :: (Eq a, Show a) =&gt; a -&gt; a -&gt; Assertion</span></div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Hindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更需要花点时间了。</p>\n<h2 id=\"特百惠\"><a href=\"#特百惠\" class=\"headerlink\" title=\"特百惠\"></a>特百惠</h2><h3 id=\"强大的容器\"><a href=\"#强大的容器\" class=\"headerlink\" title=\"强大的容器\"></a>强大的容器</h3><p>我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？</p>\n<p>首先我们将创建一个容器（container）。这个容器必须能够装载任意类型的值。这个容器将会是一个对象，但我们不会为它添加面向对象观念下的属性和方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Container = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Container.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Container(x)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将使用 Container.of 作为构造器（constructor），这样就不用到处去写糟糕的 new 关键字了，非常省心。 实际上不能这么简单地看待 of 函数，但暂时先认为它是把值放到容器里的一种方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Container.of(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">//=&gt; Container(3)</span></div><div class=\"line\">Container.of(<span class=\"string\">\"hotdogs\"</span>)</div><div class=\"line\"><span class=\"comment\">//=&gt; Container(\"hotdogs\")</span></div><div class=\"line\">Container.of(Container.of(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"yoda\"</span>&#125;))</div><div class=\"line\"><span class=\"comment\">//=&gt; Container(Container(&#123;name: \"yoda\" &#125;))</span></div></pre></td></tr></table></figure>\n<p>在继续后面的内容之前，先澄清几点：<br>Container 是个只有一个属性的对象。尽管容器可以有不止一个的属性，但大多数容器还是只有一个。我们很随意地把 Container 的这个属性命名为 <strong>value。</strong>value 不能是某个特定的类型，不然 Container 就对不起它这个名字了。数据一旦存放到 Container ，就会一直待在那儿。我们可以用 .__value 获取到数据，但这样做有悖初衷。</p>\n<h3 id=\"第一个-functor-函子\"><a href=\"#第一个-functor-函子\" class=\"headerlink\" title=\"第一个 functor(函子)\"></a>第一个 functor(函子)</h3><p>一旦容器里有了值，不管这个值是什么，我们就需要一种方法来让别的函数能够操作它。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// (a -&gt; b) -&gt; Container a -&gt; Container b</span></div><div class=\"line\">Container.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Container.of(f(Container.__value))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个 map 跟数组那个著名的 map 一样，除了前者的参数是 Container a 而后者是 [a] 。它们的使用方式也几乎一致</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Container.of(<span class=\"number\">2</span>).map(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num + <span class=\"number\">2</span>))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Container.of(<span class=\"string\">'hello'</span>).map(<span class=\"function\"><span class=\"params\">str</span> =&gt;</span> str.toUpperCase()))</div></pre></td></tr></table></figure>\n<p>为什么要使用这样一种方法？因为我们能够在不离开 Container 的情况下操作容器里面的值。这是非常了不起的一件事情。 Container 里的值传递给 map 函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的 Container。这样做的结果是，我们能连续地调用 map ，运行任何我们想运行的函数，甚至还可以改变值的类型。</p>\n<p>如果我们能一直调用 map ，那它不就是个组合（composition）么！这里边是有什么数学魔法在起作用？是 <code>functor</code>。各位，这个数学魔法就是 functor。</p>\n<p><em>functor 是实现了 map 函数并遵守一些特定规则的容器类型。</em></p>\n<p>没错，functor 就是一个签了合约的接口。functor 是范畴学里的概念。</p>\n<p>把值装进一个容器，而且只能使用 map 来处理它，这么做的理由到底是什么呢？如果我们换种方式来问，答案就很明显了：让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。</p>\n<h3 id=\"薛定谔的-Maybe\"><a href=\"#薛定谔的-Maybe\" class=\"headerlink\" title=\"薛定谔的 Maybe\"></a>薛定谔的 Maybe</h3><p>说实话 Container 挺无聊的，而且通常我们称它为 Identity ，与 id 函数的作用相同（这里也是有数学上的联系的）。除此之外，还有另外一种 functor，那就是实现了 map 函数的类似容器的数据类型，这种 functor 在调用 map 的时候能够提供非常有用的行为。现在让我们来定义一个这样的 functor。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Maybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Maybe.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Maybe(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Maybe.prototype.isNothing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.__value === <span class=\"literal\">null</span>) || (<span class=\"keyword\">this</span>.__value === <span class=\"literal\">undefined</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Maybe.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.isNothing() ? Maybe.of(<span class=\"literal\">null</span>) : Maybe.of(f(<span class=\"keyword\">this</span>.__value))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Maybe 会先检查自己的值是否为空，然后才调用传进来的函数。这样我们在使用 map 的时候就能避免恼人的空值了（这个实现出于教学目的做了简化）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(Maybe.of(<span class=\"string\">'Malkovich Malkovich'</span>).map(match(<span class=\"regexp\">/a/ig</span>)))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Maybe.of(<span class=\"literal\">null</span>).map(match(<span class=\"regexp\">/a/ig</span>)))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Maybe.of(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"Dinah\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">14</span>&#125;).map(_.property(<span class=\"string\">'age'</span>)))</div></pre></td></tr></table></figure>\n<p>当传给 map 的值是 null 时，代码并没有爆出错误。这是因为每一次 Maybe 要调用函数的时候，都会先检查它自己的值是否为空。</p>\n<p>这种点记法（dot notation syntax）已经足够函数式了，但是正如在第 1 部分指出的那样，我们更想保持一种 pointfree 的风格。碰巧的是， map 完全有能力以 curry 函数的方式来“代理”任何 functor。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></div><div class=\"line\">map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, any_functor_at_all</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> any_functor_at_all.map(f)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样我们就可以像平常一样使用组合，同时也能正常使用 map 了，非常振奋人心。<code>ramda</code> 的 map 也是这样。后面的，我们将在点记法更有教育意义的时候使用点记法，在方便使用 pointfree 模式的时候就用 pointfree。你注意到了么？我在类型标签中偷偷引入了一个额外的标记： Functor f =&gt; 。这个标记告诉我们 f 必须是一个 functor。</p>\n<p>用例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// safeHead :: [a] -&gt; Maybe(a)</span></div><div class=\"line\"><span class=\"keyword\">let</span> safeHead = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Maybe.of(xs[<span class=\"number\">0</span>])</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> streetName = compose(compose(map(_.property(<span class=\"string\">'street'</span>)), safeHead), _.property(<span class=\"string\">'addresses'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(streetName(&#123;<span class=\"attr\">addresses</span>:[]&#125;))</div><div class=\"line\"><span class=\"comment\">// Maybe(null)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(streetName(&#123;<span class=\"attr\">addresses</span>: [&#123;<span class=\"attr\">street</span>: <span class=\"string\">\"Shady Ln.\"</span>, <span class=\"attr\">number</span>: <span class=\"number\">4201</span>&#125;]&#125;))</div><div class=\"line\"><span class=\"comment\">// Maybe(\"Shady Ln.\")</span></div></pre></td></tr></table></figure>\n<p>safeHead 与一般的 _.head 类似，但是增加了类型安全保证。引入 Maybe 会发生一件非常有意思的事情，那就是我们被迫要与狡猾的 null 打交道了。 safeHead 函数能够诚实地预告它可能的失败,然后返回一个 Maybe 来通知我们相关信息。实际上不仅仅是通知，因为毕竟我们想要的值深藏在 Maybe 对象中，而且只能通过 map 来操作它。<em>本质上，这是一种由 safeHead 强制执行的空值检查。</em> 类似这样的 API 能够把一个像纸糊起来的、脆弱的应用升级为实实在在的、健壮的应用，这样的 API 保证了更加安全的软件。</p>\n<p>有时候函数可以明确返回一个 Maybe(null) 来表明失败</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// withdraw :: Number -&gt; Account -&gt; Maybe(Account)</span></div><div class=\"line\"><span class=\"keyword\">let</span> withdraw = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">amount, account</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> account.balance &gt;= account ?</div><div class=\"line\">        Maybe.of(&#123;<span class=\"attr\">account</span>: account.balance - account&#125;) :</div><div class=\"line\">        Maybe.of(<span class=\"literal\">null</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// finishTransaction :: Account -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> finishTransaction = compose(remainingBalance, updateLedger)</div><div class=\"line\"><span class=\"comment\">// &lt;- 假定这两个函数已经在别处定义好了</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getTwenty :: Account -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> getTwenty = compose(map(finishTransaction), withdraw(<span class=\"number\">20</span>))</div><div class=\"line\"></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">200.00</span>&#125;)</div><div class=\"line\"><span class=\"comment\">// Maybe(\"Your balance is $180.00\")</span></div><div class=\"line\"></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">10.00</span>&#125;)</div><div class=\"line\"><span class=\"comment\">// Maybe(null)</span></div></pre></td></tr></table></figure>\n<p>withdraw 也显示出了它的多变性，使得我们后续的操作只能用 map 来进行。这个例子与前面例子不同的地方在于，这里的 null 是有意的。我们不用 Maybe(String) ，而是用 Maybe(null)来发送失败的信号，这样程序在收到信号后就能立刻停止执行。这一点很重要：如果 withdraw 失败了，map 就会切断后续代码的执行，因为它根本就不会运行传递给它的函数，即finishTransaction 。这正是预期的效果：如果取款失败，我们并不想更新或者显示账户余额。</p>\n<h3 id=\"释放容器里的值\"><a href=\"#释放容器里的值\" class=\"headerlink\" title=\"释放容器里的值\"></a>释放容器里的值</h3><p>人们经常忽略的一个事实是：任何事物都有个最终尽头。那些会产生作用的函数，不管它们是发送 JSON 数据，还是在屏幕上打印东西，还是更改文件系统，还是别的什么，都要有一个结束。但是我们无法通过 return 把输出传递到外部世界，必须要运行这样或那样的函数才能传递出去。</p>\n<p>应用程序所做的工作就是获取、更改和保存数据直到不再需要它们，对数据做这些操作的函数有可能被 map 调用，这样的话数据就可以不用离开它温暖舒适的容器。讽刺的是，有一种常见的错误就是试图以各种方法删除 Maybe 里的值，好像这个不确定的值是魔鬼，删除它就能让它突然显形，然后一切罪恶都会得到宽恕似的（此处原文应该是源自圣经）。要知道，我们的值没有完成它的使命，很有可能是其他代码分支造成的。我们的代码，就像薛定谔的猫一样，在某个特定的时间点有两种状态，而且应该保持这种状况不变直到最后一个函数为止。这样，哪怕代码有很多逻辑性的分支，也能保证一种线性的工作流。</p>\n<p>不过，对容器里的值来说，还是有个逃生口可以出去。也就是说，如果我们想返回一个自定义的值然后还能继续执行后面的代码的话，是可以做到的；要达到这一目的，可以借助一个帮助函数 maybe ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b</span></div><div class=\"line\"><span class=\"keyword\">let</span> maybe = _.curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, f, m</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> m.isNothing() ? x : f(m.__value)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getTwenty :: Account -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> getTwenty = compose(maybe(<span class=\"string\">\"You're broke!\"</span>, finishTransaction), withdraw(<span class=\"number\">20</span>))</div><div class=\"line\"></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">200.00</span>&#125;);</div><div class=\"line\"><span class=\"comment\">// \"Your balance is $180.00\"</span></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">10.00</span>&#125;);</div><div class=\"line\"><span class=\"comment\">// \"You're broke!\"</span></div></pre></td></tr></table></figure>\n<p>这样就可以要么返回一个静态值（与 finishTransaction 返回值的类型一致），要么继续愉快地在没有 Maybe 的情况下完成交易。 maybe 使我们得以避免普通 map 那种命令式的 if/else 语句： if(x !== null) { return f(x) } 。</p>\n<p>引入 Maybe 可能会在初期造成一些不适。Swift 和 Scala 用户知道我在说什么，因为这两门语言的核心库里就有 Maybe 的概念，只不过伪装成 Option(al) 罢了。</p>\n<p><em>PS：Haskell 里面有Maybe，Rust里面也是类似伪装成 Option。</em></p>\n<p>被迫在任何情况下都进行空值检查，的确让大部分人头疼不已。然而随着时间推移，空值检查会成为第二本能，不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。</p>\n<p>Maybe 能够非常有效地帮助我们增加函数的安全性。</p>\n<p>有一点我必须要提及，否则就太不负责任了，那就是 Maybe 的“真正”实现会把它分为两种类型：一种是非空值，另一种是空值。这种实现允许我们遵守 map 的 parametricity 特性，因此 null 和 undefined 能够依然被 map 调用，functor 里的值所需的那种普遍性条件也能得到满足。所以你会经常看到 Some(x) / None 或者 Just(x) / Nothing 这样的容器类型在做空值检查，而不是Maybe 。</p>\n<h3 id=\"“纯”错误处理\"><a href=\"#“纯”错误处理\" class=\"headerlink\" title=\"“纯”错误处理\"></a>“纯”错误处理</h3><p>说出来可能会让你震惊， throw/catch 并不十分“纯”。当一个错误抛出的时候，我们没有收到返回值，反而是得到了一个警告！</p>\n<p>有了 Either 这个新朋友，我们就能以一种好得多的方式来处理错误，那就是返回一条非常礼貌的消息作为回应。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Left = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Left.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Left(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Left.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> Right = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Right.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Right(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Right.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Right.of(f(<span class=\"keyword\">this</span>.__value))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Left 和 Right 是我们称之为 Either 的抽象类型的两个子类。</span></div><div class=\"line\"><span class=\"keyword\">let</span> right = Right.of(<span class=\"string\">\"rain\"</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"b\"</span> + str</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// Right(\"brain\")</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> left = Left.of(<span class=\"string\">\"rain\"</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"b\"</span> + str</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// Left(\"rain\")</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Right.of(&#123;<span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>:<span class=\"number\">80</span>&#125;).map(_.property(<span class=\"string\">'host'</span>)))</div><div class=\"line\"><span class=\"comment\">// Right('localhost')</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Left.of(<span class=\"string\">\"rolls eyes...\"</span>).map(_.property(<span class=\"string\">'host'</span>)))</div><div class=\"line\"><span class=\"comment\">// Left('rolls eyes...')</span></div></pre></td></tr></table></figure>\n<p>Left 就像是青春期少年那样无视我们要 map 它的请求。 Right 的作用就像是一个 Container （也就是 Identity）。这里强大的地方在于， Left 有能力在它内部嵌入一个错误消息。</p>\n<p>假设有一个可能会失败的函数，就拿根据生日计算年龄来说好了。的确，我们可以用 Maybe(null) 来表示失败并把程序引向另一个分支，但是这并没有告诉我们太多信息。很有可能我们想知道失败的原因是什么。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> getAge = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">now, user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> birthdate = moment(user.birthdate, <span class=\"string\">'YYYY-MM-DD'</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span>(!birthdate.isValid()) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Left.of(<span class=\"string\">\"Birth date could not be parsed\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> Right.of(now.diff(birthdate, <span class=\"string\">'years'</span>))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'1996-12-30'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// Right(21)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'12-30'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// Left(\"Birth date could not be parsed\")</span></div></pre></td></tr></table></figure>\n<p>这么一来，就像 Maybe(null) ，当返回一个 Left 的时候就直接让程序短路。跟 Maybe(null) 不同的是，现在我们对程序为何脱离原先轨道至少有了一点头绪。有一件事要注意，这里返回的是 Either(String, Number) ，意味着我们这个 Either 左边Left的值是 String，右边Right，也就是正确的值，是 Number 。这个类型签名不是很正式，因为我们并没有定义一个真正的 Either父类；但我们还是从这个类型那里了解到不少东西。它告诉我们，我们得到的要么是一条错误消息，要么就是正确的值。</p>\n<p>PS：Rust里面也有类似的概念，对应于Result enum里的Ok，Err。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// map 如之前所实现，会调用container的map方法</span></div><div class=\"line\"><span class=\"comment\">// zoltar :: User -&gt; Either(String, _)</span></div><div class=\"line\"><span class=\"keyword\">let</span> zoltar = compose(map(<span class=\"built_in\">console</span>.log), getAge(moment()))</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(zoltar(&#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'1996-12-30'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// 21</span></div><div class=\"line\"><span class=\"comment\">// Right(undefined)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(zoltar(&#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'balloons!'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// Left(\"Birth date could not be parsed\")</span></div></pre></td></tr></table></figure>\n<p>如果 birthdate 合法，这个程序就会把它神秘的命运打印在屏幕上让我们见证；如果不合法，我们就会收到一个有着清清楚楚的错误消息的 Left ，尽管这个消息是稳稳当当地待在它的容器里的。这种行为就像，虽然我们在抛错，但是是以一种平静温和的方式抛错，而不是像一个小孩子那样，有什么不对劲就闹脾气大喊大叫。</p>\n<p>我们根据 birthdate 的合法性来控制代码的逻辑分支，同时又让代码进行从右到左的直线运动，而不用爬过各种条件语句的大括号。</p>\n<p>我们在 Right 分支的类型签名中使用 _ 表示一个应该忽略的值（在有些浏览器中，你必须要 console.log.bind(console) 才能把 console.log 当作一等公民使用）。</p>\n<p>这个例子中，尽管 fortune 使用了 Either ，它对每一个 functor 到底要干什么却是毫不知情的。通俗点来讲，一个函数在调用的时候，如果被map 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数。<em>我们把这个过程叫做 lift。</em></p>\n<p>一般情况下，普通函数更适合操作普通的数据类型而不是容器类型，在必要的时候再通过 lift 变为合适的容器去操作容器类型。这样做的好处是能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor。</p>\n<p>Either 并不仅仅只对合法性检查这种一般性的错误作用非凡，对一些更严重的、能够中断程序执行的错误比如文件丢失或者 socket 连接断开等， Either 同样效果显著。</p>\n<p>它的能耐远不止于此。比如，它表示了逻辑或（也就是||）。再比如，它体现了范畴学里 coproduct 的概念。还比如，它是标准的 sum type（或者叫不交并集，disjoint union of sets），因为它含有的所有可能的值的总数就是它包含的那两种类型的总数。</p>\n<p>Either 能做的事情多着呢，但是作为一个 functor，我们就用它处理错误。</p>\n<p>就像 Maybe 可以有个 maybe 一样， Either 也可以有一个 either 。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。这两个函数的返回值类型一致：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> either = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g, e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span>(e.constructor) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> Left: <span class=\"keyword\">return</span> f(e.__value)</div><div class=\"line\">        <span class=\"keyword\">case</span> Right: <span class=\"keyword\">return</span> g(e.__value)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> localStorage = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getFromStorage :: String -&gt; (_ -&gt; String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> getFromStorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> localStorage[key]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要是我们没把 getFromStorage 包在另一个函数里，它的输出值就是不定的，会随外部环境变化而变化。有了这个结实的包裹函数（wrapper），同一个输入就总能返回同一个输出：一个从 localStorage 里取出某个特定的元素的函数。</p>\n<p>然而，这并没有多大的用处。就像是你收藏的全新未拆封的玩偶，不能拿出来玩有什么意思。所以要是能有办法进到这个容器里面，拿到它藏在那儿的东西就好了…办法是有的，请看 <code>IO</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> IO = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = f</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(compose(f, <span class=\"keyword\">this</span>.__value))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>IO 跟之前的 functor 不同的地方在于，它的 __value 总是一个函数。不过我们不把它当作一个函数——实现的细节我们最好先不管。这里发生的事情跟我们在getFromStorage 那里看到的一模一样： IO 把非纯执行动作（impure action）捕获到包裹函数里，目的是延迟执行这个非纯动作。就这一点而言，我们认为 IO 包含的是被包裹的执行动作的返回值，而不是包裹函数本身。<br>这在 of 函数里很明显： IO(function(){ return x }) 仅仅是为了延迟执行，其实我们得到的是 IO(x) 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> io_window = <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">io_window.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">win</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.innerWidth</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// IO(1430)</span></div><div class=\"line\"></div><div class=\"line\">io_window2 = io_window.map(_.property(<span class=\"string\">'location'</span>))</div><div class=\"line\">        .map(_.property(<span class=\"string\">'href'</span>))</div><div class=\"line\">        .map(_.split(<span class=\"string\">'/'</span>))</div><div class=\"line\"><span class=\"comment\">// IO([\"http:\", \"\", \"localhost:8000\", \"blog\", \"posts\"])</span></div></pre></td></tr></table></figure>\n<p>这里， io_window 是一个真正的 IO ，我们可以直接对它使用 map 。我把这里的返回值都写成了概念性的，这样就更加直观；不过实际的返回值是 { __value: [Function] } 。当调用 IO 的 map 的时候，我们把传进来的函数放在了 map 函数里的组合的最末端（也就是最左边），反过来这个函数就成为了新的 IO 的新 value ，并继续下去。传给 map 的函数并没有运行，我们只是把它们压到一个“运行栈”的最末端而已，一个函数紧挨着另一个函数，就像小心摆放的多米诺骨牌一样，让人不敢轻易推倒。这种情形很容易叫人联想起“四人帮”（《设计模式》一书作者）提出的命令模式（command pattern）或者队列（queue）。</p>\n<p>IO 的 value 并不是它包含的值，也不是像两个下划线暗示那样是一个私有属性。value 是手榴弹的弹栓，只应该被调用者以最公开的方式拉动。为了提醒用户它的变化无常，我们把它重命名为 unsafePerformIO 看看</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> IO = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.unsafePerformIO = f</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(compose(f, <span class=\"keyword\">this</span>.unsafePerformIO))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在调用的代码对于应用程序的用户简直就直白得不能再直白了。</p>\n<p>之后我们将学习一种跟 IO 在精神上相似，但是用法上又千差万别的类型。</p>\n<h3 id=\"异步任务\"><a href=\"#异步任务\" class=\"headerlink\" title=\"异步任务\"></a>异步任务</h3><p>处理异步代码，我们有一种更好的方式，它的名字以“F”开头。这种方式的内部机制过于复杂，复杂得哪怕我唾沫横飞也很难讲清楚。所以我们就直接用 Quildreen Motta 的 Folktale 里的 Data.Task。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Folktale = <span class=\"built_in\">require</span>(<span class=\"string\">'folktale'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> Task = Folktale.concurrency.task</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Node readfile example:</span></div><div class=\"line\"><span class=\"comment\">//=======================</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// readFile :: String -&gt; Task(Error, JSON)</span></div><div class=\"line\"><span class=\"keyword\">let</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Task(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reject, result</span>) </span>&#123;</div><div class=\"line\">        fs.readFile(filename, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">            err ? reject(err) : result(data);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">readFile(<span class=\"string\">\"metamorphosis\"</span>).map(split(<span class=\"string\">'\\n'</span>)).map(head);</div><div class=\"line\"><span class=\"comment\">// Task(\"One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// in bed he had been changed into a monstrous verminous bug.\")</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// jQuery getJSON example:</span></div><div class=\"line\"><span class=\"comment\">//========================</span></div><div class=\"line\"><span class=\"comment\">// getJSON :: String -&gt; &#123;&#125; -&gt; Task(Error, JSON)</span></div><div class=\"line\"><span class=\"keyword\">let</span> getJSON = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, params</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Task(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reject, result</span>) </span>&#123;</div><div class=\"line\">        $.getJSON(url, params, result).fail(reject);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">getJSON(<span class=\"string\">'/video'</span>, &#123;<span class=\"attr\">id</span>: <span class=\"number\">10</span>&#125;).map(_.prop(<span class=\"string\">'title'</span>));</div><div class=\"line\"><span class=\"comment\">// Task(\"Family Matters ep 15\")</span></div><div class=\"line\"><span class=\"comment\">// 传入普通的实际值也没问题</span></div><div class=\"line\">Task.of(<span class=\"number\">3</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">three</span>)</span>&#123; <span class=\"keyword\">return</span> three + <span class=\"number\">1</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// Task(4)</span></div></pre></td></tr></table></figure>\n<p>例子中的 reject 和 result 函数分别是失败和成功的回调。正如你看到的，我们只是简单地调用 Task 的 map 函数，就能操作将来的值，好像这个值就在那儿似的。</p>\n<p>如果熟悉 promise 的话，你该能认出来 map 就是 then ， Task 就是一个promise。</p>\n<p>与 IO 类似， Task 在我们给它绿灯之前是不会运行的。事实上，正因为它要等我们的命令， IO 实际就被纳入到了 Task 名下，代表所有的异步操作—— readFile 和 getJSON 并不需要一个额外的 IO 容器来变纯。更重要的是，当我们调用它的 map 的时候， Task 工作的方式与 IO 几无差别：都是把对未来的操作的指示放在一个时间胶囊里，就像家务列表（chore chart）那样——<br>真是一种精密的拖延术。</p>\n<p>我们必须调用 fork 方法才能运行 Task ，这种机制与 unsafePerformIO 类似。但也有不同，不同之处就像 fork 这个名称表明的那样，它会 fork 一个子进程运行它接收到的参数代码，其他部分的执行不受影响，主线程也不会阻塞。当然这种效果也可以用其他一些技术比如线程实现，但这里的这种方法工作起来就像是一个普通的异步调用，而且 event loop 能够不受影响地继续运转。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Pure application</span></div><div class=\"line\"><span class=\"comment\">//=====================</span></div><div class=\"line\"><span class=\"comment\">// blogTemplate :: String</span></div><div class=\"line\"><span class=\"comment\">// blogPage :: Posts -&gt; HTML</span></div><div class=\"line\"><span class=\"keyword\">let</span> blogPage = Handlebars.compile(blogTemplate);</div><div class=\"line\"><span class=\"comment\">// renderPage :: Posts -&gt; HTML</span></div><div class=\"line\"><span class=\"keyword\">let</span> renderPage = compose(blogPage, sortBy(<span class=\"string\">'date'</span>));</div><div class=\"line\"><span class=\"comment\">// blog :: Params -&gt; Task(Error, HTML)</span></div><div class=\"line\"><span class=\"keyword\">let</span> blog = compose(map(renderPage), getJSON(<span class=\"string\">'/posts'</span>));</div><div class=\"line\"><span class=\"comment\">// Impure calling code</span></div><div class=\"line\"><span class=\"comment\">//=====================</span></div><div class=\"line\">blog(&#123;&#125;).fork(</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123; $(<span class=\"string\">\"#error\"</span>).html(error.message); &#125;,</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">page</span>)</span>&#123; $(<span class=\"string\">\"#main\"</span>).html(page); &#125;</div><div class=\"line\">);</div><div class=\"line\">$(<span class=\"string\">'#spinner'</span>).show();</div></pre></td></tr></table></figure>\n<p>调用 fork 之后， Task 就赶紧跑去找一些文章，渲染到页面上。与此同时，我们在页面上展示一个 spinner，因为 fork 不会等收到响应了才执行它后面的代码。最后，我们要么把文章展示在页面上，要么就显示一个出错信息，视getJSON 请求是否成功而定。</p>\n<p>我们只需要从下读到上，从右读到左就能理解代码，即便这段程序实际上会在执行过程中到处跳来跳去。这种方式使得阅读和理解应用程序的代码比那种要在各种回调和错误处理代码块之间跳跃的方式容易得多。</p>\n<h3 id=\"一点理论\"><a href=\"#一点理论\" class=\"headerlink\" title=\"一点理论\"></a>一点理论</h3><p>functor 的概念来自于范畴学，并满足一些定律。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// identity</span></div><div class=\"line\">map(id) === id;</div><div class=\"line\"><span class=\"comment\">// composition</span></div><div class=\"line\">compose(map(f), map(g)) === map(compose(f, g));</div></pre></td></tr></table></figure>\n<p>同一律很简单，但是也很重要。因为这些定律都是可运行的代码，所以我们完全可以在我们自己的 functor 上试验它们，验证它们是否成立。</p>\n<p>在范畴学中，functor 接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（identity），也一定能够组合态射；我们无须验证这一点，前面提到的定律保证这些东西会在映射后得到保留。</p>\n<p>可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。如果一个对象 a 属于源范畴 C ，那么通过 <code>functor F</code> 把 a 映射到目标范畴 D 上之后，就可以使用 <code>F a</code> 来指代 a 对象。</p>\n<p><img src=\"functor映射.png\" alt=\"functor映射\"></p>\n<p>比如， Maybe 就把类型和函数的范畴映射到这样一个范畴：即每个对象都有可能不存在，每个态射都有空值检查的范畴。这个结果在代码中的实现方式是用 map 包裹每一个函数，用 functor 包裹每一个类型。这样就能保证每个普通的类型和函数都能在新环境下继续使用组合。</p>\n<p>从技术上讲，代码中的 functor 实际上是把范畴映射到了一个包含类型和函数的子范畴（sub category）上，使得这些 functor 成为了一种新的特殊的 endofunctor。可以用一张图来表示这种态射及其对象的映射。</p>\n<p><img src=\"functor映射2.png\" alt=\"functor映射2\"></p>\n<p>这张图除了能表示态射借助 functor F 完成从一个范畴到另一个范畴的映射之外，我们发现它还符合交换律，也就是说，顺着箭头的方向往前，形成的每一个路径都指向同一个结果。不同的路径意味着不同的行为，但最终都会得到同一个数据类型。这种形式化给了我们原则性的方式去思考代码——无须分析和评估每一个单独的场景，只管可以大胆地应用公式即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// topRoute :: String -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> topRoute = compose(Maybe.of, safeHead);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// bottomRoute :: String -&gt; Maybe(String) </span></div><div class=\"line\"><span class=\"keyword\">let</span> bottomRoute = compose(map(safeHead), Maybe.of);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(topRoute(<span class=\"string\">'hi'</span>));</div><div class=\"line\"><span class=\"comment\">// Maybe('h')</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bottomRoute(<span class=\"string\">'hi'</span>));</div><div class=\"line\"><span class=\"comment\">// Maybe('h')</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// topRoute :: String -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> topRoute = compose(Maybe.of, reverse);</div><div class=\"line\"><span class=\"comment\">// bottomRoute :: String -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> bottomRoute = compose(map(reverse), Maybe.of);</div><div class=\"line\"></div><div class=\"line\">topRoute(<span class=\"string\">\"hi\"</span>);</div><div class=\"line\"><span class=\"comment\">// Maybe(\"ih\")</span></div><div class=\"line\">bottomRoute(<span class=\"string\">\"hi\"</span>);</div><div class=\"line\"><span class=\"comment\">// Maybe(\"ih\")</span></div></pre></td></tr></table></figure>\n<p><img src=\"functor映射实例.png\" alt=\"functor映射实例\"></p>\n<p>根据所有 functor 都有的特性，我们可以立即理解代码，重构代码。</p>\n<p>functor 也能嵌套使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nested = Task.of([Right.of(<span class=\"string\">\"pillows\"</span>), Left.of(<span class=\"string\">\"no sleep for you\"</span>)]);</div><div class=\"line\"></div><div class=\"line\">map(map(map(toUpperCase)), nested);</div><div class=\"line\"></div><div class=\"line\">Task([Right(<span class=\"string\">\"PILLOWS\"</span>), Left(<span class=\"string\">\"no sleep for you\"</span>)])</div></pre></td></tr></table></figure>\n<p>nested 是一个将来的数组，数组的元素有可能是程序抛出的错误。我们使用map 剥开每一层的嵌套，然后对数组的元素调用传递进去的函数。可以看到，这中间没有回调、 if/else 语句和 for 循环，只有一个明确的上下文。的确，我们必须要 map(map(map(f))) 才能最终运行函数。不想这么做的话，可以组合 functor。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f_g_x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.getCompose = f_g_x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Compose.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(map(map(f), <span class=\"keyword\">this</span>.getCompose));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>functor 组合是符合结合律的，而且之前我们定义的 Container 实际上是一个叫 Identity 的 functor。identity 和可结合的组合也能产生一个范畴，这个特殊的范畴的对象是其他范畴，态射是 functor。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>我们已经认识了几个不同的 functor，但它们的数量其实是无限的。有一些值得注意的可迭代数据类型（iterable data structure）我们没有介绍，像 tree、list、map 和 pair 等，以及所有你能说出来的。eventstream 和 observable 也都是 functor。其他的 functor 可能就是拿来做封装或者仅仅是模拟类型。我们身边到处都有 functor的身影。</p>\n<p>用多个 functor 参数调用一个函数怎么样呢？处理一个由不纯的或者异步的操作组成的有序序列怎么样呢？要应对这个什么都装在盒子里的世界，目前我们工具箱里的工具还不全。下一章，我们将直奔 monad 而去。</p>\n<h2 id=\"自我总结\"><a href=\"#自我总结\" class=\"headerlink\" title=\"自我总结\"></a>自我总结</h2><p>PS里面是自己的话。</p>\n<p>这部分的其实还有挺多的东西没有搞懂，书中许多代码其实是无法运行的，或者依赖很多编写成本很大。书里面还有一些题目，我也没有花时间进去。个人觉得这本书比一般的函数式书要深入，当然估计在Haskell书里，这些知识都很常规。其他的东西大部分都是书中的内容，我自己进行了少量地修改和较多地删减。</p>\n<p>最近在学习Rust和Haskell，打算寒假精力主要放在学习这2门语言特有的特性，说白了，就是安全性和函数式。<br>但是这2门语言门槛其实都不低，2018年平时可能会投入一些精力去学习。寒假如果顺利，希望能用这些语言来复习数据结构的知识。<br>下个学期特意选了一些偏实战专业课，打算把新学到的语言、特性和思想用起来。</p>\n<p>这本书最后还有2章，如果有机会，想在寒假看完。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"JS函数式编程\"><a href=\"#JS函数式编程\" class=\"headerlink\" title=\"JS函数式编程\"></a>JS函数式编程</h1><p>笔记里面常常依赖一些库和之前的代码，而且可能存在理论上的代码和未实现的函数，阅读时，需要仔细。</p>\n<p>下面部分经常的东西后面经常用到，我先导入。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash/curry'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> fp = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash/fp'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">'moment'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f(g(x))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> toUpperCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toUpperCase()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> toLowerCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> str.toLowerCase()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Hindley-Milner-类型签名\"><a href=\"#Hindley-Milner-类型签名\" class=\"headerlink\" title=\"Hindley-Milner 类型签名\"></a>Hindley-Milner 类型签名</h2><h3 id=\"初识类型\"><a href=\"#初识类型\" class=\"headerlink\" title=\"初识类型\"></a>初识类型</h3><p>刚接触函数式编程的人很容易深陷类型签名（type signatures）的泥淖。类型（type）是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的。</p>\n<p>类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理（free theorems）” 的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。类型签名不但可以用于编译时检测（compile timechecks），还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色——重要程度远远超出你的想象。</p>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// capitalize :: String -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> capitalize = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> toUpperCase(head(s)) + toLowerCase(tail(s))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(capitalize(<span class=\"string\">\"hello\"</span>))</div></pre></td></tr></table></figure>\n<p>在 Hindley-Milner 系统中，函数都写成类似 a -&gt; b 这个样子，其中 a 和 b是任意类型的变量。因此， capitalize 函数的类型签名可以理解为“一个接受String 返回 String 的函数”。换句话说，它接受一个 String 类型作为输入，并返回一个 String 类型的输出、</p>\n<p><em>PS：Haskell里面HM类型签名作为类型约束语法（type constraints）是很常见的。</em></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// strLength :: String -&gt; Number</span></div><div class=\"line\"><span class=\"keyword\">let</span> strLength = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> s.length</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// join :: String -&gt; [String] -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> join = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">what, xs</span>)</span>&#123;</div><div class=\"line\">   xs.join(what)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// match :: Regex -&gt; String -&gt; [String]</span></div><div class=\"line\"><span class=\"keyword\">let</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, s</span>)</span>&#123;</div><div class=\"line\">   <span class=\"keyword\">return</span> s.match(reg)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// replace :: Regex -&gt; String -&gt; String -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> replace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, sub, s</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s.replace(reg, sub)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(replace(<span class=\"regexp\">/world/ig</span>)(<span class=\"string\">'JS'</span>)(<span class=\"string\">'hello world'</span>))</div></pre></td></tr></table></figure>\n<p>strLength 和 capitalize 类似：接受一个 String 然后返回一个Number 。至于其他的，第一眼看起来可能会比较疑惑。不过在还不完全了解细节的情况下，你尽可能把最后一个类型视作返回值。那么 match 函数就可以这么理解：它接受一个 Regex 和一个 String ，返回一个 [String] 。</p>\n<p>这里有一个非常有趣的地方，对于 match 函数，我们完全可以把它的类型签名这样分组<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// match :: Regex -&gt; (String -&gt; [String])</span></div><div class=\"line\"><span class=\"keyword\">let</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, s</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s.match(reg)</div><div class=\"line\"> &#125;)</div></pre></td></tr></table></figure></p>\n<p>是的，把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出match 这个函数接受一个 Regex 作为参数，返回一个从 String 到 [String] 的函数。因为 curry，造成的结果就是这样：给 match 函数一个Regex ，得到一个新函数，能够处理其 String 参数。当然了，我们并非一定要这么看待这个过程，但这样思考有助于理解为何最后一个类型是返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// onHoliday :: String -&gt; [String]</span></div><div class=\"line\"><span class=\"keyword\">let</span> onHoliday = match(<span class=\"regexp\">/holiday/ig</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(onHoliday(<span class=\"string\">'hello holiday'</span>))</div></pre></td></tr></table></figure>\n<p>每传一个参数，就会弹出类型签名最前面的那个类型。所以 onHoliday 就是已经有了 Regex 参数的 match 。</p>\n<p>PS：我最近刚开始学习Haskell，Haskell里面所有函数都是auto-curried的。配合HM签名效果感觉很强大。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// replace :: Regex -&gt; (String -&gt; (String -&gt; String))</span></div><div class=\"line\"><span class=\"keyword\">let</span> replace = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, sub, s</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s.replace(reg, sub);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>但是在这段代码中，就像你看到的那样，为 replace 加上这么多括号未免有些多余。所以这里的括号是完全可以省略的，如果我们愿意，可以一次性把所有的参数都传进来；所以，一种更简单的思路是： replace 接受三个参数，分别是 Regex 、 String 和另一个 String ，返回的还是一个 String 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// id :: a -&gt; a</span></div><div class=\"line\"><span class=\"keyword\">let</span> id = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> x &#125;</div><div class=\"line\"><span class=\"comment\">// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></div><div class=\"line\"><span class=\"keyword\">let</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, xs</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> xs.map(f)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(map(<span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * <span class=\"number\">2</span>)([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]))</div></pre></td></tr></table></figure>\n<p>这里的 id 函数接受任意类型的 a 并返回同一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为 a 和 b 只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的一个原则，所以我们必须重申： a -&gt; b 可以是从任意类型的 a 到任意类型的 b ，但是 a -&gt; a 必须是同一个类型。例如， id 可以是 String -&gt; String ，也可以是 Number -&gt; Number ，但不能是 String -&gt; Bool 。</p>\n<p>相似地， map 也使用了变量，只不过这里的 b 可能与 a 类型相同，也可能不相同。我们可以这么理解： map 接受两个参数，第一个是从任意类型 a 到任意类型 b 的函数；第二个是一个数组，元素是任意类型的 a ； map 最后返回的是一个类型 b 的数组。</p>\n<p>辨别类型和它们的含义是一项重要的技能，这项技能可以让你在函数式编程的路上走得更远。不仅论文、博客和文档等更易理解，类型签名本身也基本上能够告诉你它的函数性（functionality）。要成为一个能够熟练读懂类型签名的人，你得勤于练习；不过一旦掌握了这项技能，你将会受益无穷，不读手册也能获取大量信息。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></div><div class=\"line\"><span class=\"keyword\">let</span> head = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>)</span>&#123; <span class=\"keyword\">return</span> xs[<span class=\"number\">0</span>]&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></div><div class=\"line\"><span class=\"keyword\">let</span> filter = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, xs</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> xs.filter(f)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></div><div class=\"line\"><span class=\"keyword\">let</span> reduce = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, x, xs</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> xs.reduce(f, x)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意看 reduce 的签名，可以看到它的第一个参数是个函数，这个函数接受一个 b 和一个 a 并返回一个 b 。那么这些 a 和 b 是从哪来的呢？很简单，签名中的第二个和第三个参数就是 b 和元素为 a 的数组，所以唯一合理的假设就是这里的 b 和每一个 a 都将传给前面说的函数作为参数。我们还可以看到， reduce 函数最后返回的结果是一个b ，也就是说， reduce 的第一个参数函数的输出就是 reduce 函数的输出。知道了 reduce 的含义，我们才敢说上面关于类型签名的推理是正确的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(reduce(<span class=\"function\">(<span class=\"params\">b, a</span>) =&gt;</span> a * b)(<span class=\"number\">3</span>)([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]))</div><div class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].reduce(<span class=\"function\">(<span class=\"params\">b, a</span>) =&gt;</span> a * b, <span class=\"number\">3</span>))</div></pre></td></tr></table></figure>\n<h3 id=\"缩小可能性范围\"><a href=\"#缩小可能性范围\" class=\"headerlink\" title=\"缩小可能性范围\"></a>缩小可能性范围</h3><p>一旦引入一个类型变量，就会出现一个奇怪的特性叫做 parametricity（<a href=\"http://en.wikipedia.org/wiki/Parametricity\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Parametricity</a> ）。这个特性表明，函数将会以一种统一的行为作用于所有的类型。</p>\n<p>a 告诉我们它不是一个特定的类型，这意味着它可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一。这就是 parametricity 的含义。</p>\n<p>这种“可能性范围的缩小”（narrowing of possibility）允许我们利用类似 Hoogle 这样的类型签名搜索引擎去搜索我们想要的函数。类型签名所能包含的信息量真的非常大。</p>\n<p><em>PS: Hoogle是Haskell官网中搜索文档的搜索引擎。</em></p>\n<h3 id=\"自由定理\"><a href=\"#自由定理\" class=\"headerlink\" title=\"自由定理\"></a>自由定理</h3><p>类型签名除了能够帮助我们推断函数可能的实现，还能够给我们带来自由定理（free theorems）。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></div><div class=\"line\">compose(f, head) == compose(head, map(f));</div><div class=\"line\"><span class=\"comment\">// filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></div><div class=\"line\">compose(map(f), filter(compose(p, f))) == compose(filter(p), map(f));</div></pre></td></tr></table></figure></p>\n<p>不用写一行代码你也能理解这些定理，它们直接来自于类型本身。</p>\n<p><em>PS: 这些函数是纯的才能成立。</em></p>\n<p>第一个例子中，等式左边说的是，先获取数组的第一个元素，然后对它调用函数 f ；等式右边说的是，先对数组中的每一个元素调用 f ，然后再取其返回结果的头部 。这两个表达式的作用是相等的，但是前者要快得多。</p>\n<p>第二个例子 filter 也是一样。等式左边是说，先组合 f 和 p 检查哪些元素要过滤掉，然后再通过 map 实际调用 f （别忘了 filter 是不会改变数组中元素的，这就保证了 a 将保持不变）；等式右边是说，先用 map 调用 f ，然后再根据 p 过滤元素。这两者也是相等的。</p>\n<h3 id=\"类型约束\"><a href=\"#类型约束\" class=\"headerlink\" title=\"类型约束\"></a>类型约束</h3><p>最后要注意的一点是，签名也可以把类型约束为一个特定的接口（interface）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sort :: Ord a =&gt; [a] -&gt; [a]</span></div></pre></td></tr></table></figure>\n<p>胖箭头左边表明的是这样一个事实： a 一定是个 Ord 对象。也就是说， a 必须要实现 Ord 接口。 Ord 到底是什么？它是从哪来的？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于 a 的更多信息，了解 sort 函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束（type constraints）。</p>\n<p>PS：Haskell里面存在Ord类型类，Rust里面也有类似的东西。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// assertEqual :: (Eq a, Show a) =&gt; a -&gt; a -&gt; Assertion</span></div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Hindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更需要花点时间了。</p>\n<h2 id=\"特百惠\"><a href=\"#特百惠\" class=\"headerlink\" title=\"特百惠\"></a>特百惠</h2><h3 id=\"强大的容器\"><a href=\"#强大的容器\" class=\"headerlink\" title=\"强大的容器\"></a>强大的容器</h3><p>我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？</p>\n<p>首先我们将创建一个容器（container）。这个容器必须能够装载任意类型的值。这个容器将会是一个对象，但我们不会为它添加面向对象观念下的属性和方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Container = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Container.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Container(x)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们将使用 Container.of 作为构造器（constructor），这样就不用到处去写糟糕的 new 关键字了，非常省心。 实际上不能这么简单地看待 of 函数，但暂时先认为它是把值放到容器里的一种方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Container.of(<span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">//=&gt; Container(3)</span></div><div class=\"line\">Container.of(<span class=\"string\">\"hotdogs\"</span>)</div><div class=\"line\"><span class=\"comment\">//=&gt; Container(\"hotdogs\")</span></div><div class=\"line\">Container.of(Container.of(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"yoda\"</span>&#125;))</div><div class=\"line\"><span class=\"comment\">//=&gt; Container(Container(&#123;name: \"yoda\" &#125;))</span></div></pre></td></tr></table></figure>\n<p>在继续后面的内容之前，先澄清几点：<br>Container 是个只有一个属性的对象。尽管容器可以有不止一个的属性，但大多数容器还是只有一个。我们很随意地把 Container 的这个属性命名为 <strong>value。</strong>value 不能是某个特定的类型，不然 Container 就对不起它这个名字了。数据一旦存放到 Container ，就会一直待在那儿。我们可以用 .__value 获取到数据，但这样做有悖初衷。</p>\n<h3 id=\"第一个-functor-函子\"><a href=\"#第一个-functor-函子\" class=\"headerlink\" title=\"第一个 functor(函子)\"></a>第一个 functor(函子)</h3><p>一旦容器里有了值，不管这个值是什么，我们就需要一种方法来让别的函数能够操作它。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// (a -&gt; b) -&gt; Container a -&gt; Container b</span></div><div class=\"line\">Container.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Container.of(f(Container.__value))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个 map 跟数组那个著名的 map 一样，除了前者的参数是 Container a 而后者是 [a] 。它们的使用方式也几乎一致</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Container.of(<span class=\"number\">2</span>).map(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num + <span class=\"number\">2</span>))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Container.of(<span class=\"string\">'hello'</span>).map(<span class=\"function\"><span class=\"params\">str</span> =&gt;</span> str.toUpperCase()))</div></pre></td></tr></table></figure>\n<p>为什么要使用这样一种方法？因为我们能够在不离开 Container 的情况下操作容器里面的值。这是非常了不起的一件事情。 Container 里的值传递给 map 函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的 Container。这样做的结果是，我们能连续地调用 map ，运行任何我们想运行的函数，甚至还可以改变值的类型。</p>\n<p>如果我们能一直调用 map ，那它不就是个组合（composition）么！这里边是有什么数学魔法在起作用？是 <code>functor</code>。各位，这个数学魔法就是 functor。</p>\n<p><em>functor 是实现了 map 函数并遵守一些特定规则的容器类型。</em></p>\n<p>没错，functor 就是一个签了合约的接口。functor 是范畴学里的概念。</p>\n<p>把值装进一个容器，而且只能使用 map 来处理它，这么做的理由到底是什么呢？如果我们换种方式来问，答案就很明显了：让容器自己去运用函数能给我们带来什么好处？答案是抽象，对于函数运用的抽象。当 map 一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。</p>\n<h3 id=\"薛定谔的-Maybe\"><a href=\"#薛定谔的-Maybe\" class=\"headerlink\" title=\"薛定谔的 Maybe\"></a>薛定谔的 Maybe</h3><p>说实话 Container 挺无聊的，而且通常我们称它为 Identity ，与 id 函数的作用相同（这里也是有数学上的联系的）。除此之外，还有另外一种 functor，那就是实现了 map 函数的类似容器的数据类型，这种 functor 在调用 map 的时候能够提供非常有用的行为。现在让我们来定义一个这样的 functor。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Maybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Maybe.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Maybe(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Maybe.prototype.isNothing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.__value === <span class=\"literal\">null</span>) || (<span class=\"keyword\">this</span>.__value === <span class=\"literal\">undefined</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Maybe.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.isNothing() ? Maybe.of(<span class=\"literal\">null</span>) : Maybe.of(f(<span class=\"keyword\">this</span>.__value))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Maybe 会先检查自己的值是否为空，然后才调用传进来的函数。这样我们在使用 map 的时候就能避免恼人的空值了（这个实现出于教学目的做了简化）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(Maybe.of(<span class=\"string\">'Malkovich Malkovich'</span>).map(match(<span class=\"regexp\">/a/ig</span>)))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Maybe.of(<span class=\"literal\">null</span>).map(match(<span class=\"regexp\">/a/ig</span>)))</div><div class=\"line\"><span class=\"built_in\">console</span>.log(Maybe.of(&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"Dinah\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">14</span>&#125;).map(_.property(<span class=\"string\">'age'</span>)))</div></pre></td></tr></table></figure>\n<p>当传给 map 的值是 null 时，代码并没有爆出错误。这是因为每一次 Maybe 要调用函数的时候，都会先检查它自己的值是否为空。</p>\n<p>这种点记法（dot notation syntax）已经足够函数式了，但是正如在第 1 部分指出的那样，我们更想保持一种 pointfree 的风格。碰巧的是， map 完全有能力以 curry 函数的方式来“代理”任何 functor。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></div><div class=\"line\">map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, any_functor_at_all</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> any_functor_at_all.map(f)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样我们就可以像平常一样使用组合，同时也能正常使用 map 了，非常振奋人心。<code>ramda</code> 的 map 也是这样。后面的，我们将在点记法更有教育意义的时候使用点记法，在方便使用 pointfree 模式的时候就用 pointfree。你注意到了么？我在类型标签中偷偷引入了一个额外的标记： Functor f =&gt; 。这个标记告诉我们 f 必须是一个 functor。</p>\n<p>用例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// safeHead :: [a] -&gt; Maybe(a)</span></div><div class=\"line\"><span class=\"keyword\">let</span> safeHead = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Maybe.of(xs[<span class=\"number\">0</span>])</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> streetName = compose(compose(map(_.property(<span class=\"string\">'street'</span>)), safeHead), _.property(<span class=\"string\">'addresses'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(streetName(&#123;<span class=\"attr\">addresses</span>:[]&#125;))</div><div class=\"line\"><span class=\"comment\">// Maybe(null)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(streetName(&#123;<span class=\"attr\">addresses</span>: [&#123;<span class=\"attr\">street</span>: <span class=\"string\">\"Shady Ln.\"</span>, <span class=\"attr\">number</span>: <span class=\"number\">4201</span>&#125;]&#125;))</div><div class=\"line\"><span class=\"comment\">// Maybe(\"Shady Ln.\")</span></div></pre></td></tr></table></figure>\n<p>safeHead 与一般的 _.head 类似，但是增加了类型安全保证。引入 Maybe 会发生一件非常有意思的事情，那就是我们被迫要与狡猾的 null 打交道了。 safeHead 函数能够诚实地预告它可能的失败,然后返回一个 Maybe 来通知我们相关信息。实际上不仅仅是通知，因为毕竟我们想要的值深藏在 Maybe 对象中，而且只能通过 map 来操作它。<em>本质上，这是一种由 safeHead 强制执行的空值检查。</em> 类似这样的 API 能够把一个像纸糊起来的、脆弱的应用升级为实实在在的、健壮的应用，这样的 API 保证了更加安全的软件。</p>\n<p>有时候函数可以明确返回一个 Maybe(null) 来表明失败</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// withdraw :: Number -&gt; Account -&gt; Maybe(Account)</span></div><div class=\"line\"><span class=\"keyword\">let</span> withdraw = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">amount, account</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> account.balance &gt;= account ?</div><div class=\"line\">        Maybe.of(&#123;<span class=\"attr\">account</span>: account.balance - account&#125;) :</div><div class=\"line\">        Maybe.of(<span class=\"literal\">null</span>)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// finishTransaction :: Account -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> finishTransaction = compose(remainingBalance, updateLedger)</div><div class=\"line\"><span class=\"comment\">// &lt;- 假定这两个函数已经在别处定义好了</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getTwenty :: Account -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> getTwenty = compose(map(finishTransaction), withdraw(<span class=\"number\">20</span>))</div><div class=\"line\"></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">200.00</span>&#125;)</div><div class=\"line\"><span class=\"comment\">// Maybe(\"Your balance is $180.00\")</span></div><div class=\"line\"></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">10.00</span>&#125;)</div><div class=\"line\"><span class=\"comment\">// Maybe(null)</span></div></pre></td></tr></table></figure>\n<p>withdraw 也显示出了它的多变性，使得我们后续的操作只能用 map 来进行。这个例子与前面例子不同的地方在于，这里的 null 是有意的。我们不用 Maybe(String) ，而是用 Maybe(null)来发送失败的信号，这样程序在收到信号后就能立刻停止执行。这一点很重要：如果 withdraw 失败了，map 就会切断后续代码的执行，因为它根本就不会运行传递给它的函数，即finishTransaction 。这正是预期的效果：如果取款失败，我们并不想更新或者显示账户余额。</p>\n<h3 id=\"释放容器里的值\"><a href=\"#释放容器里的值\" class=\"headerlink\" title=\"释放容器里的值\"></a>释放容器里的值</h3><p>人们经常忽略的一个事实是：任何事物都有个最终尽头。那些会产生作用的函数，不管它们是发送 JSON 数据，还是在屏幕上打印东西，还是更改文件系统，还是别的什么，都要有一个结束。但是我们无法通过 return 把输出传递到外部世界，必须要运行这样或那样的函数才能传递出去。</p>\n<p>应用程序所做的工作就是获取、更改和保存数据直到不再需要它们，对数据做这些操作的函数有可能被 map 调用，这样的话数据就可以不用离开它温暖舒适的容器。讽刺的是，有一种常见的错误就是试图以各种方法删除 Maybe 里的值，好像这个不确定的值是魔鬼，删除它就能让它突然显形，然后一切罪恶都会得到宽恕似的（此处原文应该是源自圣经）。要知道，我们的值没有完成它的使命，很有可能是其他代码分支造成的。我们的代码，就像薛定谔的猫一样，在某个特定的时间点有两种状态，而且应该保持这种状况不变直到最后一个函数为止。这样，哪怕代码有很多逻辑性的分支，也能保证一种线性的工作流。</p>\n<p>不过，对容器里的值来说，还是有个逃生口可以出去。也就是说，如果我们想返回一个自定义的值然后还能继续执行后面的代码的话，是可以做到的；要达到这一目的，可以借助一个帮助函数 maybe ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b</span></div><div class=\"line\"><span class=\"keyword\">let</span> maybe = _.curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, f, m</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> m.isNothing() ? x : f(m.__value)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getTwenty :: Account -&gt; String</span></div><div class=\"line\"><span class=\"keyword\">let</span> getTwenty = compose(maybe(<span class=\"string\">\"You're broke!\"</span>, finishTransaction), withdraw(<span class=\"number\">20</span>))</div><div class=\"line\"></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">200.00</span>&#125;);</div><div class=\"line\"><span class=\"comment\">// \"Your balance is $180.00\"</span></div><div class=\"line\">getTwenty(&#123; <span class=\"attr\">balance</span>: <span class=\"number\">10.00</span>&#125;);</div><div class=\"line\"><span class=\"comment\">// \"You're broke!\"</span></div></pre></td></tr></table></figure>\n<p>这样就可以要么返回一个静态值（与 finishTransaction 返回值的类型一致），要么继续愉快地在没有 Maybe 的情况下完成交易。 maybe 使我们得以避免普通 map 那种命令式的 if/else 语句： if(x !== null) { return f(x) } 。</p>\n<p>引入 Maybe 可能会在初期造成一些不适。Swift 和 Scala 用户知道我在说什么，因为这两门语言的核心库里就有 Maybe 的概念，只不过伪装成 Option(al) 罢了。</p>\n<p><em>PS：Haskell 里面有Maybe，Rust里面也是类似伪装成 Option。</em></p>\n<p>被迫在任何情况下都进行空值检查，的确让大部分人头疼不已。然而随着时间推移，空值检查会成为第二本能，不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。</p>\n<p>Maybe 能够非常有效地帮助我们增加函数的安全性。</p>\n<p>有一点我必须要提及，否则就太不负责任了，那就是 Maybe 的“真正”实现会把它分为两种类型：一种是非空值，另一种是空值。这种实现允许我们遵守 map 的 parametricity 特性，因此 null 和 undefined 能够依然被 map 调用，functor 里的值所需的那种普遍性条件也能得到满足。所以你会经常看到 Some(x) / None 或者 Just(x) / Nothing 这样的容器类型在做空值检查，而不是Maybe 。</p>\n<h3 id=\"“纯”错误处理\"><a href=\"#“纯”错误处理\" class=\"headerlink\" title=\"“纯”错误处理\"></a>“纯”错误处理</h3><p>说出来可能会让你震惊， throw/catch 并不十分“纯”。当一个错误抛出的时候，我们没有收到返回值，反而是得到了一个警告！</p>\n<p>有了 Either 这个新朋友，我们就能以一种好得多的方式来处理错误，那就是返回一条非常礼貌的消息作为回应。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Left = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Left.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Left(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Left.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> Right = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = x</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Right.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Right(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Right.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Right.of(f(<span class=\"keyword\">this</span>.__value))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Left 和 Right 是我们称之为 Either 的抽象类型的两个子类。</span></div><div class=\"line\"><span class=\"keyword\">let</span> right = Right.of(<span class=\"string\">\"rain\"</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"b\"</span> + str</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// Right(\"brain\")</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> left = Left.of(<span class=\"string\">\"rain\"</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"b\"</span> + str</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// Left(\"rain\")</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Right.of(&#123;<span class=\"attr\">host</span>: <span class=\"string\">'localhost'</span>, <span class=\"attr\">port</span>:<span class=\"number\">80</span>&#125;).map(_.property(<span class=\"string\">'host'</span>)))</div><div class=\"line\"><span class=\"comment\">// Right('localhost')</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(Left.of(<span class=\"string\">\"rolls eyes...\"</span>).map(_.property(<span class=\"string\">'host'</span>)))</div><div class=\"line\"><span class=\"comment\">// Left('rolls eyes...')</span></div></pre></td></tr></table></figure>\n<p>Left 就像是青春期少年那样无视我们要 map 它的请求。 Right 的作用就像是一个 Container （也就是 Identity）。这里强大的地方在于， Left 有能力在它内部嵌入一个错误消息。</p>\n<p>假设有一个可能会失败的函数，就拿根据生日计算年龄来说好了。的确，我们可以用 Maybe(null) 来表示失败并把程序引向另一个分支，但是这并没有告诉我们太多信息。很有可能我们想知道失败的原因是什么。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> getAge = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">now, user</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> birthdate = moment(user.birthdate, <span class=\"string\">'YYYY-MM-DD'</span>)</div><div class=\"line\">    <span class=\"keyword\">if</span>(!birthdate.isValid()) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Left.of(<span class=\"string\">\"Birth date could not be parsed\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> Right.of(now.diff(birthdate, <span class=\"string\">'years'</span>))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'1996-12-30'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// Right(21)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'12-30'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// Left(\"Birth date could not be parsed\")</span></div></pre></td></tr></table></figure>\n<p>这么一来，就像 Maybe(null) ，当返回一个 Left 的时候就直接让程序短路。跟 Maybe(null) 不同的是，现在我们对程序为何脱离原先轨道至少有了一点头绪。有一件事要注意，这里返回的是 Either(String, Number) ，意味着我们这个 Either 左边Left的值是 String，右边Right，也就是正确的值，是 Number 。这个类型签名不是很正式，因为我们并没有定义一个真正的 Either父类；但我们还是从这个类型那里了解到不少东西。它告诉我们，我们得到的要么是一条错误消息，要么就是正确的值。</p>\n<p>PS：Rust里面也有类似的概念，对应于Result enum里的Ok，Err。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// map 如之前所实现，会调用container的map方法</span></div><div class=\"line\"><span class=\"comment\">// zoltar :: User -&gt; Either(String, _)</span></div><div class=\"line\"><span class=\"keyword\">let</span> zoltar = compose(map(<span class=\"built_in\">console</span>.log), getAge(moment()))</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(zoltar(&#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'1996-12-30'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// 21</span></div><div class=\"line\"><span class=\"comment\">// Right(undefined)</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(zoltar(&#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'balloons!'</span>&#125;))</div><div class=\"line\"><span class=\"comment\">// Left(\"Birth date could not be parsed\")</span></div></pre></td></tr></table></figure>\n<p>如果 birthdate 合法，这个程序就会把它神秘的命运打印在屏幕上让我们见证；如果不合法，我们就会收到一个有着清清楚楚的错误消息的 Left ，尽管这个消息是稳稳当当地待在它的容器里的。这种行为就像，虽然我们在抛错，但是是以一种平静温和的方式抛错，而不是像一个小孩子那样，有什么不对劲就闹脾气大喊大叫。</p>\n<p>我们根据 birthdate 的合法性来控制代码的逻辑分支，同时又让代码进行从右到左的直线运动，而不用爬过各种条件语句的大括号。</p>\n<p>我们在 Right 分支的类型签名中使用 _ 表示一个应该忽略的值（在有些浏览器中，你必须要 console.log.bind(console) 才能把 console.log 当作一等公民使用）。</p>\n<p>这个例子中，尽管 fortune 使用了 Either ，它对每一个 functor 到底要干什么却是毫不知情的。通俗点来讲，一个函数在调用的时候，如果被map 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数。<em>我们把这个过程叫做 lift。</em></p>\n<p>一般情况下，普通函数更适合操作普通的数据类型而不是容器类型，在必要的时候再通过 lift 变为合适的容器去操作容器类型。这样做的好处是能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor。</p>\n<p>Either 并不仅仅只对合法性检查这种一般性的错误作用非凡，对一些更严重的、能够中断程序执行的错误比如文件丢失或者 socket 连接断开等， Either 同样效果显著。</p>\n<p>它的能耐远不止于此。比如，它表示了逻辑或（也就是||）。再比如，它体现了范畴学里 coproduct 的概念。还比如，它是标准的 sum type（或者叫不交并集，disjoint union of sets），因为它含有的所有可能的值的总数就是它包含的那两种类型的总数。</p>\n<p>Either 能做的事情多着呢，但是作为一个 functor，我们就用它处理错误。</p>\n<p>就像 Maybe 可以有个 maybe 一样， Either 也可以有一个 either 。两者的用法类似，但 either 接受两个函数（而不是一个）和一个静态值为参数。这两个函数的返回值类型一致：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> either = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g, e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span>(e.constructor) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> Left: <span class=\"keyword\">return</span> f(e.__value)</div><div class=\"line\">        <span class=\"keyword\">case</span> Right: <span class=\"keyword\">return</span> g(e.__value)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> localStorage = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// getFromStorage :: String -&gt; (_ -&gt; String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> getFromStorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> localStorage[key]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要是我们没把 getFromStorage 包在另一个函数里，它的输出值就是不定的，会随外部环境变化而变化。有了这个结实的包裹函数（wrapper），同一个输入就总能返回同一个输出：一个从 localStorage 里取出某个特定的元素的函数。</p>\n<p>然而，这并没有多大的用处。就像是你收藏的全新未拆封的玩偶，不能拿出来玩有什么意思。所以要是能有办法进到这个容器里面，拿到它藏在那儿的东西就好了…办法是有的，请看 <code>IO</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> IO = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.__value = f</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(compose(f, <span class=\"keyword\">this</span>.__value))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>IO 跟之前的 functor 不同的地方在于，它的 __value 总是一个函数。不过我们不把它当作一个函数——实现的细节我们最好先不管。这里发生的事情跟我们在getFromStorage 那里看到的一模一样： IO 把非纯执行动作（impure action）捕获到包裹函数里，目的是延迟执行这个非纯动作。就这一点而言，我们认为 IO 包含的是被包裹的执行动作的返回值，而不是包裹函数本身。<br>这在 of 函数里很明显： IO(function(){ return x }) 仅仅是为了延迟执行，其实我们得到的是 IO(x) 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> io_window = <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">io_window.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">win</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.innerWidth</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">// IO(1430)</span></div><div class=\"line\"></div><div class=\"line\">io_window2 = io_window.map(_.property(<span class=\"string\">'location'</span>))</div><div class=\"line\">        .map(_.property(<span class=\"string\">'href'</span>))</div><div class=\"line\">        .map(_.split(<span class=\"string\">'/'</span>))</div><div class=\"line\"><span class=\"comment\">// IO([\"http:\", \"\", \"localhost:8000\", \"blog\", \"posts\"])</span></div></pre></td></tr></table></figure>\n<p>这里， io_window 是一个真正的 IO ，我们可以直接对它使用 map 。我把这里的返回值都写成了概念性的，这样就更加直观；不过实际的返回值是 { __value: [Function] } 。当调用 IO 的 map 的时候，我们把传进来的函数放在了 map 函数里的组合的最末端（也就是最左边），反过来这个函数就成为了新的 IO 的新 value ，并继续下去。传给 map 的函数并没有运行，我们只是把它们压到一个“运行栈”的最末端而已，一个函数紧挨着另一个函数，就像小心摆放的多米诺骨牌一样，让人不敢轻易推倒。这种情形很容易叫人联想起“四人帮”（《设计模式》一书作者）提出的命令模式（command pattern）或者队列（queue）。</p>\n<p>IO 的 value 并不是它包含的值，也不是像两个下划线暗示那样是一个私有属性。value 是手榴弹的弹栓，只应该被调用者以最公开的方式拉动。为了提醒用户它的变化无常，我们把它重命名为 unsafePerformIO 看看</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> IO = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.unsafePerformIO = f</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> x</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">IO.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(compose(f, <span class=\"keyword\">this</span>.unsafePerformIO))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在调用的代码对于应用程序的用户简直就直白得不能再直白了。</p>\n<p>之后我们将学习一种跟 IO 在精神上相似，但是用法上又千差万别的类型。</p>\n<h3 id=\"异步任务\"><a href=\"#异步任务\" class=\"headerlink\" title=\"异步任务\"></a>异步任务</h3><p>处理异步代码，我们有一种更好的方式，它的名字以“F”开头。这种方式的内部机制过于复杂，复杂得哪怕我唾沫横飞也很难讲清楚。所以我们就直接用 Quildreen Motta 的 Folktale 里的 Data.Task。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Folktale = <span class=\"built_in\">require</span>(<span class=\"string\">'folktale'</span>)</div><div class=\"line\"><span class=\"keyword\">const</span> Task = Folktale.concurrency.task</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Node readfile example:</span></div><div class=\"line\"><span class=\"comment\">//=======================</span></div><div class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"><span class=\"comment\">// readFile :: String -&gt; Task(Error, JSON)</span></div><div class=\"line\"><span class=\"keyword\">let</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Task(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reject, result</span>) </span>&#123;</div><div class=\"line\">        fs.readFile(filename, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">            err ? reject(err) : result(data);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">readFile(<span class=\"string\">\"metamorphosis\"</span>).map(split(<span class=\"string\">'\\n'</span>)).map(head);</div><div class=\"line\"><span class=\"comment\">// Task(\"One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// in bed he had been changed into a monstrous verminous bug.\")</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// jQuery getJSON example:</span></div><div class=\"line\"><span class=\"comment\">//========================</span></div><div class=\"line\"><span class=\"comment\">// getJSON :: String -&gt; &#123;&#125; -&gt; Task(Error, JSON)</span></div><div class=\"line\"><span class=\"keyword\">let</span> getJSON = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, params</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Task(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reject, result</span>) </span>&#123;</div><div class=\"line\">        $.getJSON(url, params, result).fail(reject);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">getJSON(<span class=\"string\">'/video'</span>, &#123;<span class=\"attr\">id</span>: <span class=\"number\">10</span>&#125;).map(_.prop(<span class=\"string\">'title'</span>));</div><div class=\"line\"><span class=\"comment\">// Task(\"Family Matters ep 15\")</span></div><div class=\"line\"><span class=\"comment\">// 传入普通的实际值也没问题</span></div><div class=\"line\">Task.of(<span class=\"number\">3</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">three</span>)</span>&#123; <span class=\"keyword\">return</span> three + <span class=\"number\">1</span> &#125;);</div><div class=\"line\"><span class=\"comment\">// Task(4)</span></div></pre></td></tr></table></figure>\n<p>例子中的 reject 和 result 函数分别是失败和成功的回调。正如你看到的，我们只是简单地调用 Task 的 map 函数，就能操作将来的值，好像这个值就在那儿似的。</p>\n<p>如果熟悉 promise 的话，你该能认出来 map 就是 then ， Task 就是一个promise。</p>\n<p>与 IO 类似， Task 在我们给它绿灯之前是不会运行的。事实上，正因为它要等我们的命令， IO 实际就被纳入到了 Task 名下，代表所有的异步操作—— readFile 和 getJSON 并不需要一个额外的 IO 容器来变纯。更重要的是，当我们调用它的 map 的时候， Task 工作的方式与 IO 几无差别：都是把对未来的操作的指示放在一个时间胶囊里，就像家务列表（chore chart）那样——<br>真是一种精密的拖延术。</p>\n<p>我们必须调用 fork 方法才能运行 Task ，这种机制与 unsafePerformIO 类似。但也有不同，不同之处就像 fork 这个名称表明的那样，它会 fork 一个子进程运行它接收到的参数代码，其他部分的执行不受影响，主线程也不会阻塞。当然这种效果也可以用其他一些技术比如线程实现，但这里的这种方法工作起来就像是一个普通的异步调用，而且 event loop 能够不受影响地继续运转。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Pure application</span></div><div class=\"line\"><span class=\"comment\">//=====================</span></div><div class=\"line\"><span class=\"comment\">// blogTemplate :: String</span></div><div class=\"line\"><span class=\"comment\">// blogPage :: Posts -&gt; HTML</span></div><div class=\"line\"><span class=\"keyword\">let</span> blogPage = Handlebars.compile(blogTemplate);</div><div class=\"line\"><span class=\"comment\">// renderPage :: Posts -&gt; HTML</span></div><div class=\"line\"><span class=\"keyword\">let</span> renderPage = compose(blogPage, sortBy(<span class=\"string\">'date'</span>));</div><div class=\"line\"><span class=\"comment\">// blog :: Params -&gt; Task(Error, HTML)</span></div><div class=\"line\"><span class=\"keyword\">let</span> blog = compose(map(renderPage), getJSON(<span class=\"string\">'/posts'</span>));</div><div class=\"line\"><span class=\"comment\">// Impure calling code</span></div><div class=\"line\"><span class=\"comment\">//=====================</span></div><div class=\"line\">blog(&#123;&#125;).fork(</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>)</span>&#123; $(<span class=\"string\">\"#error\"</span>).html(error.message); &#125;,</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">page</span>)</span>&#123; $(<span class=\"string\">\"#main\"</span>).html(page); &#125;</div><div class=\"line\">);</div><div class=\"line\">$(<span class=\"string\">'#spinner'</span>).show();</div></pre></td></tr></table></figure>\n<p>调用 fork 之后， Task 就赶紧跑去找一些文章，渲染到页面上。与此同时，我们在页面上展示一个 spinner，因为 fork 不会等收到响应了才执行它后面的代码。最后，我们要么把文章展示在页面上，要么就显示一个出错信息，视getJSON 请求是否成功而定。</p>\n<p>我们只需要从下读到上，从右读到左就能理解代码，即便这段程序实际上会在执行过程中到处跳来跳去。这种方式使得阅读和理解应用程序的代码比那种要在各种回调和错误处理代码块之间跳跃的方式容易得多。</p>\n<h3 id=\"一点理论\"><a href=\"#一点理论\" class=\"headerlink\" title=\"一点理论\"></a>一点理论</h3><p>functor 的概念来自于范畴学，并满足一些定律。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// identity</span></div><div class=\"line\">map(id) === id;</div><div class=\"line\"><span class=\"comment\">// composition</span></div><div class=\"line\">compose(map(f), map(g)) === map(compose(f, g));</div></pre></td></tr></table></figure>\n<p>同一律很简单，但是也很重要。因为这些定律都是可运行的代码，所以我们完全可以在我们自己的 functor 上试验它们，验证它们是否成立。</p>\n<p>在范畴学中，functor 接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（identity），也一定能够组合态射；我们无须验证这一点，前面提到的定律保证这些东西会在映射后得到保留。</p>\n<p>可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。如果一个对象 a 属于源范畴 C ，那么通过 <code>functor F</code> 把 a 映射到目标范畴 D 上之后，就可以使用 <code>F a</code> 来指代 a 对象。</p>\n<p><img src=\"functor映射.png\" alt=\"functor映射\"></p>\n<p>比如， Maybe 就把类型和函数的范畴映射到这样一个范畴：即每个对象都有可能不存在，每个态射都有空值检查的范畴。这个结果在代码中的实现方式是用 map 包裹每一个函数，用 functor 包裹每一个类型。这样就能保证每个普通的类型和函数都能在新环境下继续使用组合。</p>\n<p>从技术上讲，代码中的 functor 实际上是把范畴映射到了一个包含类型和函数的子范畴（sub category）上，使得这些 functor 成为了一种新的特殊的 endofunctor。可以用一张图来表示这种态射及其对象的映射。</p>\n<p><img src=\"functor映射2.png\" alt=\"functor映射2\"></p>\n<p>这张图除了能表示态射借助 functor F 完成从一个范畴到另一个范畴的映射之外，我们发现它还符合交换律，也就是说，顺着箭头的方向往前，形成的每一个路径都指向同一个结果。不同的路径意味着不同的行为，但最终都会得到同一个数据类型。这种形式化给了我们原则性的方式去思考代码——无须分析和评估每一个单独的场景，只管可以大胆地应用公式即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// topRoute :: String -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> topRoute = compose(Maybe.of, safeHead);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// bottomRoute :: String -&gt; Maybe(String) </span></div><div class=\"line\"><span class=\"keyword\">let</span> bottomRoute = compose(map(safeHead), Maybe.of);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(topRoute(<span class=\"string\">'hi'</span>));</div><div class=\"line\"><span class=\"comment\">// Maybe('h')</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(bottomRoute(<span class=\"string\">'hi'</span>));</div><div class=\"line\"><span class=\"comment\">// Maybe('h')</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// topRoute :: String -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> topRoute = compose(Maybe.of, reverse);</div><div class=\"line\"><span class=\"comment\">// bottomRoute :: String -&gt; Maybe(String)</span></div><div class=\"line\"><span class=\"keyword\">let</span> bottomRoute = compose(map(reverse), Maybe.of);</div><div class=\"line\"></div><div class=\"line\">topRoute(<span class=\"string\">\"hi\"</span>);</div><div class=\"line\"><span class=\"comment\">// Maybe(\"ih\")</span></div><div class=\"line\">bottomRoute(<span class=\"string\">\"hi\"</span>);</div><div class=\"line\"><span class=\"comment\">// Maybe(\"ih\")</span></div></pre></td></tr></table></figure>\n<p><img src=\"functor映射实例.png\" alt=\"functor映射实例\"></p>\n<p>根据所有 functor 都有的特性，我们可以立即理解代码，重构代码。</p>\n<p>functor 也能嵌套使用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> nested = Task.of([Right.of(<span class=\"string\">\"pillows\"</span>), Left.of(<span class=\"string\">\"no sleep for you\"</span>)]);</div><div class=\"line\"></div><div class=\"line\">map(map(map(toUpperCase)), nested);</div><div class=\"line\"></div><div class=\"line\">Task([Right(<span class=\"string\">\"PILLOWS\"</span>), Left(<span class=\"string\">\"no sleep for you\"</span>)])</div></pre></td></tr></table></figure>\n<p>nested 是一个将来的数组，数组的元素有可能是程序抛出的错误。我们使用map 剥开每一层的嵌套，然后对数组的元素调用传递进去的函数。可以看到，这中间没有回调、 if/else 语句和 for 循环，只有一个明确的上下文。的确，我们必须要 map(map(map(f))) 才能最终运行函数。不想这么做的话，可以组合 functor。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> Compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f_g_x</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.getCompose = f_g_x;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Compose.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(map(map(f), <span class=\"keyword\">this</span>.getCompose));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>functor 组合是符合结合律的，而且之前我们定义的 Container 实际上是一个叫 Identity 的 functor。identity 和可结合的组合也能产生一个范畴，这个特殊的范畴的对象是其他范畴，态射是 functor。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>我们已经认识了几个不同的 functor，但它们的数量其实是无限的。有一些值得注意的可迭代数据类型（iterable data structure）我们没有介绍，像 tree、list、map 和 pair 等，以及所有你能说出来的。eventstream 和 observable 也都是 functor。其他的 functor 可能就是拿来做封装或者仅仅是模拟类型。我们身边到处都有 functor的身影。</p>\n<p>用多个 functor 参数调用一个函数怎么样呢？处理一个由不纯的或者异步的操作组成的有序序列怎么样呢？要应对这个什么都装在盒子里的世界，目前我们工具箱里的工具还不全。下一章，我们将直奔 monad 而去。</p>\n<h2 id=\"自我总结\"><a href=\"#自我总结\" class=\"headerlink\" title=\"自我总结\"></a>自我总结</h2><p>PS里面是自己的话。</p>\n<p>这部分的其实还有挺多的东西没有搞懂，书中许多代码其实是无法运行的，或者依赖很多编写成本很大。书里面还有一些题目，我也没有花时间进去。个人觉得这本书比一般的函数式书要深入，当然估计在Haskell书里，这些知识都很常规。其他的东西大部分都是书中的内容，我自己进行了少量地修改和较多地删减。</p>\n<p>最近在学习Rust和Haskell，打算寒假精力主要放在学习这2门语言特有的特性，说白了，就是安全性和函数式。<br>但是这2门语言门槛其实都不低，2018年平时可能会投入一些精力去学习。寒假如果顺利，希望能用这些语言来复习数据结构的知识。<br>下个学期特意选了一些偏实战专业课，打算把新学到的语言、特性和思想用起来。</p>\n<p>这本书最后还有2章，如果有机会，想在寒假看完。</p>"},{"title":"关于未来方向学习的思考","date":"2017-08-11T15:43:14.000Z","_content":"# 总结现状\n\n## 如今\n\n今天是周五，等会就周六了。虽然平时经常忙活在电脑前，但好像没在做什么特别有意义的事情，看到github一个好项目就想着去看它的源码，然后呢，迫于水平不够，一堆工具也掌握的不利索，怎么也没法开始学。其实大概是自己内心不知道以后到底想去做什么吧。其实2，3w行的代码如果搞懂它的流程，而且又熟悉相关语言并懂得一些相关方向的知识，应该是可以开始看了，起码不应该想到看就害怕而退缩，这连第一步都没有走呢。\n\n## 想法\n\n比较坚定的想法呢是以后做编译相关工作，这个工作岗位很少，要求也很高，许多大神高中就开始接触了。我呢，现在还半吊子，最近才开始理解了最基本的知识，将来如果要考研，这应该是计算机体系结构这个方向的研究生吧。而这2个月一直在学机器学习，但我只是对它的原理好奇，又想着机器学习方向能跟数学打交道，又能锻炼算法能力，便很欣然地参加了这次暑假集训。最近这个月有些忙坏了，但又觉得自己学到知识很少，可能是太贪心了吧，自己对计算机许多方向都感兴趣，但未曾深入其中一个。我还经常跟同学说那句话：不要总想着以后要干嘛，你现在在干嘛，以后很可能就在干嘛，所以要干嘛就赶紧现在就开始干。其实我自己也没有做到我所说，虽然我非常希望自己能做到。\n\n<!-- more -->\n\n## 兴趣\n\n最近查阅了一些资料，其实都是自己以前都看过，只是很多不少都忘记了或者没有重视起来。记得大一时候对C++兴趣特别浓厚，买了C++primer和STL源码剖析，还很认真看过（但没怎么敲代码），后来接触了的其他编程语言，C++也基本没有使用过了。现在要是还记得大一C++要求的内容就不错咯。\n\n但我知识，我想以后从事的方向很可能离不开C++（至少10年是这样）。不论是机器学习或者是编译原理，还是网络编程，在高性能的场合，永远需要它。\n\n目前我比较感兴趣的是编译原理，机器学习，网络编程吧。\n这三个都可以学很深，无底洞。编译原理简单的话，写个编译器前端，嗯，可能还不如自动化工具强，学的深入了，就得学后端了，代码优化，无底洞，国内好像没几家公司需要这种人才（大概更不需要应届生吧）。不过作为“永不失业的职业”，我对编译原理里面的设计成分更感兴趣，即自制语言。而如果作为一个应用开发者的话，约束应该大很多了，很多时候公式让你做的跟你的兴趣点完全无关，再考虑国内公司的尿性，不让你干缺德的就不错了。\n\n扯远了，关于“设计”这种概念，对于机器学习跟网络编程，也同样适用吧。机器学习重在解决问题，而设计算法是重要环节，这里设计部分可能要发挥脑力，而不是跟风地调用算法，我觉得这里也是很有意思的部分，但如果是解决商业问题，或者做项目的话，自由度感觉不大，倒是留在实验室研究什么的更有意思（虽然最近就是留实验室学习，有点小枯燥）。而网络编程，重点是在网络层以上的开发，打交道是传输层跟应用层，设计协议是很有意思的一环。怎么样的协议更有语义，更高效，更安全，扩展性强，我觉得这部分自制性很强，也是很有研究的感觉。\n\n隐隐约约觉得以上三个方向深入研究最后都要跟并发或性能打交道。毫无疑问，编译原理，优化部分，可能需要把代码隐式转换为并发代码，或者编译成适合并发的机器代码。机器学习虽然是高阶算法，但依托于大数据平台，而底层需要高并发，分布式的架构。有时候算法策略本身可能需要考虑容易并发，而如果设计一个机器学习平台或者系统，底层模型肯定到处是并发，也明显需要分布式。网络编程呢，则是为了更好的进行数据交换，也是并发的策略之一，更是分布式计算的基石。\n\n以上三个方向，在底层方面最需要的便是C++了。众所周知C++是比较难掌握的，虽然现在情况在变好，但我其实还蛮担心自己毕业前连基本的STL都用不好。\n\n## 基本规划\n\n好像写了这么多，还是不清楚接下来应该如何去学习知识，在这最后的2年时间。其实下个学期课挺多的，而且都是比较难的课，虽然大部分我都挺感兴趣的，但精力一旦不足，我容易对计算机感到一种疲惫，然后几天不碰。而下个学期如此多的课的情况，在学好课内之余如何把课外感兴趣的知识补上呢（C++，机器学习，网络编程深入学习）。可能就只能在周末多抽出时间学习了吧。\n算上准备考研，也该多用用C++了，这样数据结构也算复习了。而下学期部分课需要一些数学知识，正好稍微注重一下复习数学，也算事半功倍了。网络编程这部分，即使只是简单地学习，对计算机网络这门课帮助也不少啊，感觉咬咬牙，下学期真的能学到很多知识吧，只希望自己不要自暴自弃，要善于总结学到的知识。\n\n如此一想，感觉也想通了一些，毕竟学习编译原理，计算机网络，操作系统的时候是完全可以用C++来实现相应的功能的，这也锻炼了我C++的水平，但可能目前完全达不到吧，所以打算暑假稍微学习一下C++。\n\n嗯，决定了，暑假还剩一个月，我打算学习以下内容：\n\n* 机器学习跟深度学习，这部分跟实验室进度来，尽量不落下吧\n* C++，看些简单的源码，学习一下STL，把忘记的捡起来\n* 简单的编译原理学习，实现几个简单的玩具编译器（已经跟着博客抄了一个，感觉还需要再写一个），如果可能的话，用C++来实现\n* 网络编程，这一块，估计很麻烦，我基本没有实战过，倒是有基本的理论知识，理想情况下应该是golang或者nodejs来写（它们封装的很好，写起来难度容易接受），C++写的话，估计写一个月也写不出什么。所以尽量暑假尝试写个简单协议（突然想起来之前写redgo，有机会完善下）\n\n其实对C++一向是又爱又恨，爱是觉得这门语言太重要了，感觉如果掌握，用其他语言也就游刃有余了，而且有些语法感觉真的很厉害。恨是觉得这门语言太复杂了，我掌握很吃力，而且有些语法根本就是坑，基础设施STL也是非常复杂。写项目的话，我连相应的流程，工具，环境都不了解。\n\n现在已经周六了，大概就写到这里了，其实我也是编写边梳理自己的思路。\n写出来呢，可以经常看，这样自己就不会忘记对自己的严格要求了。每次面对电脑，2小时也不做点有意义的事情的时候，你就会觉得自己真是非常没用，那句话怎么说来着：回首过去，尽是些可耻往事。\n\n大概不论爱好什么，最简单证明自己的热情，是不留余力地享受自己的爱好吧","source":"_posts/关于未来方向学习的思考.md","raw":"---\ntitle: 关于未来方向学习的思考\ndate: 2017-08-11 23:43:14\ntags: summary\ncategory: life\n---\n# 总结现状\n\n## 如今\n\n今天是周五，等会就周六了。虽然平时经常忙活在电脑前，但好像没在做什么特别有意义的事情，看到github一个好项目就想着去看它的源码，然后呢，迫于水平不够，一堆工具也掌握的不利索，怎么也没法开始学。其实大概是自己内心不知道以后到底想去做什么吧。其实2，3w行的代码如果搞懂它的流程，而且又熟悉相关语言并懂得一些相关方向的知识，应该是可以开始看了，起码不应该想到看就害怕而退缩，这连第一步都没有走呢。\n\n## 想法\n\n比较坚定的想法呢是以后做编译相关工作，这个工作岗位很少，要求也很高，许多大神高中就开始接触了。我呢，现在还半吊子，最近才开始理解了最基本的知识，将来如果要考研，这应该是计算机体系结构这个方向的研究生吧。而这2个月一直在学机器学习，但我只是对它的原理好奇，又想着机器学习方向能跟数学打交道，又能锻炼算法能力，便很欣然地参加了这次暑假集训。最近这个月有些忙坏了，但又觉得自己学到知识很少，可能是太贪心了吧，自己对计算机许多方向都感兴趣，但未曾深入其中一个。我还经常跟同学说那句话：不要总想着以后要干嘛，你现在在干嘛，以后很可能就在干嘛，所以要干嘛就赶紧现在就开始干。其实我自己也没有做到我所说，虽然我非常希望自己能做到。\n\n<!-- more -->\n\n## 兴趣\n\n最近查阅了一些资料，其实都是自己以前都看过，只是很多不少都忘记了或者没有重视起来。记得大一时候对C++兴趣特别浓厚，买了C++primer和STL源码剖析，还很认真看过（但没怎么敲代码），后来接触了的其他编程语言，C++也基本没有使用过了。现在要是还记得大一C++要求的内容就不错咯。\n\n但我知识，我想以后从事的方向很可能离不开C++（至少10年是这样）。不论是机器学习或者是编译原理，还是网络编程，在高性能的场合，永远需要它。\n\n目前我比较感兴趣的是编译原理，机器学习，网络编程吧。\n这三个都可以学很深，无底洞。编译原理简单的话，写个编译器前端，嗯，可能还不如自动化工具强，学的深入了，就得学后端了，代码优化，无底洞，国内好像没几家公司需要这种人才（大概更不需要应届生吧）。不过作为“永不失业的职业”，我对编译原理里面的设计成分更感兴趣，即自制语言。而如果作为一个应用开发者的话，约束应该大很多了，很多时候公式让你做的跟你的兴趣点完全无关，再考虑国内公司的尿性，不让你干缺德的就不错了。\n\n扯远了，关于“设计”这种概念，对于机器学习跟网络编程，也同样适用吧。机器学习重在解决问题，而设计算法是重要环节，这里设计部分可能要发挥脑力，而不是跟风地调用算法，我觉得这里也是很有意思的部分，但如果是解决商业问题，或者做项目的话，自由度感觉不大，倒是留在实验室研究什么的更有意思（虽然最近就是留实验室学习，有点小枯燥）。而网络编程，重点是在网络层以上的开发，打交道是传输层跟应用层，设计协议是很有意思的一环。怎么样的协议更有语义，更高效，更安全，扩展性强，我觉得这部分自制性很强，也是很有研究的感觉。\n\n隐隐约约觉得以上三个方向深入研究最后都要跟并发或性能打交道。毫无疑问，编译原理，优化部分，可能需要把代码隐式转换为并发代码，或者编译成适合并发的机器代码。机器学习虽然是高阶算法，但依托于大数据平台，而底层需要高并发，分布式的架构。有时候算法策略本身可能需要考虑容易并发，而如果设计一个机器学习平台或者系统，底层模型肯定到处是并发，也明显需要分布式。网络编程呢，则是为了更好的进行数据交换，也是并发的策略之一，更是分布式计算的基石。\n\n以上三个方向，在底层方面最需要的便是C++了。众所周知C++是比较难掌握的，虽然现在情况在变好，但我其实还蛮担心自己毕业前连基本的STL都用不好。\n\n## 基本规划\n\n好像写了这么多，还是不清楚接下来应该如何去学习知识，在这最后的2年时间。其实下个学期课挺多的，而且都是比较难的课，虽然大部分我都挺感兴趣的，但精力一旦不足，我容易对计算机感到一种疲惫，然后几天不碰。而下个学期如此多的课的情况，在学好课内之余如何把课外感兴趣的知识补上呢（C++，机器学习，网络编程深入学习）。可能就只能在周末多抽出时间学习了吧。\n算上准备考研，也该多用用C++了，这样数据结构也算复习了。而下学期部分课需要一些数学知识，正好稍微注重一下复习数学，也算事半功倍了。网络编程这部分，即使只是简单地学习，对计算机网络这门课帮助也不少啊，感觉咬咬牙，下学期真的能学到很多知识吧，只希望自己不要自暴自弃，要善于总结学到的知识。\n\n如此一想，感觉也想通了一些，毕竟学习编译原理，计算机网络，操作系统的时候是完全可以用C++来实现相应的功能的，这也锻炼了我C++的水平，但可能目前完全达不到吧，所以打算暑假稍微学习一下C++。\n\n嗯，决定了，暑假还剩一个月，我打算学习以下内容：\n\n* 机器学习跟深度学习，这部分跟实验室进度来，尽量不落下吧\n* C++，看些简单的源码，学习一下STL，把忘记的捡起来\n* 简单的编译原理学习，实现几个简单的玩具编译器（已经跟着博客抄了一个，感觉还需要再写一个），如果可能的话，用C++来实现\n* 网络编程，这一块，估计很麻烦，我基本没有实战过，倒是有基本的理论知识，理想情况下应该是golang或者nodejs来写（它们封装的很好，写起来难度容易接受），C++写的话，估计写一个月也写不出什么。所以尽量暑假尝试写个简单协议（突然想起来之前写redgo，有机会完善下）\n\n其实对C++一向是又爱又恨，爱是觉得这门语言太重要了，感觉如果掌握，用其他语言也就游刃有余了，而且有些语法感觉真的很厉害。恨是觉得这门语言太复杂了，我掌握很吃力，而且有些语法根本就是坑，基础设施STL也是非常复杂。写项目的话，我连相应的流程，工具，环境都不了解。\n\n现在已经周六了，大概就写到这里了，其实我也是编写边梳理自己的思路。\n写出来呢，可以经常看，这样自己就不会忘记对自己的严格要求了。每次面对电脑，2小时也不做点有意义的事情的时候，你就会觉得自己真是非常没用，那句话怎么说来着：回首过去，尽是些可耻往事。\n\n大概不论爱好什么，最简单证明自己的热情，是不留余力地享受自己的爱好吧","slug":"关于未来方向学习的思考","published":1,"updated":"2017-09-24T11:34:24.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y8l000o6svsuyyw85z5","content":"<h1 id=\"总结现状\"><a href=\"#总结现状\" class=\"headerlink\" title=\"总结现状\"></a>总结现状</h1><h2 id=\"如今\"><a href=\"#如今\" class=\"headerlink\" title=\"如今\"></a>如今</h2><p>今天是周五，等会就周六了。虽然平时经常忙活在电脑前，但好像没在做什么特别有意义的事情，看到github一个好项目就想着去看它的源码，然后呢，迫于水平不够，一堆工具也掌握的不利索，怎么也没法开始学。其实大概是自己内心不知道以后到底想去做什么吧。其实2，3w行的代码如果搞懂它的流程，而且又熟悉相关语言并懂得一些相关方向的知识，应该是可以开始看了，起码不应该想到看就害怕而退缩，这连第一步都没有走呢。</p>\n<h2 id=\"想法\"><a href=\"#想法\" class=\"headerlink\" title=\"想法\"></a>想法</h2><p>比较坚定的想法呢是以后做编译相关工作，这个工作岗位很少，要求也很高，许多大神高中就开始接触了。我呢，现在还半吊子，最近才开始理解了最基本的知识，将来如果要考研，这应该是计算机体系结构这个方向的研究生吧。而这2个月一直在学机器学习，但我只是对它的原理好奇，又想着机器学习方向能跟数学打交道，又能锻炼算法能力，便很欣然地参加了这次暑假集训。最近这个月有些忙坏了，但又觉得自己学到知识很少，可能是太贪心了吧，自己对计算机许多方向都感兴趣，但未曾深入其中一个。我还经常跟同学说那句话：不要总想着以后要干嘛，你现在在干嘛，以后很可能就在干嘛，所以要干嘛就赶紧现在就开始干。其实我自己也没有做到我所说，虽然我非常希望自己能做到。</p>\n<a id=\"more\"></a>\n<h2 id=\"兴趣\"><a href=\"#兴趣\" class=\"headerlink\" title=\"兴趣\"></a>兴趣</h2><p>最近查阅了一些资料，其实都是自己以前都看过，只是很多不少都忘记了或者没有重视起来。记得大一时候对C++兴趣特别浓厚，买了C++primer和STL源码剖析，还很认真看过（但没怎么敲代码），后来接触了的其他编程语言，C++也基本没有使用过了。现在要是还记得大一C++要求的内容就不错咯。</p>\n<p>但我知识，我想以后从事的方向很可能离不开C++（至少10年是这样）。不论是机器学习或者是编译原理，还是网络编程，在高性能的场合，永远需要它。</p>\n<p>目前我比较感兴趣的是编译原理，机器学习，网络编程吧。<br>这三个都可以学很深，无底洞。编译原理简单的话，写个编译器前端，嗯，可能还不如自动化工具强，学的深入了，就得学后端了，代码优化，无底洞，国内好像没几家公司需要这种人才（大概更不需要应届生吧）。不过作为“永不失业的职业”，我对编译原理里面的设计成分更感兴趣，即自制语言。而如果作为一个应用开发者的话，约束应该大很多了，很多时候公式让你做的跟你的兴趣点完全无关，再考虑国内公司的尿性，不让你干缺德的就不错了。</p>\n<p>扯远了，关于“设计”这种概念，对于机器学习跟网络编程，也同样适用吧。机器学习重在解决问题，而设计算法是重要环节，这里设计部分可能要发挥脑力，而不是跟风地调用算法，我觉得这里也是很有意思的部分，但如果是解决商业问题，或者做项目的话，自由度感觉不大，倒是留在实验室研究什么的更有意思（虽然最近就是留实验室学习，有点小枯燥）。而网络编程，重点是在网络层以上的开发，打交道是传输层跟应用层，设计协议是很有意思的一环。怎么样的协议更有语义，更高效，更安全，扩展性强，我觉得这部分自制性很强，也是很有研究的感觉。</p>\n<p>隐隐约约觉得以上三个方向深入研究最后都要跟并发或性能打交道。毫无疑问，编译原理，优化部分，可能需要把代码隐式转换为并发代码，或者编译成适合并发的机器代码。机器学习虽然是高阶算法，但依托于大数据平台，而底层需要高并发，分布式的架构。有时候算法策略本身可能需要考虑容易并发，而如果设计一个机器学习平台或者系统，底层模型肯定到处是并发，也明显需要分布式。网络编程呢，则是为了更好的进行数据交换，也是并发的策略之一，更是分布式计算的基石。</p>\n<p>以上三个方向，在底层方面最需要的便是C++了。众所周知C++是比较难掌握的，虽然现在情况在变好，但我其实还蛮担心自己毕业前连基本的STL都用不好。</p>\n<h2 id=\"基本规划\"><a href=\"#基本规划\" class=\"headerlink\" title=\"基本规划\"></a>基本规划</h2><p>好像写了这么多，还是不清楚接下来应该如何去学习知识，在这最后的2年时间。其实下个学期课挺多的，而且都是比较难的课，虽然大部分我都挺感兴趣的，但精力一旦不足，我容易对计算机感到一种疲惫，然后几天不碰。而下个学期如此多的课的情况，在学好课内之余如何把课外感兴趣的知识补上呢（C++，机器学习，网络编程深入学习）。可能就只能在周末多抽出时间学习了吧。<br>算上准备考研，也该多用用C++了，这样数据结构也算复习了。而下学期部分课需要一些数学知识，正好稍微注重一下复习数学，也算事半功倍了。网络编程这部分，即使只是简单地学习，对计算机网络这门课帮助也不少啊，感觉咬咬牙，下学期真的能学到很多知识吧，只希望自己不要自暴自弃，要善于总结学到的知识。</p>\n<p>如此一想，感觉也想通了一些，毕竟学习编译原理，计算机网络，操作系统的时候是完全可以用C++来实现相应的功能的，这也锻炼了我C++的水平，但可能目前完全达不到吧，所以打算暑假稍微学习一下C++。</p>\n<p>嗯，决定了，暑假还剩一个月，我打算学习以下内容：</p>\n<ul>\n<li>机器学习跟深度学习，这部分跟实验室进度来，尽量不落下吧</li>\n<li>C++，看些简单的源码，学习一下STL，把忘记的捡起来</li>\n<li>简单的编译原理学习，实现几个简单的玩具编译器（已经跟着博客抄了一个，感觉还需要再写一个），如果可能的话，用C++来实现</li>\n<li>网络编程，这一块，估计很麻烦，我基本没有实战过，倒是有基本的理论知识，理想情况下应该是golang或者nodejs来写（它们封装的很好，写起来难度容易接受），C++写的话，估计写一个月也写不出什么。所以尽量暑假尝试写个简单协议（突然想起来之前写redgo，有机会完善下）</li>\n</ul>\n<p>其实对C++一向是又爱又恨，爱是觉得这门语言太重要了，感觉如果掌握，用其他语言也就游刃有余了，而且有些语法感觉真的很厉害。恨是觉得这门语言太复杂了，我掌握很吃力，而且有些语法根本就是坑，基础设施STL也是非常复杂。写项目的话，我连相应的流程，工具，环境都不了解。</p>\n<p>现在已经周六了，大概就写到这里了，其实我也是编写边梳理自己的思路。<br>写出来呢，可以经常看，这样自己就不会忘记对自己的严格要求了。每次面对电脑，2小时也不做点有意义的事情的时候，你就会觉得自己真是非常没用，那句话怎么说来着：回首过去，尽是些可耻往事。</p>\n<p>大概不论爱好什么，最简单证明自己的热情，是不留余力地享受自己的爱好吧</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"总结现状\"><a href=\"#总结现状\" class=\"headerlink\" title=\"总结现状\"></a>总结现状</h1><h2 id=\"如今\"><a href=\"#如今\" class=\"headerlink\" title=\"如今\"></a>如今</h2><p>今天是周五，等会就周六了。虽然平时经常忙活在电脑前，但好像没在做什么特别有意义的事情，看到github一个好项目就想着去看它的源码，然后呢，迫于水平不够，一堆工具也掌握的不利索，怎么也没法开始学。其实大概是自己内心不知道以后到底想去做什么吧。其实2，3w行的代码如果搞懂它的流程，而且又熟悉相关语言并懂得一些相关方向的知识，应该是可以开始看了，起码不应该想到看就害怕而退缩，这连第一步都没有走呢。</p>\n<h2 id=\"想法\"><a href=\"#想法\" class=\"headerlink\" title=\"想法\"></a>想法</h2><p>比较坚定的想法呢是以后做编译相关工作，这个工作岗位很少，要求也很高，许多大神高中就开始接触了。我呢，现在还半吊子，最近才开始理解了最基本的知识，将来如果要考研，这应该是计算机体系结构这个方向的研究生吧。而这2个月一直在学机器学习，但我只是对它的原理好奇，又想着机器学习方向能跟数学打交道，又能锻炼算法能力，便很欣然地参加了这次暑假集训。最近这个月有些忙坏了，但又觉得自己学到知识很少，可能是太贪心了吧，自己对计算机许多方向都感兴趣，但未曾深入其中一个。我还经常跟同学说那句话：不要总想着以后要干嘛，你现在在干嘛，以后很可能就在干嘛，所以要干嘛就赶紧现在就开始干。其实我自己也没有做到我所说，虽然我非常希望自己能做到。</p>","more":"<h2 id=\"兴趣\"><a href=\"#兴趣\" class=\"headerlink\" title=\"兴趣\"></a>兴趣</h2><p>最近查阅了一些资料，其实都是自己以前都看过，只是很多不少都忘记了或者没有重视起来。记得大一时候对C++兴趣特别浓厚，买了C++primer和STL源码剖析，还很认真看过（但没怎么敲代码），后来接触了的其他编程语言，C++也基本没有使用过了。现在要是还记得大一C++要求的内容就不错咯。</p>\n<p>但我知识，我想以后从事的方向很可能离不开C++（至少10年是这样）。不论是机器学习或者是编译原理，还是网络编程，在高性能的场合，永远需要它。</p>\n<p>目前我比较感兴趣的是编译原理，机器学习，网络编程吧。<br>这三个都可以学很深，无底洞。编译原理简单的话，写个编译器前端，嗯，可能还不如自动化工具强，学的深入了，就得学后端了，代码优化，无底洞，国内好像没几家公司需要这种人才（大概更不需要应届生吧）。不过作为“永不失业的职业”，我对编译原理里面的设计成分更感兴趣，即自制语言。而如果作为一个应用开发者的话，约束应该大很多了，很多时候公式让你做的跟你的兴趣点完全无关，再考虑国内公司的尿性，不让你干缺德的就不错了。</p>\n<p>扯远了，关于“设计”这种概念，对于机器学习跟网络编程，也同样适用吧。机器学习重在解决问题，而设计算法是重要环节，这里设计部分可能要发挥脑力，而不是跟风地调用算法，我觉得这里也是很有意思的部分，但如果是解决商业问题，或者做项目的话，自由度感觉不大，倒是留在实验室研究什么的更有意思（虽然最近就是留实验室学习，有点小枯燥）。而网络编程，重点是在网络层以上的开发，打交道是传输层跟应用层，设计协议是很有意思的一环。怎么样的协议更有语义，更高效，更安全，扩展性强，我觉得这部分自制性很强，也是很有研究的感觉。</p>\n<p>隐隐约约觉得以上三个方向深入研究最后都要跟并发或性能打交道。毫无疑问，编译原理，优化部分，可能需要把代码隐式转换为并发代码，或者编译成适合并发的机器代码。机器学习虽然是高阶算法，但依托于大数据平台，而底层需要高并发，分布式的架构。有时候算法策略本身可能需要考虑容易并发，而如果设计一个机器学习平台或者系统，底层模型肯定到处是并发，也明显需要分布式。网络编程呢，则是为了更好的进行数据交换，也是并发的策略之一，更是分布式计算的基石。</p>\n<p>以上三个方向，在底层方面最需要的便是C++了。众所周知C++是比较难掌握的，虽然现在情况在变好，但我其实还蛮担心自己毕业前连基本的STL都用不好。</p>\n<h2 id=\"基本规划\"><a href=\"#基本规划\" class=\"headerlink\" title=\"基本规划\"></a>基本规划</h2><p>好像写了这么多，还是不清楚接下来应该如何去学习知识，在这最后的2年时间。其实下个学期课挺多的，而且都是比较难的课，虽然大部分我都挺感兴趣的，但精力一旦不足，我容易对计算机感到一种疲惫，然后几天不碰。而下个学期如此多的课的情况，在学好课内之余如何把课外感兴趣的知识补上呢（C++，机器学习，网络编程深入学习）。可能就只能在周末多抽出时间学习了吧。<br>算上准备考研，也该多用用C++了，这样数据结构也算复习了。而下学期部分课需要一些数学知识，正好稍微注重一下复习数学，也算事半功倍了。网络编程这部分，即使只是简单地学习，对计算机网络这门课帮助也不少啊，感觉咬咬牙，下学期真的能学到很多知识吧，只希望自己不要自暴自弃，要善于总结学到的知识。</p>\n<p>如此一想，感觉也想通了一些，毕竟学习编译原理，计算机网络，操作系统的时候是完全可以用C++来实现相应的功能的，这也锻炼了我C++的水平，但可能目前完全达不到吧，所以打算暑假稍微学习一下C++。</p>\n<p>嗯，决定了，暑假还剩一个月，我打算学习以下内容：</p>\n<ul>\n<li>机器学习跟深度学习，这部分跟实验室进度来，尽量不落下吧</li>\n<li>C++，看些简单的源码，学习一下STL，把忘记的捡起来</li>\n<li>简单的编译原理学习，实现几个简单的玩具编译器（已经跟着博客抄了一个，感觉还需要再写一个），如果可能的话，用C++来实现</li>\n<li>网络编程，这一块，估计很麻烦，我基本没有实战过，倒是有基本的理论知识，理想情况下应该是golang或者nodejs来写（它们封装的很好，写起来难度容易接受），C++写的话，估计写一个月也写不出什么。所以尽量暑假尝试写个简单协议（突然想起来之前写redgo，有机会完善下）</li>\n</ul>\n<p>其实对C++一向是又爱又恨，爱是觉得这门语言太重要了，感觉如果掌握，用其他语言也就游刃有余了，而且有些语法感觉真的很厉害。恨是觉得这门语言太复杂了，我掌握很吃力，而且有些语法根本就是坑，基础设施STL也是非常复杂。写项目的话，我连相应的流程，工具，环境都不了解。</p>\n<p>现在已经周六了，大概就写到这里了，其实我也是编写边梳理自己的思路。<br>写出来呢，可以经常看，这样自己就不会忘记对自己的严格要求了。每次面对电脑，2小时也不做点有意义的事情的时候，你就会觉得自己真是非常没用，那句话怎么说来着：回首过去，尽是些可耻往事。</p>\n<p>大概不论爱好什么，最简单证明自己的热情，是不留余力地享受自己的爱好吧</p>"},{"title":"人工智能发展报告","date":"2017-09-24T11:29:28.000Z","_content":"# 人工智能的发展\n\n数据挖掘课程的作业报告，放在这里分享一下，都是一些蠢话。\n<!-- more -->\n\n## 符号主义（逻辑主义）\n\n### 推理期\n\n二十世纪五十年代到七十年代初，人工智能的研究处于“推理期”，那时候人们普遍认为机器获得智能的方法是赋予机器逻辑推理的能力。该阶段比较有代表的工作比如在1955年12月，赫伯特·西蒙（Herbert Simon）和艾伦·纽厄尔（Allen Newell）开发出`逻辑理论家`，这是世界上第一个人工智能程序，有能力证明罗素和怀特海《数学原理》第二章52个定理中的38个定理，\n甚至在后来证明了全部52个定理。这两位也因此在1975年获得了图灵奖。\n\n### 知识期\n\n随着后来的研究进展，人们意识到仅仅具有逻辑推理能力是远远无法实现人工智能的。从二十世纪七十年代中期开始，人工智能的研究进入`知识期`。专家系统被大量开发出来，E.A. Feigenbaum 作为“`知识工程`”之父在1994年获得图灵奖。不过后来人们又意识到专家系统的“知识工程瓶颈”，把人类总结的知识教授给计算机是相当困难的。\n\n## 机器学习\n\n八十年代左右，“`从样例中学习`”的一大主流还是符号主义的思想，其代表如决策树（Decision tree）和基于逻辑的学习。决策树以信息论为基础，而基于逻辑的学习是归纳逻辑程序设计，可看作是机器学习与逻辑程序设计的交叉。\n\n### 神经网络（联结主义）\n\n九十年代中期之前，“从样例中学习”的另一个主流是基于神经网络的联结主义。1986年，D.E. Rumelhart 等人重新发明了BP算法，产生了深远影响，如今的深度学习最基本的概念便是BP算法。不过联结主义产生的是“`黑箱`”模型，从知识获取角度看有明显的弱点。然而，由于BP算法，深度学习算法在实际中非常有用，在2006年开始第三次神经网络高潮以深度学习之名重新爆发而来，在2012年之后成为人工智能的主流算法。当然，在九十年代统计学习兴起时，而又因为当时的局限性，曾经落入低潮。\n\n### 统计学习\n\n九十年代中期，“`统计学习`”迅速兴起并成为主流，如今依然是主流的机器学习算法，典型代表是SVM。早在九十年代之前，统计学习的许多基础理论已经出现，但因为联结主义的神经网络在九十年代具有局限性而没落后，统计学习被人瞄准目光而迅速流行起来。\n\n## 谈谈自己的理解\n\n前面的一些概括是我认为比较重要的历史的整理。如今看来，人工智能的历史虽然不漫长，却可以说的上丰富与多变。现如今，从学术、商业、工业角度来审视的人工智能，占据主流的是传统机器学习跟深度学习，然后才是强化学习跟规则学习（个人看法）。当然，如今的机器学习算法或多或少都用上了概率统计的知识。\n\n深度学习如今越来越火热，在我自己开始留意机器学习的内容开始，深度学习相关的文章跟新闻就狂轰滥炸地映入我的眼里，以至于我没法不正视它。后来我也简单的接触深度学习，才发现它确实不可思议。在训练深度学习时，它就是在特征空间里不断逼近然后拟合到数据特征的“万能函数”，怪不得说它是`万能近似图灵机`。把它应用到许多领域感觉也就不奇怪了，当然它不一定比传统的机器学习和其他人工智能算法要更有效。\n\n不过可能是因为深度学习的`万用性`导致它的`黑箱性`，大部分人在使用它来解决问题的时候，没有获得很好的解释，无论是从深度学习结构模型的理论角度还是问题本身特性的角度。只是在设计网络架构时，粗略地分析问题的特性，然后改良别人成功的架构跟“合理”的解释来解决问题。在问题较满意的解决后，没有合理的可解释性或者干脆从他人理解的来解释。\n\n当然，从实用性跟工作角度来说，我觉得这样没错。深度学习跟你的剪刀和锤子一样，只是解决问题跟生产的工具，并不需要在意内部机理。这样的比喻来解释可能非常不妥当，不过我想表达的是，如今主流的人工智能方法：深度学习，虽然在构造时有比较好的理论基础，但在优化模型，优化架构，并且在解释优化可能性与优化思路上，缺乏理论。（对深度学习接触才几周，造成这样可能有偏差的认知，如有错误，欢迎指出）\n\n相比于深度学习，传统偏向于统计的机器学习，可解释性就比较强了，而且在很多时候，从各种角度上与深度学习比较，丝毫不逊色。而且现实的问题非常复杂，蕴含大量不确定跟随机的事件，而概率论与数理统计就是对现实世界建立这样的一些模型跟假设，这方面的理论也算比较完善了，所以传统机器学习更能在数学理论上解释一些模型的行为。\n\n而最近神经网络之父 Geoffrey Hinton 也表明对`BP`非常怀疑，应该抛弃它。BP如今是深度学习最常用的算法了，如果丢弃它，深度学习大概会大变样吧。如此看来，深度学习没有那么“完美”，仍需要大量基础研究甚至真的可能在未来被更好的算法替代。\n\n## 展望未来的人工智能\n\n如果想到三十年以后，大街小巷到处有序而不拥挤地行驶着无人车，载着乘客去景点；天空上时不时飞过一架架无人机，拍摄城市风景与监控城市安全；新闻报道是程序根据许多视频、图片。文本而撰写的；家里布满了传感器跟智能家具，许多繁琐事情可以通过简单对话跟指令来处理。\n想到如果真能如此，不由对如今的人工智能算法寄予厚望并抱有乐观的想法。\n\n但在我看来，上面的美好描述可能还是过于乐观了。\n\n之前曾在哪里看到一个观点，20年后人工智能将会代替80%的工作。我觉得这个也太乐观了。当今现实生活中，从事脑力活动的人已经多余从事体力活动的人了，未来这个趋势应该更加明显。而以目前人工智能的能力，很多脑力活动不能代替（或者说，实现这些能代替脑力活动的程序需要更多脑力的脑力活动）。若人工智能的算法更加成熟稳定，许多人应该会从事人工智能相关的工作，建设基础设施（其实现在就有很多人往机器学习这个方向转业），普及人工智能，而只有少部分人推动人工智能的发展。\n\n其实我一直不敢想像未来，这对于我太难了。十年前我对未来的展望似乎跟如今的现实大相径庭了。自己觉得可能出现的东西往往没有到来，反而出现一些超出以前认知的意外事物。说不定，以后深度学习也不再是实现人工智能的主力了，出现一些特定算法可以实现以前难以实现的智能，但却无法较好完成如今研究的方向。最坏的情况就是深度学习仍然是主流，而其理论仍然不明朗，调参也没有完备的方法论，人工智能发展停滞了几十年，直到我们这一代人死去，这后面的事情我也不想展望了。","source":"_posts/人工智能发展报告.md","raw":"---\ntitle: 人工智能发展报告\ndate: 2017-09-24 19:29:28\ntags: ML\ncategory: study\n---\n# 人工智能的发展\n\n数据挖掘课程的作业报告，放在这里分享一下，都是一些蠢话。\n<!-- more -->\n\n## 符号主义（逻辑主义）\n\n### 推理期\n\n二十世纪五十年代到七十年代初，人工智能的研究处于“推理期”，那时候人们普遍认为机器获得智能的方法是赋予机器逻辑推理的能力。该阶段比较有代表的工作比如在1955年12月，赫伯特·西蒙（Herbert Simon）和艾伦·纽厄尔（Allen Newell）开发出`逻辑理论家`，这是世界上第一个人工智能程序，有能力证明罗素和怀特海《数学原理》第二章52个定理中的38个定理，\n甚至在后来证明了全部52个定理。这两位也因此在1975年获得了图灵奖。\n\n### 知识期\n\n随着后来的研究进展，人们意识到仅仅具有逻辑推理能力是远远无法实现人工智能的。从二十世纪七十年代中期开始，人工智能的研究进入`知识期`。专家系统被大量开发出来，E.A. Feigenbaum 作为“`知识工程`”之父在1994年获得图灵奖。不过后来人们又意识到专家系统的“知识工程瓶颈”，把人类总结的知识教授给计算机是相当困难的。\n\n## 机器学习\n\n八十年代左右，“`从样例中学习`”的一大主流还是符号主义的思想，其代表如决策树（Decision tree）和基于逻辑的学习。决策树以信息论为基础，而基于逻辑的学习是归纳逻辑程序设计，可看作是机器学习与逻辑程序设计的交叉。\n\n### 神经网络（联结主义）\n\n九十年代中期之前，“从样例中学习”的另一个主流是基于神经网络的联结主义。1986年，D.E. Rumelhart 等人重新发明了BP算法，产生了深远影响，如今的深度学习最基本的概念便是BP算法。不过联结主义产生的是“`黑箱`”模型，从知识获取角度看有明显的弱点。然而，由于BP算法，深度学习算法在实际中非常有用，在2006年开始第三次神经网络高潮以深度学习之名重新爆发而来，在2012年之后成为人工智能的主流算法。当然，在九十年代统计学习兴起时，而又因为当时的局限性，曾经落入低潮。\n\n### 统计学习\n\n九十年代中期，“`统计学习`”迅速兴起并成为主流，如今依然是主流的机器学习算法，典型代表是SVM。早在九十年代之前，统计学习的许多基础理论已经出现，但因为联结主义的神经网络在九十年代具有局限性而没落后，统计学习被人瞄准目光而迅速流行起来。\n\n## 谈谈自己的理解\n\n前面的一些概括是我认为比较重要的历史的整理。如今看来，人工智能的历史虽然不漫长，却可以说的上丰富与多变。现如今，从学术、商业、工业角度来审视的人工智能，占据主流的是传统机器学习跟深度学习，然后才是强化学习跟规则学习（个人看法）。当然，如今的机器学习算法或多或少都用上了概率统计的知识。\n\n深度学习如今越来越火热，在我自己开始留意机器学习的内容开始，深度学习相关的文章跟新闻就狂轰滥炸地映入我的眼里，以至于我没法不正视它。后来我也简单的接触深度学习，才发现它确实不可思议。在训练深度学习时，它就是在特征空间里不断逼近然后拟合到数据特征的“万能函数”，怪不得说它是`万能近似图灵机`。把它应用到许多领域感觉也就不奇怪了，当然它不一定比传统的机器学习和其他人工智能算法要更有效。\n\n不过可能是因为深度学习的`万用性`导致它的`黑箱性`，大部分人在使用它来解决问题的时候，没有获得很好的解释，无论是从深度学习结构模型的理论角度还是问题本身特性的角度。只是在设计网络架构时，粗略地分析问题的特性，然后改良别人成功的架构跟“合理”的解释来解决问题。在问题较满意的解决后，没有合理的可解释性或者干脆从他人理解的来解释。\n\n当然，从实用性跟工作角度来说，我觉得这样没错。深度学习跟你的剪刀和锤子一样，只是解决问题跟生产的工具，并不需要在意内部机理。这样的比喻来解释可能非常不妥当，不过我想表达的是，如今主流的人工智能方法：深度学习，虽然在构造时有比较好的理论基础，但在优化模型，优化架构，并且在解释优化可能性与优化思路上，缺乏理论。（对深度学习接触才几周，造成这样可能有偏差的认知，如有错误，欢迎指出）\n\n相比于深度学习，传统偏向于统计的机器学习，可解释性就比较强了，而且在很多时候，从各种角度上与深度学习比较，丝毫不逊色。而且现实的问题非常复杂，蕴含大量不确定跟随机的事件，而概率论与数理统计就是对现实世界建立这样的一些模型跟假设，这方面的理论也算比较完善了，所以传统机器学习更能在数学理论上解释一些模型的行为。\n\n而最近神经网络之父 Geoffrey Hinton 也表明对`BP`非常怀疑，应该抛弃它。BP如今是深度学习最常用的算法了，如果丢弃它，深度学习大概会大变样吧。如此看来，深度学习没有那么“完美”，仍需要大量基础研究甚至真的可能在未来被更好的算法替代。\n\n## 展望未来的人工智能\n\n如果想到三十年以后，大街小巷到处有序而不拥挤地行驶着无人车，载着乘客去景点；天空上时不时飞过一架架无人机，拍摄城市风景与监控城市安全；新闻报道是程序根据许多视频、图片。文本而撰写的；家里布满了传感器跟智能家具，许多繁琐事情可以通过简单对话跟指令来处理。\n想到如果真能如此，不由对如今的人工智能算法寄予厚望并抱有乐观的想法。\n\n但在我看来，上面的美好描述可能还是过于乐观了。\n\n之前曾在哪里看到一个观点，20年后人工智能将会代替80%的工作。我觉得这个也太乐观了。当今现实生活中，从事脑力活动的人已经多余从事体力活动的人了，未来这个趋势应该更加明显。而以目前人工智能的能力，很多脑力活动不能代替（或者说，实现这些能代替脑力活动的程序需要更多脑力的脑力活动）。若人工智能的算法更加成熟稳定，许多人应该会从事人工智能相关的工作，建设基础设施（其实现在就有很多人往机器学习这个方向转业），普及人工智能，而只有少部分人推动人工智能的发展。\n\n其实我一直不敢想像未来，这对于我太难了。十年前我对未来的展望似乎跟如今的现实大相径庭了。自己觉得可能出现的东西往往没有到来，反而出现一些超出以前认知的意外事物。说不定，以后深度学习也不再是实现人工智能的主力了，出现一些特定算法可以实现以前难以实现的智能，但却无法较好完成如今研究的方向。最坏的情况就是深度学习仍然是主流，而其理论仍然不明朗，调参也没有完备的方法论，人工智能发展停滞了几十年，直到我们这一代人死去，这后面的事情我也不想展望了。","slug":"人工智能发展报告","published":1,"updated":"2017-09-24T11:33:42.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y8t000q6svsen6k00zo","content":"<h1 id=\"人工智能的发展\"><a href=\"#人工智能的发展\" class=\"headerlink\" title=\"人工智能的发展\"></a>人工智能的发展</h1><p>数据挖掘课程的作业报告，放在这里分享一下，都是一些蠢话。<br><a id=\"more\"></a></p>\n<h2 id=\"符号主义（逻辑主义）\"><a href=\"#符号主义（逻辑主义）\" class=\"headerlink\" title=\"符号主义（逻辑主义）\"></a>符号主义（逻辑主义）</h2><h3 id=\"推理期\"><a href=\"#推理期\" class=\"headerlink\" title=\"推理期\"></a>推理期</h3><p>二十世纪五十年代到七十年代初，人工智能的研究处于“推理期”，那时候人们普遍认为机器获得智能的方法是赋予机器逻辑推理的能力。该阶段比较有代表的工作比如在1955年12月，赫伯特·西蒙（Herbert Simon）和艾伦·纽厄尔（Allen Newell）开发出<code>逻辑理论家</code>，这是世界上第一个人工智能程序，有能力证明罗素和怀特海《数学原理》第二章52个定理中的38个定理，<br>甚至在后来证明了全部52个定理。这两位也因此在1975年获得了图灵奖。</p>\n<h3 id=\"知识期\"><a href=\"#知识期\" class=\"headerlink\" title=\"知识期\"></a>知识期</h3><p>随着后来的研究进展，人们意识到仅仅具有逻辑推理能力是远远无法实现人工智能的。从二十世纪七十年代中期开始，人工智能的研究进入<code>知识期</code>。专家系统被大量开发出来，E.A. Feigenbaum 作为“<code>知识工程</code>”之父在1994年获得图灵奖。不过后来人们又意识到专家系统的“知识工程瓶颈”，把人类总结的知识教授给计算机是相当困难的。</p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p>八十年代左右，“<code>从样例中学习</code>”的一大主流还是符号主义的思想，其代表如决策树（Decision tree）和基于逻辑的学习。决策树以信息论为基础，而基于逻辑的学习是归纳逻辑程序设计，可看作是机器学习与逻辑程序设计的交叉。</p>\n<h3 id=\"神经网络（联结主义）\"><a href=\"#神经网络（联结主义）\" class=\"headerlink\" title=\"神经网络（联结主义）\"></a>神经网络（联结主义）</h3><p>九十年代中期之前，“从样例中学习”的另一个主流是基于神经网络的联结主义。1986年，D.E. Rumelhart 等人重新发明了BP算法，产生了深远影响，如今的深度学习最基本的概念便是BP算法。不过联结主义产生的是“<code>黑箱</code>”模型，从知识获取角度看有明显的弱点。然而，由于BP算法，深度学习算法在实际中非常有用，在2006年开始第三次神经网络高潮以深度学习之名重新爆发而来，在2012年之后成为人工智能的主流算法。当然，在九十年代统计学习兴起时，而又因为当时的局限性，曾经落入低潮。</p>\n<h3 id=\"统计学习\"><a href=\"#统计学习\" class=\"headerlink\" title=\"统计学习\"></a>统计学习</h3><p>九十年代中期，“<code>统计学习</code>”迅速兴起并成为主流，如今依然是主流的机器学习算法，典型代表是SVM。早在九十年代之前，统计学习的许多基础理论已经出现，但因为联结主义的神经网络在九十年代具有局限性而没落后，统计学习被人瞄准目光而迅速流行起来。</p>\n<h2 id=\"谈谈自己的理解\"><a href=\"#谈谈自己的理解\" class=\"headerlink\" title=\"谈谈自己的理解\"></a>谈谈自己的理解</h2><p>前面的一些概括是我认为比较重要的历史的整理。如今看来，人工智能的历史虽然不漫长，却可以说的上丰富与多变。现如今，从学术、商业、工业角度来审视的人工智能，占据主流的是传统机器学习跟深度学习，然后才是强化学习跟规则学习（个人看法）。当然，如今的机器学习算法或多或少都用上了概率统计的知识。</p>\n<p>深度学习如今越来越火热，在我自己开始留意机器学习的内容开始，深度学习相关的文章跟新闻就狂轰滥炸地映入我的眼里，以至于我没法不正视它。后来我也简单的接触深度学习，才发现它确实不可思议。在训练深度学习时，它就是在特征空间里不断逼近然后拟合到数据特征的“万能函数”，怪不得说它是<code>万能近似图灵机</code>。把它应用到许多领域感觉也就不奇怪了，当然它不一定比传统的机器学习和其他人工智能算法要更有效。</p>\n<p>不过可能是因为深度学习的<code>万用性</code>导致它的<code>黑箱性</code>，大部分人在使用它来解决问题的时候，没有获得很好的解释，无论是从深度学习结构模型的理论角度还是问题本身特性的角度。只是在设计网络架构时，粗略地分析问题的特性，然后改良别人成功的架构跟“合理”的解释来解决问题。在问题较满意的解决后，没有合理的可解释性或者干脆从他人理解的来解释。</p>\n<p>当然，从实用性跟工作角度来说，我觉得这样没错。深度学习跟你的剪刀和锤子一样，只是解决问题跟生产的工具，并不需要在意内部机理。这样的比喻来解释可能非常不妥当，不过我想表达的是，如今主流的人工智能方法：深度学习，虽然在构造时有比较好的理论基础，但在优化模型，优化架构，并且在解释优化可能性与优化思路上，缺乏理论。（对深度学习接触才几周，造成这样可能有偏差的认知，如有错误，欢迎指出）</p>\n<p>相比于深度学习，传统偏向于统计的机器学习，可解释性就比较强了，而且在很多时候，从各种角度上与深度学习比较，丝毫不逊色。而且现实的问题非常复杂，蕴含大量不确定跟随机的事件，而概率论与数理统计就是对现实世界建立这样的一些模型跟假设，这方面的理论也算比较完善了，所以传统机器学习更能在数学理论上解释一些模型的行为。</p>\n<p>而最近神经网络之父 Geoffrey Hinton 也表明对<code>BP</code>非常怀疑，应该抛弃它。BP如今是深度学习最常用的算法了，如果丢弃它，深度学习大概会大变样吧。如此看来，深度学习没有那么“完美”，仍需要大量基础研究甚至真的可能在未来被更好的算法替代。</p>\n<h2 id=\"展望未来的人工智能\"><a href=\"#展望未来的人工智能\" class=\"headerlink\" title=\"展望未来的人工智能\"></a>展望未来的人工智能</h2><p>如果想到三十年以后，大街小巷到处有序而不拥挤地行驶着无人车，载着乘客去景点；天空上时不时飞过一架架无人机，拍摄城市风景与监控城市安全；新闻报道是程序根据许多视频、图片。文本而撰写的；家里布满了传感器跟智能家具，许多繁琐事情可以通过简单对话跟指令来处理。<br>想到如果真能如此，不由对如今的人工智能算法寄予厚望并抱有乐观的想法。</p>\n<p>但在我看来，上面的美好描述可能还是过于乐观了。</p>\n<p>之前曾在哪里看到一个观点，20年后人工智能将会代替80%的工作。我觉得这个也太乐观了。当今现实生活中，从事脑力活动的人已经多余从事体力活动的人了，未来这个趋势应该更加明显。而以目前人工智能的能力，很多脑力活动不能代替（或者说，实现这些能代替脑力活动的程序需要更多脑力的脑力活动）。若人工智能的算法更加成熟稳定，许多人应该会从事人工智能相关的工作，建设基础设施（其实现在就有很多人往机器学习这个方向转业），普及人工智能，而只有少部分人推动人工智能的发展。</p>\n<p>其实我一直不敢想像未来，这对于我太难了。十年前我对未来的展望似乎跟如今的现实大相径庭了。自己觉得可能出现的东西往往没有到来，反而出现一些超出以前认知的意外事物。说不定，以后深度学习也不再是实现人工智能的主力了，出现一些特定算法可以实现以前难以实现的智能，但却无法较好完成如今研究的方向。最坏的情况就是深度学习仍然是主流，而其理论仍然不明朗，调参也没有完备的方法论，人工智能发展停滞了几十年，直到我们这一代人死去，这后面的事情我也不想展望了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"人工智能的发展\"><a href=\"#人工智能的发展\" class=\"headerlink\" title=\"人工智能的发展\"></a>人工智能的发展</h1><p>数据挖掘课程的作业报告，放在这里分享一下，都是一些蠢话。<br>","more":"</p>\n<h2 id=\"符号主义（逻辑主义）\"><a href=\"#符号主义（逻辑主义）\" class=\"headerlink\" title=\"符号主义（逻辑主义）\"></a>符号主义（逻辑主义）</h2><h3 id=\"推理期\"><a href=\"#推理期\" class=\"headerlink\" title=\"推理期\"></a>推理期</h3><p>二十世纪五十年代到七十年代初，人工智能的研究处于“推理期”，那时候人们普遍认为机器获得智能的方法是赋予机器逻辑推理的能力。该阶段比较有代表的工作比如在1955年12月，赫伯特·西蒙（Herbert Simon）和艾伦·纽厄尔（Allen Newell）开发出<code>逻辑理论家</code>，这是世界上第一个人工智能程序，有能力证明罗素和怀特海《数学原理》第二章52个定理中的38个定理，<br>甚至在后来证明了全部52个定理。这两位也因此在1975年获得了图灵奖。</p>\n<h3 id=\"知识期\"><a href=\"#知识期\" class=\"headerlink\" title=\"知识期\"></a>知识期</h3><p>随着后来的研究进展，人们意识到仅仅具有逻辑推理能力是远远无法实现人工智能的。从二十世纪七十年代中期开始，人工智能的研究进入<code>知识期</code>。专家系统被大量开发出来，E.A. Feigenbaum 作为“<code>知识工程</code>”之父在1994年获得图灵奖。不过后来人们又意识到专家系统的“知识工程瓶颈”，把人类总结的知识教授给计算机是相当困难的。</p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p>八十年代左右，“<code>从样例中学习</code>”的一大主流还是符号主义的思想，其代表如决策树（Decision tree）和基于逻辑的学习。决策树以信息论为基础，而基于逻辑的学习是归纳逻辑程序设计，可看作是机器学习与逻辑程序设计的交叉。</p>\n<h3 id=\"神经网络（联结主义）\"><a href=\"#神经网络（联结主义）\" class=\"headerlink\" title=\"神经网络（联结主义）\"></a>神经网络（联结主义）</h3><p>九十年代中期之前，“从样例中学习”的另一个主流是基于神经网络的联结主义。1986年，D.E. Rumelhart 等人重新发明了BP算法，产生了深远影响，如今的深度学习最基本的概念便是BP算法。不过联结主义产生的是“<code>黑箱</code>”模型，从知识获取角度看有明显的弱点。然而，由于BP算法，深度学习算法在实际中非常有用，在2006年开始第三次神经网络高潮以深度学习之名重新爆发而来，在2012年之后成为人工智能的主流算法。当然，在九十年代统计学习兴起时，而又因为当时的局限性，曾经落入低潮。</p>\n<h3 id=\"统计学习\"><a href=\"#统计学习\" class=\"headerlink\" title=\"统计学习\"></a>统计学习</h3><p>九十年代中期，“<code>统计学习</code>”迅速兴起并成为主流，如今依然是主流的机器学习算法，典型代表是SVM。早在九十年代之前，统计学习的许多基础理论已经出现，但因为联结主义的神经网络在九十年代具有局限性而没落后，统计学习被人瞄准目光而迅速流行起来。</p>\n<h2 id=\"谈谈自己的理解\"><a href=\"#谈谈自己的理解\" class=\"headerlink\" title=\"谈谈自己的理解\"></a>谈谈自己的理解</h2><p>前面的一些概括是我认为比较重要的历史的整理。如今看来，人工智能的历史虽然不漫长，却可以说的上丰富与多变。现如今，从学术、商业、工业角度来审视的人工智能，占据主流的是传统机器学习跟深度学习，然后才是强化学习跟规则学习（个人看法）。当然，如今的机器学习算法或多或少都用上了概率统计的知识。</p>\n<p>深度学习如今越来越火热，在我自己开始留意机器学习的内容开始，深度学习相关的文章跟新闻就狂轰滥炸地映入我的眼里，以至于我没法不正视它。后来我也简单的接触深度学习，才发现它确实不可思议。在训练深度学习时，它就是在特征空间里不断逼近然后拟合到数据特征的“万能函数”，怪不得说它是<code>万能近似图灵机</code>。把它应用到许多领域感觉也就不奇怪了，当然它不一定比传统的机器学习和其他人工智能算法要更有效。</p>\n<p>不过可能是因为深度学习的<code>万用性</code>导致它的<code>黑箱性</code>，大部分人在使用它来解决问题的时候，没有获得很好的解释，无论是从深度学习结构模型的理论角度还是问题本身特性的角度。只是在设计网络架构时，粗略地分析问题的特性，然后改良别人成功的架构跟“合理”的解释来解决问题。在问题较满意的解决后，没有合理的可解释性或者干脆从他人理解的来解释。</p>\n<p>当然，从实用性跟工作角度来说，我觉得这样没错。深度学习跟你的剪刀和锤子一样，只是解决问题跟生产的工具，并不需要在意内部机理。这样的比喻来解释可能非常不妥当，不过我想表达的是，如今主流的人工智能方法：深度学习，虽然在构造时有比较好的理论基础，但在优化模型，优化架构，并且在解释优化可能性与优化思路上，缺乏理论。（对深度学习接触才几周，造成这样可能有偏差的认知，如有错误，欢迎指出）</p>\n<p>相比于深度学习，传统偏向于统计的机器学习，可解释性就比较强了，而且在很多时候，从各种角度上与深度学习比较，丝毫不逊色。而且现实的问题非常复杂，蕴含大量不确定跟随机的事件，而概率论与数理统计就是对现实世界建立这样的一些模型跟假设，这方面的理论也算比较完善了，所以传统机器学习更能在数学理论上解释一些模型的行为。</p>\n<p>而最近神经网络之父 Geoffrey Hinton 也表明对<code>BP</code>非常怀疑，应该抛弃它。BP如今是深度学习最常用的算法了，如果丢弃它，深度学习大概会大变样吧。如此看来，深度学习没有那么“完美”，仍需要大量基础研究甚至真的可能在未来被更好的算法替代。</p>\n<h2 id=\"展望未来的人工智能\"><a href=\"#展望未来的人工智能\" class=\"headerlink\" title=\"展望未来的人工智能\"></a>展望未来的人工智能</h2><p>如果想到三十年以后，大街小巷到处有序而不拥挤地行驶着无人车，载着乘客去景点；天空上时不时飞过一架架无人机，拍摄城市风景与监控城市安全；新闻报道是程序根据许多视频、图片。文本而撰写的；家里布满了传感器跟智能家具，许多繁琐事情可以通过简单对话跟指令来处理。<br>想到如果真能如此，不由对如今的人工智能算法寄予厚望并抱有乐观的想法。</p>\n<p>但在我看来，上面的美好描述可能还是过于乐观了。</p>\n<p>之前曾在哪里看到一个观点，20年后人工智能将会代替80%的工作。我觉得这个也太乐观了。当今现实生活中，从事脑力活动的人已经多余从事体力活动的人了，未来这个趋势应该更加明显。而以目前人工智能的能力，很多脑力活动不能代替（或者说，实现这些能代替脑力活动的程序需要更多脑力的脑力活动）。若人工智能的算法更加成熟稳定，许多人应该会从事人工智能相关的工作，建设基础设施（其实现在就有很多人往机器学习这个方向转业），普及人工智能，而只有少部分人推动人工智能的发展。</p>\n<p>其实我一直不敢想像未来，这对于我太难了。十年前我对未来的展望似乎跟如今的现实大相径庭了。自己觉得可能出现的东西往往没有到来，反而出现一些超出以前认知的意外事物。说不定，以后深度学习也不再是实现人工智能的主力了，出现一些特定算法可以实现以前难以实现的智能，但却无法较好完成如今研究的方向。最坏的情况就是深度学习仍然是主流，而其理论仍然不明朗，调参也没有完备的方法论，人工智能发展停滞了几十年，直到我们这一代人死去，这后面的事情我也不想展望了。</p>"},{"title":"从《线性代数应该这样学》到《Redis的设计与实现》","date":"2017-09-08T13:50:19.000Z","_content":"# 从《线性代数应该这样学》到《Redis的设计与实现》\n\n## 《线性代数应该这样学》\n\n![部分目录](/images/线性代数应该这样学1.jpg)\n\n<!-- more -->\n\n### 起因\n\n这本是好早之前买的，当时想着是时候复习一下线性代数了，因为以后要用到（那时候想到可能需要接触一下机器学习了）。买来之后发现太数学了，怕是数学系的许多人也吃不消看这种书。\n\n### 收获与总结\n\n这本书可以作为第一本或者第二本线性代数的学习材料。但这本书远比本科工科的要求要高出许多，以致于作者在前言里说，这本每页应当至少投入一小时来学习。匆匆看完前两章我便放下了，书里充斥着大量证明，从最基本的`向量空间`的定义引出基本的性质，然后用证明的方式来引出各种向量空间的特点跟性质。而这是第一章的内容，读起来还是挺熟悉的感觉的，只是换了一种表述各种概念的方式和术语，但深入思考便与之前学习的向量没有多少差别。这里与我大一学的过程就差别大了，大一是直接从矩阵着手，最后讲到向量，但那时候觉得向量是很突兀的东西，甚至跟高中学习的向量完全不一样，没有从几何的角度稍加解释向量的一些特点。而这本书从`标量`开始，比较了标量跟向量的异同，开阔了一下从标量到向量的思路，本质上它们比自己想像的还要相似。\n\n第二章接着从有限维度引申到无限维度，在讨论了无限维度的一些异同后，继续深入了向量空间的各种特性，譬如`张成空间`，`直和`这些陌生的概念。而这些与普通向量之间的联系是很紧密的，但读到后面愈发抽象，我其实也忘记了七七八八了，惭愧。\n\n后面几章暂时就没有看了，基本应该是从向量空间引申到线性映射，然后引出矩阵及其性质。在我看来矩阵是向量空间的更一般化，所以以后继续讨论的大量性质，也可能用于向量。最后从矩阵的一般运算到各种算子，最后才提出行列式相关内容，大概就是这样（*痛苦*）的过程吧。\n\n## 《TCP/IP网络编程》\n\n### 感获\n\n这本书是一本网络编程的入门书，整体难度跟`CSAPP`的第三部分差不多，各有侧重吧，内容有比较多重叠，但内容稍微多于`CSAPP`。用的是`C语言的socket接口`来讲解基本原理。用C语言讲有个好处，就是能直接从操作系统级别来思考网络编程，而且能使用全部的socket模式、所有并发模型、IO模型。\n缺点是这些socket api相当底层，以至于一个api只做一个最基本的逻辑操作。学习起来特别费劲，而且高度依赖一部分操作系统的知识。\n因为之前接触过`golang`和`nodejs`，分别也简单用过相应的socket接口。这两个语言的并发模型比较受限，nodejs目前只能异步跟简单多进程（将来应该可以用上简单多线程），golang倒是用goroutine（线程调度），通道（或者叫信道），多进程。而它们的socket接口便是跟这些模型有一定的耦合，而且高度精简，有更好的语义，从底层上面减去一些麻烦。当然，nodejs因为更单一，比golang还精简。\n\n言归正传，这本书其实重点不在于讲解socket api，而是从使用api来达到理解socket编程思维，socket的各种核心功能，tcp/udp基本原理，并发模型的基本原理，可能还有较多的跨平台编程思路（因为C语言的socket各个系统有差异）。\n\n### 一点思考\n\n因为听说是隔壁网络工程的网络编程课的教材（说实话，这本书可能稍微浅了点，除非隔壁把这本书全部内容都讲授，我觉得才比较合理），我也无意中看到并且有打算看看。不过这本书实际比较狭窄，基本专注于tcp和并发这两个内容了，虽然充分且不错地解释了部分tcp知识，部分操作系统知识，对应用层太忽略了（提了下dns跟http），我个人认为把传输层跟应用层稍加紧密地联系起来，更能激发学习兴趣，也使这本书更加实用。\n\n其实大概就匆匆看了半本，而且忽略了windows下的实现，自己也就琢磨了下源码，基本没有自己去写过（坏习惯啊），算是预热`计算机网络`跟`操作系统`的知识了。\n\n## 《Redis的设计与实现》\n\n这是图书馆借的到好书，其实早想看了，之前拿起来抱怨看不懂，这次再拿起来，已经不是那么可怕了。\n\n### 收获\n\n不过现在我看的比较少，数据结构篇还没有看完，也算是温习一些数据结构的知识了。这本书把redis相关的数据结构的内存模型很漂亮的表述清楚了，特别是hash和跳表，结合了许多图片来理解。也讲清楚了实现该数据结构的动机，复杂度，和一些特性。但大部分的数据结构基础操作忽略了，有些地方比较好奇，却没有讲到。这是我目前读到第六章的感受。但快开学了，这些书不太可能全看完，接下来怎么看还是得看心情咯。\n\n## 最近的读书总结\n\n其实还看了不少书，比如《深度学习》、《机器学习》、《统计学习方法》、《流畅的python》等，这些应该是一两个月前开始看的，都是需要长期学习的知识，在暑假机器学习集训班学习时来补充机器学习相关知识的。之后会写机器学习相关的总结，所以没有在这里总结一些知识跟感想。\n还有部分书是跟下学期的课比较紧密的，提前看看也算是预习，本身也挺感兴趣的，也不一一列出了，读的篇幅不多，列出意义也不大。","source":"_posts/从《线性代数应该这样学》到《Redis的设计与实现》.md","raw":"---\ntitle: 从《线性代数应该这样学》到《Redis的设计与实现》\ndate: 2017-09-08 21:50:19\ntags: summary\ncategory: study\n---\n# 从《线性代数应该这样学》到《Redis的设计与实现》\n\n## 《线性代数应该这样学》\n\n![部分目录](/images/线性代数应该这样学1.jpg)\n\n<!-- more -->\n\n### 起因\n\n这本是好早之前买的，当时想着是时候复习一下线性代数了，因为以后要用到（那时候想到可能需要接触一下机器学习了）。买来之后发现太数学了，怕是数学系的许多人也吃不消看这种书。\n\n### 收获与总结\n\n这本书可以作为第一本或者第二本线性代数的学习材料。但这本书远比本科工科的要求要高出许多，以致于作者在前言里说，这本每页应当至少投入一小时来学习。匆匆看完前两章我便放下了，书里充斥着大量证明，从最基本的`向量空间`的定义引出基本的性质，然后用证明的方式来引出各种向量空间的特点跟性质。而这是第一章的内容，读起来还是挺熟悉的感觉的，只是换了一种表述各种概念的方式和术语，但深入思考便与之前学习的向量没有多少差别。这里与我大一学的过程就差别大了，大一是直接从矩阵着手，最后讲到向量，但那时候觉得向量是很突兀的东西，甚至跟高中学习的向量完全不一样，没有从几何的角度稍加解释向量的一些特点。而这本书从`标量`开始，比较了标量跟向量的异同，开阔了一下从标量到向量的思路，本质上它们比自己想像的还要相似。\n\n第二章接着从有限维度引申到无限维度，在讨论了无限维度的一些异同后，继续深入了向量空间的各种特性，譬如`张成空间`，`直和`这些陌生的概念。而这些与普通向量之间的联系是很紧密的，但读到后面愈发抽象，我其实也忘记了七七八八了，惭愧。\n\n后面几章暂时就没有看了，基本应该是从向量空间引申到线性映射，然后引出矩阵及其性质。在我看来矩阵是向量空间的更一般化，所以以后继续讨论的大量性质，也可能用于向量。最后从矩阵的一般运算到各种算子，最后才提出行列式相关内容，大概就是这样（*痛苦*）的过程吧。\n\n## 《TCP/IP网络编程》\n\n### 感获\n\n这本书是一本网络编程的入门书，整体难度跟`CSAPP`的第三部分差不多，各有侧重吧，内容有比较多重叠，但内容稍微多于`CSAPP`。用的是`C语言的socket接口`来讲解基本原理。用C语言讲有个好处，就是能直接从操作系统级别来思考网络编程，而且能使用全部的socket模式、所有并发模型、IO模型。\n缺点是这些socket api相当底层，以至于一个api只做一个最基本的逻辑操作。学习起来特别费劲，而且高度依赖一部分操作系统的知识。\n因为之前接触过`golang`和`nodejs`，分别也简单用过相应的socket接口。这两个语言的并发模型比较受限，nodejs目前只能异步跟简单多进程（将来应该可以用上简单多线程），golang倒是用goroutine（线程调度），通道（或者叫信道），多进程。而它们的socket接口便是跟这些模型有一定的耦合，而且高度精简，有更好的语义，从底层上面减去一些麻烦。当然，nodejs因为更单一，比golang还精简。\n\n言归正传，这本书其实重点不在于讲解socket api，而是从使用api来达到理解socket编程思维，socket的各种核心功能，tcp/udp基本原理，并发模型的基本原理，可能还有较多的跨平台编程思路（因为C语言的socket各个系统有差异）。\n\n### 一点思考\n\n因为听说是隔壁网络工程的网络编程课的教材（说实话，这本书可能稍微浅了点，除非隔壁把这本书全部内容都讲授，我觉得才比较合理），我也无意中看到并且有打算看看。不过这本书实际比较狭窄，基本专注于tcp和并发这两个内容了，虽然充分且不错地解释了部分tcp知识，部分操作系统知识，对应用层太忽略了（提了下dns跟http），我个人认为把传输层跟应用层稍加紧密地联系起来，更能激发学习兴趣，也使这本书更加实用。\n\n其实大概就匆匆看了半本，而且忽略了windows下的实现，自己也就琢磨了下源码，基本没有自己去写过（坏习惯啊），算是预热`计算机网络`跟`操作系统`的知识了。\n\n## 《Redis的设计与实现》\n\n这是图书馆借的到好书，其实早想看了，之前拿起来抱怨看不懂，这次再拿起来，已经不是那么可怕了。\n\n### 收获\n\n不过现在我看的比较少，数据结构篇还没有看完，也算是温习一些数据结构的知识了。这本书把redis相关的数据结构的内存模型很漂亮的表述清楚了，特别是hash和跳表，结合了许多图片来理解。也讲清楚了实现该数据结构的动机，复杂度，和一些特性。但大部分的数据结构基础操作忽略了，有些地方比较好奇，却没有讲到。这是我目前读到第六章的感受。但快开学了，这些书不太可能全看完，接下来怎么看还是得看心情咯。\n\n## 最近的读书总结\n\n其实还看了不少书，比如《深度学习》、《机器学习》、《统计学习方法》、《流畅的python》等，这些应该是一两个月前开始看的，都是需要长期学习的知识，在暑假机器学习集训班学习时来补充机器学习相关知识的。之后会写机器学习相关的总结，所以没有在这里总结一些知识跟感想。\n还有部分书是跟下学期的课比较紧密的，提前看看也算是预习，本身也挺感兴趣的，也不一一列出了，读的篇幅不多，列出意义也不大。","slug":"从《线性代数应该这样学》到《Redis的设计与实现》","published":1,"updated":"2017-09-24T11:34:14.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y99000t6svsm6f5i7rv","content":"<h1 id=\"从《线性代数应该这样学》到《Redis的设计与实现》\"><a href=\"#从《线性代数应该这样学》到《Redis的设计与实现》\" class=\"headerlink\" title=\"从《线性代数应该这样学》到《Redis的设计与实现》\"></a>从《线性代数应该这样学》到《Redis的设计与实现》</h1><h2 id=\"《线性代数应该这样学》\"><a href=\"#《线性代数应该这样学》\" class=\"headerlink\" title=\"《线性代数应该这样学》\"></a>《线性代数应该这样学》</h2><p><img src=\"/images/线性代数应该这样学1.jpg\" alt=\"部分目录\"></p>\n<a id=\"more\"></a>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>这本是好早之前买的，当时想着是时候复习一下线性代数了，因为以后要用到（那时候想到可能需要接触一下机器学习了）。买来之后发现太数学了，怕是数学系的许多人也吃不消看这种书。</p>\n<h3 id=\"收获与总结\"><a href=\"#收获与总结\" class=\"headerlink\" title=\"收获与总结\"></a>收获与总结</h3><p>这本书可以作为第一本或者第二本线性代数的学习材料。但这本书远比本科工科的要求要高出许多，以致于作者在前言里说，这本每页应当至少投入一小时来学习。匆匆看完前两章我便放下了，书里充斥着大量证明，从最基本的<code>向量空间</code>的定义引出基本的性质，然后用证明的方式来引出各种向量空间的特点跟性质。而这是第一章的内容，读起来还是挺熟悉的感觉的，只是换了一种表述各种概念的方式和术语，但深入思考便与之前学习的向量没有多少差别。这里与我大一学的过程就差别大了，大一是直接从矩阵着手，最后讲到向量，但那时候觉得向量是很突兀的东西，甚至跟高中学习的向量完全不一样，没有从几何的角度稍加解释向量的一些特点。而这本书从<code>标量</code>开始，比较了标量跟向量的异同，开阔了一下从标量到向量的思路，本质上它们比自己想像的还要相似。</p>\n<p>第二章接着从有限维度引申到无限维度，在讨论了无限维度的一些异同后，继续深入了向量空间的各种特性，譬如<code>张成空间</code>，<code>直和</code>这些陌生的概念。而这些与普通向量之间的联系是很紧密的，但读到后面愈发抽象，我其实也忘记了七七八八了，惭愧。</p>\n<p>后面几章暂时就没有看了，基本应该是从向量空间引申到线性映射，然后引出矩阵及其性质。在我看来矩阵是向量空间的更一般化，所以以后继续讨论的大量性质，也可能用于向量。最后从矩阵的一般运算到各种算子，最后才提出行列式相关内容，大概就是这样（<em>痛苦</em>）的过程吧。</p>\n<h2 id=\"《TCP-IP网络编程》\"><a href=\"#《TCP-IP网络编程》\" class=\"headerlink\" title=\"《TCP/IP网络编程》\"></a>《TCP/IP网络编程》</h2><h3 id=\"感获\"><a href=\"#感获\" class=\"headerlink\" title=\"感获\"></a>感获</h3><p>这本书是一本网络编程的入门书，整体难度跟<code>CSAPP</code>的第三部分差不多，各有侧重吧，内容有比较多重叠，但内容稍微多于<code>CSAPP</code>。用的是<code>C语言的socket接口</code>来讲解基本原理。用C语言讲有个好处，就是能直接从操作系统级别来思考网络编程，而且能使用全部的socket模式、所有并发模型、IO模型。<br>缺点是这些socket api相当底层，以至于一个api只做一个最基本的逻辑操作。学习起来特别费劲，而且高度依赖一部分操作系统的知识。<br>因为之前接触过<code>golang</code>和<code>nodejs</code>，分别也简单用过相应的socket接口。这两个语言的并发模型比较受限，nodejs目前只能异步跟简单多进程（将来应该可以用上简单多线程），golang倒是用goroutine（线程调度），通道（或者叫信道），多进程。而它们的socket接口便是跟这些模型有一定的耦合，而且高度精简，有更好的语义，从底层上面减去一些麻烦。当然，nodejs因为更单一，比golang还精简。</p>\n<p>言归正传，这本书其实重点不在于讲解socket api，而是从使用api来达到理解socket编程思维，socket的各种核心功能，tcp/udp基本原理，并发模型的基本原理，可能还有较多的跨平台编程思路（因为C语言的socket各个系统有差异）。</p>\n<h3 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h3><p>因为听说是隔壁网络工程的网络编程课的教材（说实话，这本书可能稍微浅了点，除非隔壁把这本书全部内容都讲授，我觉得才比较合理），我也无意中看到并且有打算看看。不过这本书实际比较狭窄，基本专注于tcp和并发这两个内容了，虽然充分且不错地解释了部分tcp知识，部分操作系统知识，对应用层太忽略了（提了下dns跟http），我个人认为把传输层跟应用层稍加紧密地联系起来，更能激发学习兴趣，也使这本书更加实用。</p>\n<p>其实大概就匆匆看了半本，而且忽略了windows下的实现，自己也就琢磨了下源码，基本没有自己去写过（坏习惯啊），算是预热<code>计算机网络</code>跟<code>操作系统</code>的知识了。</p>\n<h2 id=\"《Redis的设计与实现》\"><a href=\"#《Redis的设计与实现》\" class=\"headerlink\" title=\"《Redis的设计与实现》\"></a>《Redis的设计与实现》</h2><p>这是图书馆借的到好书，其实早想看了，之前拿起来抱怨看不懂，这次再拿起来，已经不是那么可怕了。</p>\n<h3 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h3><p>不过现在我看的比较少，数据结构篇还没有看完，也算是温习一些数据结构的知识了。这本书把redis相关的数据结构的内存模型很漂亮的表述清楚了，特别是hash和跳表，结合了许多图片来理解。也讲清楚了实现该数据结构的动机，复杂度，和一些特性。但大部分的数据结构基础操作忽略了，有些地方比较好奇，却没有讲到。这是我目前读到第六章的感受。但快开学了，这些书不太可能全看完，接下来怎么看还是得看心情咯。</p>\n<h2 id=\"最近的读书总结\"><a href=\"#最近的读书总结\" class=\"headerlink\" title=\"最近的读书总结\"></a>最近的读书总结</h2><p>其实还看了不少书，比如《深度学习》、《机器学习》、《统计学习方法》、《流畅的python》等，这些应该是一两个月前开始看的，都是需要长期学习的知识，在暑假机器学习集训班学习时来补充机器学习相关知识的。之后会写机器学习相关的总结，所以没有在这里总结一些知识跟感想。<br>还有部分书是跟下学期的课比较紧密的，提前看看也算是预习，本身也挺感兴趣的，也不一一列出了，读的篇幅不多，列出意义也不大。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"从《线性代数应该这样学》到《Redis的设计与实现》\"><a href=\"#从《线性代数应该这样学》到《Redis的设计与实现》\" class=\"headerlink\" title=\"从《线性代数应该这样学》到《Redis的设计与实现》\"></a>从《线性代数应该这样学》到《Redis的设计与实现》</h1><h2 id=\"《线性代数应该这样学》\"><a href=\"#《线性代数应该这样学》\" class=\"headerlink\" title=\"《线性代数应该这样学》\"></a>《线性代数应该这样学》</h2><p><img src=\"/images/线性代数应该这样学1.jpg\" alt=\"部分目录\"></p>","more":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>这本是好早之前买的，当时想着是时候复习一下线性代数了，因为以后要用到（那时候想到可能需要接触一下机器学习了）。买来之后发现太数学了，怕是数学系的许多人也吃不消看这种书。</p>\n<h3 id=\"收获与总结\"><a href=\"#收获与总结\" class=\"headerlink\" title=\"收获与总结\"></a>收获与总结</h3><p>这本书可以作为第一本或者第二本线性代数的学习材料。但这本书远比本科工科的要求要高出许多，以致于作者在前言里说，这本每页应当至少投入一小时来学习。匆匆看完前两章我便放下了，书里充斥着大量证明，从最基本的<code>向量空间</code>的定义引出基本的性质，然后用证明的方式来引出各种向量空间的特点跟性质。而这是第一章的内容，读起来还是挺熟悉的感觉的，只是换了一种表述各种概念的方式和术语，但深入思考便与之前学习的向量没有多少差别。这里与我大一学的过程就差别大了，大一是直接从矩阵着手，最后讲到向量，但那时候觉得向量是很突兀的东西，甚至跟高中学习的向量完全不一样，没有从几何的角度稍加解释向量的一些特点。而这本书从<code>标量</code>开始，比较了标量跟向量的异同，开阔了一下从标量到向量的思路，本质上它们比自己想像的还要相似。</p>\n<p>第二章接着从有限维度引申到无限维度，在讨论了无限维度的一些异同后，继续深入了向量空间的各种特性，譬如<code>张成空间</code>，<code>直和</code>这些陌生的概念。而这些与普通向量之间的联系是很紧密的，但读到后面愈发抽象，我其实也忘记了七七八八了，惭愧。</p>\n<p>后面几章暂时就没有看了，基本应该是从向量空间引申到线性映射，然后引出矩阵及其性质。在我看来矩阵是向量空间的更一般化，所以以后继续讨论的大量性质，也可能用于向量。最后从矩阵的一般运算到各种算子，最后才提出行列式相关内容，大概就是这样（<em>痛苦</em>）的过程吧。</p>\n<h2 id=\"《TCP-IP网络编程》\"><a href=\"#《TCP-IP网络编程》\" class=\"headerlink\" title=\"《TCP/IP网络编程》\"></a>《TCP/IP网络编程》</h2><h3 id=\"感获\"><a href=\"#感获\" class=\"headerlink\" title=\"感获\"></a>感获</h3><p>这本书是一本网络编程的入门书，整体难度跟<code>CSAPP</code>的第三部分差不多，各有侧重吧，内容有比较多重叠，但内容稍微多于<code>CSAPP</code>。用的是<code>C语言的socket接口</code>来讲解基本原理。用C语言讲有个好处，就是能直接从操作系统级别来思考网络编程，而且能使用全部的socket模式、所有并发模型、IO模型。<br>缺点是这些socket api相当底层，以至于一个api只做一个最基本的逻辑操作。学习起来特别费劲，而且高度依赖一部分操作系统的知识。<br>因为之前接触过<code>golang</code>和<code>nodejs</code>，分别也简单用过相应的socket接口。这两个语言的并发模型比较受限，nodejs目前只能异步跟简单多进程（将来应该可以用上简单多线程），golang倒是用goroutine（线程调度），通道（或者叫信道），多进程。而它们的socket接口便是跟这些模型有一定的耦合，而且高度精简，有更好的语义，从底层上面减去一些麻烦。当然，nodejs因为更单一，比golang还精简。</p>\n<p>言归正传，这本书其实重点不在于讲解socket api，而是从使用api来达到理解socket编程思维，socket的各种核心功能，tcp/udp基本原理，并发模型的基本原理，可能还有较多的跨平台编程思路（因为C语言的socket各个系统有差异）。</p>\n<h3 id=\"一点思考\"><a href=\"#一点思考\" class=\"headerlink\" title=\"一点思考\"></a>一点思考</h3><p>因为听说是隔壁网络工程的网络编程课的教材（说实话，这本书可能稍微浅了点，除非隔壁把这本书全部内容都讲授，我觉得才比较合理），我也无意中看到并且有打算看看。不过这本书实际比较狭窄，基本专注于tcp和并发这两个内容了，虽然充分且不错地解释了部分tcp知识，部分操作系统知识，对应用层太忽略了（提了下dns跟http），我个人认为把传输层跟应用层稍加紧密地联系起来，更能激发学习兴趣，也使这本书更加实用。</p>\n<p>其实大概就匆匆看了半本，而且忽略了windows下的实现，自己也就琢磨了下源码，基本没有自己去写过（坏习惯啊），算是预热<code>计算机网络</code>跟<code>操作系统</code>的知识了。</p>\n<h2 id=\"《Redis的设计与实现》\"><a href=\"#《Redis的设计与实现》\" class=\"headerlink\" title=\"《Redis的设计与实现》\"></a>《Redis的设计与实现》</h2><p>这是图书馆借的到好书，其实早想看了，之前拿起来抱怨看不懂，这次再拿起来，已经不是那么可怕了。</p>\n<h3 id=\"收获\"><a href=\"#收获\" class=\"headerlink\" title=\"收获\"></a>收获</h3><p>不过现在我看的比较少，数据结构篇还没有看完，也算是温习一些数据结构的知识了。这本书把redis相关的数据结构的内存模型很漂亮的表述清楚了，特别是hash和跳表，结合了许多图片来理解。也讲清楚了实现该数据结构的动机，复杂度，和一些特性。但大部分的数据结构基础操作忽略了，有些地方比较好奇，却没有讲到。这是我目前读到第六章的感受。但快开学了，这些书不太可能全看完，接下来怎么看还是得看心情咯。</p>\n<h2 id=\"最近的读书总结\"><a href=\"#最近的读书总结\" class=\"headerlink\" title=\"最近的读书总结\"></a>最近的读书总结</h2><p>其实还看了不少书，比如《深度学习》、《机器学习》、《统计学习方法》、《流畅的python》等，这些应该是一两个月前开始看的，都是需要长期学习的知识，在暑假机器学习集训班学习时来补充机器学习相关知识的。之后会写机器学习相关的总结，所以没有在这里总结一些知识跟感想。<br>还有部分书是跟下学期的课比较紧密的，提前看看也算是预习，本身也挺感兴趣的，也不一一列出了，读的篇幅不多，列出意义也不大。</p>"},{"title":"最近一周总结","date":"2017-08-20T12:57:17.000Z","_content":"# 总结\n\n## 近况\n\n### 杂项\n\n发现已经漏了好几天没有写博客，也不知道自己能否坚持下去，最近可能也比较懈怠。C++的模版接触了下，发现使用还是容易掌握的，但后来就没有学下去了。靠这样学是永远学不完的，甚至学了一部分忘记七七八八了。打算下学期如果适合C++编程的任务，尽量使用C++来完成，这样有任务的使用C++应该能学的更快，更扎实，C++学好了，很多东西也都能学好，果然不是空穴来风。\n\n### 兴趣方向\n\n最近学习深度学习的基础，主要是全连接神经网络(FNN)和卷积神经网络(CNN)，其实正式学习是下周，所以这周在机器学习方面懈怠很多。其他方面呢，编译原理，《编译器设计》看了些内容，感觉很有收获，虽然不是直接关于编译原理的收获，但对计算机的全貌有了更进一步的了解。期间，查了一些关于链接的知识，也看了一点点关于`linux kernel`的知识，总的来说，收获了一点点学习这些知识的方法论。\n\n<!-- more -->\n\n### 英文资料\n\n这两天买了两本英文书，打算常常读一读，一本是go圣经，一本是《编译原理与实践》。两本对于我来说应该难度不大。go圣经我看过半本中文版，虽然还掌握的不好，但有了前置知识，看英文只是时间问题。《编译原理与实践》比《龙书》跟《编译器设计》要简单些，所以买了英文版，打算下学期的编译原理课配合着读。这么说来了，在编译原理相关的书里，我已经接触了6，7本了，但其实没有精读过任何一本。下学期重点看这三本吧，以我现在半吊子的水平，希望本科基本能看完3，4本。毕竟最想从事的就是编译器相关工作，也说不清为什么偏爱这个。\n\n## 不足与改正\n\n最近越来越意识到自己在编程方面的缺陷，不论编写代码量小还是较大，自己思路一直不清晰。说来，很多我编写的代码，是根据别人的来编写的，自己完全独立从头开始写的几乎没有。上大学以后，在学业方面的作业情况也有类似，就是没有自己的思路，得照着例题来“复现”思路，但这终归不是自己学到的知识。这个问题从大学开始的，已经遗留比较久了，严重影响了自己的思维。趁着下学期的许多有趣课程跟高难度的高强度的课表，改着这个坏毛病，尽量做到把书本知识深刻映入大脑，然后根据自己的思路来完成作业而不依赖参考答案。\n","source":"_posts/最近一周总结.md","raw":"---\ntitle: 最近一周总结\ndate: 2017-08-20 20:57:17\ntags: summary\ncategory: study\n---\n# 总结\n\n## 近况\n\n### 杂项\n\n发现已经漏了好几天没有写博客，也不知道自己能否坚持下去，最近可能也比较懈怠。C++的模版接触了下，发现使用还是容易掌握的，但后来就没有学下去了。靠这样学是永远学不完的，甚至学了一部分忘记七七八八了。打算下学期如果适合C++编程的任务，尽量使用C++来完成，这样有任务的使用C++应该能学的更快，更扎实，C++学好了，很多东西也都能学好，果然不是空穴来风。\n\n### 兴趣方向\n\n最近学习深度学习的基础，主要是全连接神经网络(FNN)和卷积神经网络(CNN)，其实正式学习是下周，所以这周在机器学习方面懈怠很多。其他方面呢，编译原理，《编译器设计》看了些内容，感觉很有收获，虽然不是直接关于编译原理的收获，但对计算机的全貌有了更进一步的了解。期间，查了一些关于链接的知识，也看了一点点关于`linux kernel`的知识，总的来说，收获了一点点学习这些知识的方法论。\n\n<!-- more -->\n\n### 英文资料\n\n这两天买了两本英文书，打算常常读一读，一本是go圣经，一本是《编译原理与实践》。两本对于我来说应该难度不大。go圣经我看过半本中文版，虽然还掌握的不好，但有了前置知识，看英文只是时间问题。《编译原理与实践》比《龙书》跟《编译器设计》要简单些，所以买了英文版，打算下学期的编译原理课配合着读。这么说来了，在编译原理相关的书里，我已经接触了6，7本了，但其实没有精读过任何一本。下学期重点看这三本吧，以我现在半吊子的水平，希望本科基本能看完3，4本。毕竟最想从事的就是编译器相关工作，也说不清为什么偏爱这个。\n\n## 不足与改正\n\n最近越来越意识到自己在编程方面的缺陷，不论编写代码量小还是较大，自己思路一直不清晰。说来，很多我编写的代码，是根据别人的来编写的，自己完全独立从头开始写的几乎没有。上大学以后，在学业方面的作业情况也有类似，就是没有自己的思路，得照着例题来“复现”思路，但这终归不是自己学到的知识。这个问题从大学开始的，已经遗留比较久了，严重影响了自己的思维。趁着下学期的许多有趣课程跟高难度的高强度的课表，改着这个坏毛病，尽量做到把书本知识深刻映入大脑，然后根据自己的思路来完成作业而不依赖参考答案。\n","slug":"最近一周总结","published":1,"updated":"2017-09-24T11:34:44.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y9b000v6svsmko2x1f4","content":"<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"近况\"><a href=\"#近况\" class=\"headerlink\" title=\"近况\"></a>近况</h2><h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><p>发现已经漏了好几天没有写博客，也不知道自己能否坚持下去，最近可能也比较懈怠。C++的模版接触了下，发现使用还是容易掌握的，但后来就没有学下去了。靠这样学是永远学不完的，甚至学了一部分忘记七七八八了。打算下学期如果适合C++编程的任务，尽量使用C++来完成，这样有任务的使用C++应该能学的更快，更扎实，C++学好了，很多东西也都能学好，果然不是空穴来风。</p>\n<h3 id=\"兴趣方向\"><a href=\"#兴趣方向\" class=\"headerlink\" title=\"兴趣方向\"></a>兴趣方向</h3><p>最近学习深度学习的基础，主要是全连接神经网络(FNN)和卷积神经网络(CNN)，其实正式学习是下周，所以这周在机器学习方面懈怠很多。其他方面呢，编译原理，《编译器设计》看了些内容，感觉很有收获，虽然不是直接关于编译原理的收获，但对计算机的全貌有了更进一步的了解。期间，查了一些关于链接的知识，也看了一点点关于<code>linux kernel</code>的知识，总的来说，收获了一点点学习这些知识的方法论。</p>\n<a id=\"more\"></a>\n<h3 id=\"英文资料\"><a href=\"#英文资料\" class=\"headerlink\" title=\"英文资料\"></a>英文资料</h3><p>这两天买了两本英文书，打算常常读一读，一本是go圣经，一本是《编译原理与实践》。两本对于我来说应该难度不大。go圣经我看过半本中文版，虽然还掌握的不好，但有了前置知识，看英文只是时间问题。《编译原理与实践》比《龙书》跟《编译器设计》要简单些，所以买了英文版，打算下学期的编译原理课配合着读。这么说来了，在编译原理相关的书里，我已经接触了6，7本了，但其实没有精读过任何一本。下学期重点看这三本吧，以我现在半吊子的水平，希望本科基本能看完3，4本。毕竟最想从事的就是编译器相关工作，也说不清为什么偏爱这个。</p>\n<h2 id=\"不足与改正\"><a href=\"#不足与改正\" class=\"headerlink\" title=\"不足与改正\"></a>不足与改正</h2><p>最近越来越意识到自己在编程方面的缺陷，不论编写代码量小还是较大，自己思路一直不清晰。说来，很多我编写的代码，是根据别人的来编写的，自己完全独立从头开始写的几乎没有。上大学以后，在学业方面的作业情况也有类似，就是没有自己的思路，得照着例题来“复现”思路，但这终归不是自己学到的知识。这个问题从大学开始的，已经遗留比较久了，严重影响了自己的思维。趁着下学期的许多有趣课程跟高难度的高强度的课表，改着这个坏毛病，尽量做到把书本知识深刻映入大脑，然后根据自己的思路来完成作业而不依赖参考答案。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"近况\"><a href=\"#近况\" class=\"headerlink\" title=\"近况\"></a>近况</h2><h3 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h3><p>发现已经漏了好几天没有写博客，也不知道自己能否坚持下去，最近可能也比较懈怠。C++的模版接触了下，发现使用还是容易掌握的，但后来就没有学下去了。靠这样学是永远学不完的，甚至学了一部分忘记七七八八了。打算下学期如果适合C++编程的任务，尽量使用C++来完成，这样有任务的使用C++应该能学的更快，更扎实，C++学好了，很多东西也都能学好，果然不是空穴来风。</p>\n<h3 id=\"兴趣方向\"><a href=\"#兴趣方向\" class=\"headerlink\" title=\"兴趣方向\"></a>兴趣方向</h3><p>最近学习深度学习的基础，主要是全连接神经网络(FNN)和卷积神经网络(CNN)，其实正式学习是下周，所以这周在机器学习方面懈怠很多。其他方面呢，编译原理，《编译器设计》看了些内容，感觉很有收获，虽然不是直接关于编译原理的收获，但对计算机的全貌有了更进一步的了解。期间，查了一些关于链接的知识，也看了一点点关于<code>linux kernel</code>的知识，总的来说，收获了一点点学习这些知识的方法论。</p>","more":"<h3 id=\"英文资料\"><a href=\"#英文资料\" class=\"headerlink\" title=\"英文资料\"></a>英文资料</h3><p>这两天买了两本英文书，打算常常读一读，一本是go圣经，一本是《编译原理与实践》。两本对于我来说应该难度不大。go圣经我看过半本中文版，虽然还掌握的不好，但有了前置知识，看英文只是时间问题。《编译原理与实践》比《龙书》跟《编译器设计》要简单些，所以买了英文版，打算下学期的编译原理课配合着读。这么说来了，在编译原理相关的书里，我已经接触了6，7本了，但其实没有精读过任何一本。下学期重点看这三本吧，以我现在半吊子的水平，希望本科基本能看完3，4本。毕竟最想从事的就是编译器相关工作，也说不清为什么偏爱这个。</p>\n<h2 id=\"不足与改正\"><a href=\"#不足与改正\" class=\"headerlink\" title=\"不足与改正\"></a>不足与改正</h2><p>最近越来越意识到自己在编程方面的缺陷，不论编写代码量小还是较大，自己思路一直不清晰。说来，很多我编写的代码，是根据别人的来编写的，自己完全独立从头开始写的几乎没有。上大学以后，在学业方面的作业情况也有类似，就是没有自己的思路，得照着例题来“复现”思路，但这终归不是自己学到的知识。这个问题从大学开始的，已经遗留比较久了，严重影响了自己的思维。趁着下学期的许多有趣课程跟高难度的高强度的课表，改着这个坏毛病，尽量做到把书本知识深刻映入大脑，然后根据自己的思路来完成作业而不依赖参考答案。</p>"},{"date":"2017-08-10T05:53:56.000Z","title":"机器学习里的一些小概念","categry":"study","_content":"# 机器学习里的一些小概念\n\n## 轮廓系数\n\n轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。最早由 Peter J. Rousseeuw 在 1986 提出。\n它结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。\n\n### 计算过程\n\n假设我们已经通过一定算法，将待分类数据进行了聚类。\n常用的比如使用K-means，将待分类数据分为了k个簇。\n对于簇中的每个向量。分别计算它们的轮廓系数。\n对于其中的一个点 i 来说：\n\n* 计算 a(i) = average(i向量到所有它属于的簇中其它点的距离)\n* 计算 b(i) = min(i向量到所有其他簇的点的平均距离)\n\n那么i向量轮廓系数就为：\n{% raw %}\n$$ S(i) = \\frac{b(i) - a(i)}{max\\{a(i), b(i)\\}} $$\n{% endraw %}\n\n### 判断\n\n可见轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。将所有点的轮廓系数求平均，就是该聚类结果总的轮廓系数。\n\n* a(i) ：i向量到同一簇内其他点不相似程度的平均值\n* b(i) ：i向量到其他簇的平均不相似程度的最小值\n* S(i)接近1，则说明样本i聚类合理；\n* S(i)接近-1，则说明样本i更应该分类到另外的簇；\n* 若S(i)近似为0，则说明样本i在两个簇的边界上。\n\n## 未完待续","source":"_posts/机器学习里的一些小概念.md","raw":"---\ndate: 2017-08-10 13:53:56\ntitle: 机器学习里的一些小概念\ntags: ML\ncategry: study\n---\n# 机器学习里的一些小概念\n\n## 轮廓系数\n\n轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。最早由 Peter J. Rousseeuw 在 1986 提出。\n它结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。\n\n### 计算过程\n\n假设我们已经通过一定算法，将待分类数据进行了聚类。\n常用的比如使用K-means，将待分类数据分为了k个簇。\n对于簇中的每个向量。分别计算它们的轮廓系数。\n对于其中的一个点 i 来说：\n\n* 计算 a(i) = average(i向量到所有它属于的簇中其它点的距离)\n* 计算 b(i) = min(i向量到所有其他簇的点的平均距离)\n\n那么i向量轮廓系数就为：\n{% raw %}\n$$ S(i) = \\frac{b(i) - a(i)}{max\\{a(i), b(i)\\}} $$\n{% endraw %}\n\n### 判断\n\n可见轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。将所有点的轮廓系数求平均，就是该聚类结果总的轮廓系数。\n\n* a(i) ：i向量到同一簇内其他点不相似程度的平均值\n* b(i) ：i向量到其他簇的平均不相似程度的最小值\n* S(i)接近1，则说明样本i聚类合理；\n* S(i)接近-1，则说明样本i更应该分类到另外的簇；\n* 若S(i)近似为0，则说明样本i在两个簇的边界上。\n\n## 未完待续","slug":"机器学习里的一些小概念","published":1,"updated":"2017-09-19T15:00:13.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y9l000z6svs84c2tboa","content":"<h1 id=\"机器学习里的一些小概念\"><a href=\"#机器学习里的一些小概念\" class=\"headerlink\" title=\"机器学习里的一些小概念\"></a>机器学习里的一些小概念</h1><h2 id=\"轮廓系数\"><a href=\"#轮廓系数\" class=\"headerlink\" title=\"轮廓系数\"></a>轮廓系数</h2><p>轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。最早由 Peter J. Rousseeuw 在 1986 提出。<br>它结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。</p>\n<h3 id=\"计算过程\"><a href=\"#计算过程\" class=\"headerlink\" title=\"计算过程\"></a>计算过程</h3><p>假设我们已经通过一定算法，将待分类数据进行了聚类。<br>常用的比如使用K-means，将待分类数据分为了k个簇。<br>对于簇中的每个向量。分别计算它们的轮廓系数。<br>对于其中的一个点 i 来说：</p>\n<ul>\n<li>计算 a(i) = average(i向量到所有它属于的簇中其它点的距离)</li>\n<li>计算 b(i) = min(i向量到所有其他簇的点的平均距离)</li>\n</ul>\n<p>那么i向量轮廓系数就为：<br>\n$$ S(i) = \\frac{b(i) - a(i)}{max\\{a(i), b(i)\\}} $$\n</p>\n<h3 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h3><p>可见轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。将所有点的轮廓系数求平均，就是该聚类结果总的轮廓系数。</p>\n<ul>\n<li>a(i) ：i向量到同一簇内其他点不相似程度的平均值</li>\n<li>b(i) ：i向量到其他簇的平均不相似程度的最小值</li>\n<li>S(i)接近1，则说明样本i聚类合理；</li>\n<li>S(i)接近-1，则说明样本i更应该分类到另外的簇；</li>\n<li>若S(i)近似为0，则说明样本i在两个簇的边界上。</li>\n</ul>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"机器学习里的一些小概念\"><a href=\"#机器学习里的一些小概念\" class=\"headerlink\" title=\"机器学习里的一些小概念\"></a>机器学习里的一些小概念</h1><h2 id=\"轮廓系数\"><a href=\"#轮廓系数\" class=\"headerlink\" title=\"轮廓系数\"></a>轮廓系数</h2><p>轮廓系数（Silhouette Coefficient），是聚类效果好坏的一种评价方式。最早由 Peter J. Rousseeuw 在 1986 提出。<br>它结合内聚度和分离度两种因素。可以用来在相同原始数据的基础上用来评价不同算法、或者算法不同运行方式对聚类结果所产生的影响。</p>\n<h3 id=\"计算过程\"><a href=\"#计算过程\" class=\"headerlink\" title=\"计算过程\"></a>计算过程</h3><p>假设我们已经通过一定算法，将待分类数据进行了聚类。<br>常用的比如使用K-means，将待分类数据分为了k个簇。<br>对于簇中的每个向量。分别计算它们的轮廓系数。<br>对于其中的一个点 i 来说：</p>\n<ul>\n<li>计算 a(i) = average(i向量到所有它属于的簇中其它点的距离)</li>\n<li>计算 b(i) = min(i向量到所有其他簇的点的平均距离)</li>\n</ul>\n<p>那么i向量轮廓系数就为：<br>\n$$ S(i) = \\frac{b(i) - a(i)}{max\\{a(i), b(i)\\}} $$\n</p>\n<h3 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h3><p>可见轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。将所有点的轮廓系数求平均，就是该聚类结果总的轮廓系数。</p>\n<ul>\n<li>a(i) ：i向量到同一簇内其他点不相似程度的平均值</li>\n<li>b(i) ：i向量到其他簇的平均不相似程度的最小值</li>\n<li>S(i)接近1，则说明样本i聚类合理；</li>\n<li>S(i)接近-1，则说明样本i更应该分类到另外的簇；</li>\n<li>若S(i)近似为0，则说明样本i在两个簇的边界上。</li>\n</ul>\n<h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2>"},{"title":"暑假机器学习总结","date":"2017-09-13T12:49:32.000Z","_content":"# 机器学习学习总结\n\n经过两个月的学习，从对机器学习一点点懵懂认知，到现在对机器学习的基础知识跟体系有一定的认知。如今学习暂告一段落，总结如今学习过的重点知识，可以起到很好的复习作业，也是对两个月以来的交代。以下，我将按照每周学习进度来总结回顾机器学习的知识。\n\n<!-- more -->\n\n## 第一周\n\n我们先学习了`python`编程基础，之后的学习是基于python各种库来实验的。我之前已经比较熟悉python，所以很快就完成这段学习；之后接触`numpy`，这是C语言为python编写的底层矩阵库，我之前也接触过，但比较浅，不过numpy封装的很好，用起来门槛也很低，很快就上手了；numpy之后就是`pandas`,它是数据分析常用的库，基于numpy，非常全面，我之前也用过，但基本需要重新学习，pandas比较难用，尤其是IO部分，有细粒度的操作，文档看起来也比较麻烦，没有示例，所以学习的过程中，是遇到问题再去查找方法，后面的学习pandas其实用到的也比较少。\n\n以上内容大概花了两天，算是对机器学习的预备知识的准备。当然期间也学习了简单的使用anaconda，jupyter等工具，不再一一总结了。\n\n之后开始学习基本的图像知识：\n\n- [颜色直方图](http://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E7%9B%B4%E6%96%B9%E5%9B%BE),它所描述的是不同色彩在整幅图像中所占的比例，而并不关心每种色彩所处的空间位置。之后有几次作业中要编写颜色直方图的处理，一开始还是挺棘手的。不过跟后来的图像特征提取就是小巫见大巫了\n- [HOG特征](http://blog.csdn.net/zouxy09/article/details/7929348)，主要思想：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。这也是之后的需要实现的任务，学习过程中，只有这个博客资料可以参考，其他资料要么可能是全英文晦涩难懂，要么还不如这个。这个博客写的太精炼了，初学的时候，实现起来非常困难，以至于有些同学对`根据这个博客写出算法`的可能性产生怀疑。我这周的作业也卡在这里了，学习机器学习的时候反而是因为图像处理知识不过关。后来经过讲解对这些特征有更新的认识了，不过可能实现起来对于现在我的依然有些困难。\n- [LBP特征](http://blog.csdn.net/zouxy09/article/details/7929531)、[Haar特征](http://blog.csdn.net/zouxy09/article/details/7929570)也是这周的基础知识，我稍微学习了下LBP，发现比HOG要好懂，Haar并没有怎么看，最后这2个内容没有出现在作业里，我对这些也只有粗浅的认识。`LBP`（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。而`Haar`特征值反映了图像的灰度变化情况。\n\n图像的部分内容学习后，开始了最基础的机器学习的内容：\n\n- [Regression](http://www.bilibili.com/video/av10590361/)，先从最简单的`线性回归`开始，线性回归可能是踏入机器学习世界的第一步吧，它教你如何做最简单的预测和机器学习比较本质的思维。前几周学习的知识大多是看李宏毅的视频，前几周感觉还是不错的。从线性回归开始，学到了基本的`梯度下降`思想和度量性能的`代价函数`。\n\n- [Error](http://www.bilibili.com/video/av10590361/#page=2)，第二节就是深入理解各种模型评估的知识，讲授了`误差`,`偏差`,`方差`的区别与联系。\n\n- [Gradient Descent](http://www.bilibili.com/video/av10590361/#page=3)，最后是深入学习梯度下降，学习推导基本的梯度下降，然后提出`随机梯度下降(SGD)`，从大量数据中随机选择一定量数据来训练，提高学习效率。除此之外，讲解了梯度下降的问题：学习率的选择。然后基于此讲解了一个算法`Adagrad`来控制学习率。\n\n- 最后还有一些比较杂的知识，了解了[K折交叉验证](https://github.com/basicv8vc/Python-Machine-Learning-zh/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_section2.md)的思想与作用，把数据集分割为训练集，验证集，测试集的思想与作用。各种[距离度量](http://blog.csdn.net/shiwei408/article/details/7602324)，可以衡量样本近似度。最后完成两个作业\n\n图像知识可能在第一周学习，有点不知其有何用的感觉，就算想在思想上重视它，但没有实际用起来，还是难以深刻理解它的重要性吧。谈点个人感受，我其实挺不擅长也不太喜欢处理图像的，大一自己有简单接触过图像处理（跟现在的学的不太一样，而是常规的图像处理，不跟特征，知识等内容关联），虽然不比这些难，但也很吃力。\n\n## 第二周\n\n第二周主要学习的是`分类`的基础算法，分别学习`K近邻`,`决策树`,`逻辑斯蒂回归`：\n\n- [KNN](http://cs231n.github.io/classification/)的思想就是把某个样本跟其他所有样本进行距离度量并总和，该样本离哪个类别'最近'，就标记为该类别。KNN是`懒惰学习`的典型算法，即到需要分类的时候才使用上训练集。在学习KNN的时候还了解到矢量化编程的重要性，减少不必要的python for 循环可以利于底层numpy优化为并行代码，在我这次实验里速度提升了近百倍。\n\n- [Logistic Regression](https://www.bilibili.com/video/av10590361/#page=5) 该算法跟线性回归（跟感知器也类似）基本类似，不过它加入了`sigmoid`函数来进行分类而不是回归。后来学习`深度学习`才知道这里有`神经网络`的最基本的思想，或者说可能是最简单的神经网络了。\n\n- [Decision Tree](https://www.bilibili.com/video/av12469267/#page=34)决策树可能是到这周为止最难的算法了，写起来会特别长。思想其实很简单，就是树的思想 + 人类决策过程。常用的决策树有`ID3`,`C4.5`,`C5.0`,`CART`等，不过我只编写了最简单的ID3，其他决策树进行了简单的了解。学习过程中认识到如果生成完整的决策树，那会变得非常耗时，后面学习到剪枝知识（我在作业里面编写`预剪枝`了，不过效果很差）。学习决策树里面知道了一些信息论的知识，如`信息熵`,`信息增益`,`纯度`等知识，决策的依据便是依据这些数值来找到最佳决策特征。\n\n最后根据学到的知识完成一个井字棋胜负预测，不过我的模型很一般。这周的知识量不是很大，更多侧重机器学习基础编程，但是感觉学到东西很多的一周。\n\n## 第三周\n\n这周学习的机器学习非常强大和实用，是现在也很常用的模型：\n\n- [SVM](https://www.bilibili.com/video/av9770190/index_27.html#page=20)非常理论，学到这里，我感觉我的高数白学了。其实现在我也不是很了解SVM，只对基本概念有了解。基本思想应该是把低维空间的非线性问题映射到高维空间线性问题来解决。然后里面概念非常多：支持向量的概念，距离度量，核函数，核方法，对偶问题，KKT等。\n\n- [集成学习](https://www.bilibili.com/video/av10590361/index_22.html#page=22)非常实用且广用。许多一般模型集成后都可以大幅度提升性能。这周接触了许多集成学习算法：\n    - `bagging`，非常简单的集成学习算法，我后来实现了bagging决策树，性能提升了许多。基本思想是`自助采样`一些样本后，分别训练n个模型，然后进行投票决策。这样可以大大减少过拟合而提升性能。\n    \n    - `Random Forest`，bagging算法的变体，基于决策树实现的。它与bagging的区别在于特化了决策树，在节点决策时，加入`属性扰动`（即只从一部分特征里选择最优特征），而bagging只有`样本扰动`（随机采集样本）。它的性能一般来说比bagging要好，我猜大概是加入了新的扰动后，更能避免决策树容易过拟合的缺点吧。\n    \n    - 其他如 `boosting`的`adboost`和`xgboost`，进行了简单了解，xgboost在kaggle里面很热门，因为性能特别好。不过这几个算法难度更大，我了解的也比较少。adboost的基本思想是让之前训练错误的部分对应的权重变大，让模型认识到这点。\n     \n- 最后是一点点图像特征的知识[bag of words model](https://gurus.pyimagesearch.com/the-bag-of-visual-words-model/)，对此进行一些了解\n\n## 第四周\n\n这周学习无监督学习，主要是聚类跟降维，不过主要是侧重分析并运用这些技术：\n\n- `聚类`可以按结构特性分为原型聚类，层次聚类，密度聚类。[K-means](https://www.bilibili.com/video/av9912938/#page=78)是最基础的聚类算法，主要思想是通过多次迭代来把刻画原型，来使误差最小。K-means之后是了解了`高斯混合聚类`，也是原型聚类。\n\n- `降维`这部分主要接触了[PCA](https://www.bilibili.com/video/av10590361/index_22.html#page=13)，不过这部分理论特别麻烦，我只搞懂了基本思想，并学会基本运用。总之，它变换了基底，并把比重最小的维度去掉来降维，这样能最大程度的保存原始样本的信息。\n\n这周机器学习的知识就进入进阶难度了，说实话，我掌握的不太会好，不过算是对机器学习的体系更加了解了。除了以上还有一些[其他知识](http://ufldl.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B)，不过比较零碎，我就不一一总结了。\n\n## 第五六七八周\n\n这里把深度学习一起总结了吧，这几周感觉学习的不太好。\n\n第六周开始，陆陆续续有许多高大上的报告可以听讲了，了解了许多前沿的应用，思想，算法。从第五周开始也步入了[深度学习](https://www.bilibili.com/video/av10590361/index_13.html#page=6)的大门。\n\n这几周主要学习`全连接网络`跟`卷积神经网络`跟`循环神经网络`，理解了很久[反向传播](https://www.bilibili.com/video/av10590361/index_13.html#page=7)，[卷积运算](https://www.bilibili.com/video/av10590361/index_13.html#page=10)。其实参考过很多资料，这里就不一一列出了。目前对`反向传播`也有稍微清晰的了解了，对于卷积，了解了其思想，但对其运算还是只有抽象的认识，反向传播可以说是目前神经网络的基础。`全连接网络`在理论上是近似的`图灵机`，不过实用性很差，一般是配合其他网络而使用。而卷积神经网络是针对图像而发明的，在图像处理跟机器视觉应用广泛。而循环神经网络更适用于序列数据，如文本，这在自然语言处理很常用，而由于一般的`RNN`有局限性，所以有一个`LSTM`的变体，这个模型我不是很清楚，但它的表现更好（最近好像又出现一个比较厉害的新变体`SRU`）。\n\n由于神经网络的代码非常难写，写出来也基本不可以重用，我们学习了`keras`这个基于`tensorflow`的深度学习框架来实现一些经典的模型。后来应用keras解决了一些基本的图像分类问题。\n\n第七八周陆陆续续的讲座也应该提一提，感觉大大开阔了我的视野。原来我以为深度学习基本都是在对图像上进行工作，好像这样也没什么意思。不过后来发现图像几乎是实现人工智能最基本的办法。而老师们的方向五花八门，问题的复杂度也远超过我的脑容量，深度学习反而变成了实现人工智能的基本工具而已，更多在于对于问题的深入研究和对特征的深入探究。\n\n这几周的学习积极性变得比较差劲了，不过收获还是很多。至少认识到机器学习跟深度学习的基本思想，我觉得未来的程序员都或多或少需要了解这些知识，因为他们可能会用到相应的算法来部署一些人工智能应用到各种设备、各种网站、各种系统中去，而懂得这些知识的人显然能在工作中更胜一筹。\n\n## 总结\n\n以上大概就是我的总结了，很粗略，也没有讲到具体的数学知识，更多是讲到自己的小小收获跟感受。我不清楚以后是否会从事机器学习相关的工作，但我以后肯定会抱着好奇心继续完善我对这些知识认识，了解里面的新思想，跟上人工智能的潮流，做一个终身学习的人吧。\n","source":"_posts/暑假机器学习总结.md","raw":"---\ntitle: 暑假机器学习总结\ndate: 2017-09-13 20:49:32\ntags: ML\ncategory: study\n---\n# 机器学习学习总结\n\n经过两个月的学习，从对机器学习一点点懵懂认知，到现在对机器学习的基础知识跟体系有一定的认知。如今学习暂告一段落，总结如今学习过的重点知识，可以起到很好的复习作业，也是对两个月以来的交代。以下，我将按照每周学习进度来总结回顾机器学习的知识。\n\n<!-- more -->\n\n## 第一周\n\n我们先学习了`python`编程基础，之后的学习是基于python各种库来实验的。我之前已经比较熟悉python，所以很快就完成这段学习；之后接触`numpy`，这是C语言为python编写的底层矩阵库，我之前也接触过，但比较浅，不过numpy封装的很好，用起来门槛也很低，很快就上手了；numpy之后就是`pandas`,它是数据分析常用的库，基于numpy，非常全面，我之前也用过，但基本需要重新学习，pandas比较难用，尤其是IO部分，有细粒度的操作，文档看起来也比较麻烦，没有示例，所以学习的过程中，是遇到问题再去查找方法，后面的学习pandas其实用到的也比较少。\n\n以上内容大概花了两天，算是对机器学习的预备知识的准备。当然期间也学习了简单的使用anaconda，jupyter等工具，不再一一总结了。\n\n之后开始学习基本的图像知识：\n\n- [颜色直方图](http://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E7%9B%B4%E6%96%B9%E5%9B%BE),它所描述的是不同色彩在整幅图像中所占的比例，而并不关心每种色彩所处的空间位置。之后有几次作业中要编写颜色直方图的处理，一开始还是挺棘手的。不过跟后来的图像特征提取就是小巫见大巫了\n- [HOG特征](http://blog.csdn.net/zouxy09/article/details/7929348)，主要思想：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。这也是之后的需要实现的任务，学习过程中，只有这个博客资料可以参考，其他资料要么可能是全英文晦涩难懂，要么还不如这个。这个博客写的太精炼了，初学的时候，实现起来非常困难，以至于有些同学对`根据这个博客写出算法`的可能性产生怀疑。我这周的作业也卡在这里了，学习机器学习的时候反而是因为图像处理知识不过关。后来经过讲解对这些特征有更新的认识了，不过可能实现起来对于现在我的依然有些困难。\n- [LBP特征](http://blog.csdn.net/zouxy09/article/details/7929531)、[Haar特征](http://blog.csdn.net/zouxy09/article/details/7929570)也是这周的基础知识，我稍微学习了下LBP，发现比HOG要好懂，Haar并没有怎么看，最后这2个内容没有出现在作业里，我对这些也只有粗浅的认识。`LBP`（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。而`Haar`特征值反映了图像的灰度变化情况。\n\n图像的部分内容学习后，开始了最基础的机器学习的内容：\n\n- [Regression](http://www.bilibili.com/video/av10590361/)，先从最简单的`线性回归`开始，线性回归可能是踏入机器学习世界的第一步吧，它教你如何做最简单的预测和机器学习比较本质的思维。前几周学习的知识大多是看李宏毅的视频，前几周感觉还是不错的。从线性回归开始，学到了基本的`梯度下降`思想和度量性能的`代价函数`。\n\n- [Error](http://www.bilibili.com/video/av10590361/#page=2)，第二节就是深入理解各种模型评估的知识，讲授了`误差`,`偏差`,`方差`的区别与联系。\n\n- [Gradient Descent](http://www.bilibili.com/video/av10590361/#page=3)，最后是深入学习梯度下降，学习推导基本的梯度下降，然后提出`随机梯度下降(SGD)`，从大量数据中随机选择一定量数据来训练，提高学习效率。除此之外，讲解了梯度下降的问题：学习率的选择。然后基于此讲解了一个算法`Adagrad`来控制学习率。\n\n- 最后还有一些比较杂的知识，了解了[K折交叉验证](https://github.com/basicv8vc/Python-Machine-Learning-zh/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_section2.md)的思想与作用，把数据集分割为训练集，验证集，测试集的思想与作用。各种[距离度量](http://blog.csdn.net/shiwei408/article/details/7602324)，可以衡量样本近似度。最后完成两个作业\n\n图像知识可能在第一周学习，有点不知其有何用的感觉，就算想在思想上重视它，但没有实际用起来，还是难以深刻理解它的重要性吧。谈点个人感受，我其实挺不擅长也不太喜欢处理图像的，大一自己有简单接触过图像处理（跟现在的学的不太一样，而是常规的图像处理，不跟特征，知识等内容关联），虽然不比这些难，但也很吃力。\n\n## 第二周\n\n第二周主要学习的是`分类`的基础算法，分别学习`K近邻`,`决策树`,`逻辑斯蒂回归`：\n\n- [KNN](http://cs231n.github.io/classification/)的思想就是把某个样本跟其他所有样本进行距离度量并总和，该样本离哪个类别'最近'，就标记为该类别。KNN是`懒惰学习`的典型算法，即到需要分类的时候才使用上训练集。在学习KNN的时候还了解到矢量化编程的重要性，减少不必要的python for 循环可以利于底层numpy优化为并行代码，在我这次实验里速度提升了近百倍。\n\n- [Logistic Regression](https://www.bilibili.com/video/av10590361/#page=5) 该算法跟线性回归（跟感知器也类似）基本类似，不过它加入了`sigmoid`函数来进行分类而不是回归。后来学习`深度学习`才知道这里有`神经网络`的最基本的思想，或者说可能是最简单的神经网络了。\n\n- [Decision Tree](https://www.bilibili.com/video/av12469267/#page=34)决策树可能是到这周为止最难的算法了，写起来会特别长。思想其实很简单，就是树的思想 + 人类决策过程。常用的决策树有`ID3`,`C4.5`,`C5.0`,`CART`等，不过我只编写了最简单的ID3，其他决策树进行了简单的了解。学习过程中认识到如果生成完整的决策树，那会变得非常耗时，后面学习到剪枝知识（我在作业里面编写`预剪枝`了，不过效果很差）。学习决策树里面知道了一些信息论的知识，如`信息熵`,`信息增益`,`纯度`等知识，决策的依据便是依据这些数值来找到最佳决策特征。\n\n最后根据学到的知识完成一个井字棋胜负预测，不过我的模型很一般。这周的知识量不是很大，更多侧重机器学习基础编程，但是感觉学到东西很多的一周。\n\n## 第三周\n\n这周学习的机器学习非常强大和实用，是现在也很常用的模型：\n\n- [SVM](https://www.bilibili.com/video/av9770190/index_27.html#page=20)非常理论，学到这里，我感觉我的高数白学了。其实现在我也不是很了解SVM，只对基本概念有了解。基本思想应该是把低维空间的非线性问题映射到高维空间线性问题来解决。然后里面概念非常多：支持向量的概念，距离度量，核函数，核方法，对偶问题，KKT等。\n\n- [集成学习](https://www.bilibili.com/video/av10590361/index_22.html#page=22)非常实用且广用。许多一般模型集成后都可以大幅度提升性能。这周接触了许多集成学习算法：\n    - `bagging`，非常简单的集成学习算法，我后来实现了bagging决策树，性能提升了许多。基本思想是`自助采样`一些样本后，分别训练n个模型，然后进行投票决策。这样可以大大减少过拟合而提升性能。\n    \n    - `Random Forest`，bagging算法的变体，基于决策树实现的。它与bagging的区别在于特化了决策树，在节点决策时，加入`属性扰动`（即只从一部分特征里选择最优特征），而bagging只有`样本扰动`（随机采集样本）。它的性能一般来说比bagging要好，我猜大概是加入了新的扰动后，更能避免决策树容易过拟合的缺点吧。\n    \n    - 其他如 `boosting`的`adboost`和`xgboost`，进行了简单了解，xgboost在kaggle里面很热门，因为性能特别好。不过这几个算法难度更大，我了解的也比较少。adboost的基本思想是让之前训练错误的部分对应的权重变大，让模型认识到这点。\n     \n- 最后是一点点图像特征的知识[bag of words model](https://gurus.pyimagesearch.com/the-bag-of-visual-words-model/)，对此进行一些了解\n\n## 第四周\n\n这周学习无监督学习，主要是聚类跟降维，不过主要是侧重分析并运用这些技术：\n\n- `聚类`可以按结构特性分为原型聚类，层次聚类，密度聚类。[K-means](https://www.bilibili.com/video/av9912938/#page=78)是最基础的聚类算法，主要思想是通过多次迭代来把刻画原型，来使误差最小。K-means之后是了解了`高斯混合聚类`，也是原型聚类。\n\n- `降维`这部分主要接触了[PCA](https://www.bilibili.com/video/av10590361/index_22.html#page=13)，不过这部分理论特别麻烦，我只搞懂了基本思想，并学会基本运用。总之，它变换了基底，并把比重最小的维度去掉来降维，这样能最大程度的保存原始样本的信息。\n\n这周机器学习的知识就进入进阶难度了，说实话，我掌握的不太会好，不过算是对机器学习的体系更加了解了。除了以上还有一些[其他知识](http://ufldl.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B)，不过比较零碎，我就不一一总结了。\n\n## 第五六七八周\n\n这里把深度学习一起总结了吧，这几周感觉学习的不太好。\n\n第六周开始，陆陆续续有许多高大上的报告可以听讲了，了解了许多前沿的应用，思想，算法。从第五周开始也步入了[深度学习](https://www.bilibili.com/video/av10590361/index_13.html#page=6)的大门。\n\n这几周主要学习`全连接网络`跟`卷积神经网络`跟`循环神经网络`，理解了很久[反向传播](https://www.bilibili.com/video/av10590361/index_13.html#page=7)，[卷积运算](https://www.bilibili.com/video/av10590361/index_13.html#page=10)。其实参考过很多资料，这里就不一一列出了。目前对`反向传播`也有稍微清晰的了解了，对于卷积，了解了其思想，但对其运算还是只有抽象的认识，反向传播可以说是目前神经网络的基础。`全连接网络`在理论上是近似的`图灵机`，不过实用性很差，一般是配合其他网络而使用。而卷积神经网络是针对图像而发明的，在图像处理跟机器视觉应用广泛。而循环神经网络更适用于序列数据，如文本，这在自然语言处理很常用，而由于一般的`RNN`有局限性，所以有一个`LSTM`的变体，这个模型我不是很清楚，但它的表现更好（最近好像又出现一个比较厉害的新变体`SRU`）。\n\n由于神经网络的代码非常难写，写出来也基本不可以重用，我们学习了`keras`这个基于`tensorflow`的深度学习框架来实现一些经典的模型。后来应用keras解决了一些基本的图像分类问题。\n\n第七八周陆陆续续的讲座也应该提一提，感觉大大开阔了我的视野。原来我以为深度学习基本都是在对图像上进行工作，好像这样也没什么意思。不过后来发现图像几乎是实现人工智能最基本的办法。而老师们的方向五花八门，问题的复杂度也远超过我的脑容量，深度学习反而变成了实现人工智能的基本工具而已，更多在于对于问题的深入研究和对特征的深入探究。\n\n这几周的学习积极性变得比较差劲了，不过收获还是很多。至少认识到机器学习跟深度学习的基本思想，我觉得未来的程序员都或多或少需要了解这些知识，因为他们可能会用到相应的算法来部署一些人工智能应用到各种设备、各种网站、各种系统中去，而懂得这些知识的人显然能在工作中更胜一筹。\n\n## 总结\n\n以上大概就是我的总结了，很粗略，也没有讲到具体的数学知识，更多是讲到自己的小小收获跟感受。我不清楚以后是否会从事机器学习相关的工作，但我以后肯定会抱着好奇心继续完善我对这些知识认识，了解里面的新思想，跟上人工智能的潮流，做一个终身学习的人吧。\n","slug":"暑假机器学习总结","published":1,"updated":"2017-09-24T11:34:31.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y9p00126svstzbmta1t","content":"<h1 id=\"机器学习学习总结\"><a href=\"#机器学习学习总结\" class=\"headerlink\" title=\"机器学习学习总结\"></a>机器学习学习总结</h1><p>经过两个月的学习，从对机器学习一点点懵懂认知，到现在对机器学习的基础知识跟体系有一定的认知。如今学习暂告一段落，总结如今学习过的重点知识，可以起到很好的复习作业，也是对两个月以来的交代。以下，我将按照每周学习进度来总结回顾机器学习的知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"第一周\"><a href=\"#第一周\" class=\"headerlink\" title=\"第一周\"></a>第一周</h2><p>我们先学习了<code>python</code>编程基础，之后的学习是基于python各种库来实验的。我之前已经比较熟悉python，所以很快就完成这段学习；之后接触<code>numpy</code>，这是C语言为python编写的底层矩阵库，我之前也接触过，但比较浅，不过numpy封装的很好，用起来门槛也很低，很快就上手了；numpy之后就是<code>pandas</code>,它是数据分析常用的库，基于numpy，非常全面，我之前也用过，但基本需要重新学习，pandas比较难用，尤其是IO部分，有细粒度的操作，文档看起来也比较麻烦，没有示例，所以学习的过程中，是遇到问题再去查找方法，后面的学习pandas其实用到的也比较少。</p>\n<p>以上内容大概花了两天，算是对机器学习的预备知识的准备。当然期间也学习了简单的使用anaconda，jupyter等工具，不再一一总结了。</p>\n<p>之后开始学习基本的图像知识：</p>\n<ul>\n<li><a href=\"http://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E7%9B%B4%E6%96%B9%E5%9B%BE\" target=\"_blank\" rel=\"noopener\">颜色直方图</a>,它所描述的是不同色彩在整幅图像中所占的比例，而并不关心每种色彩所处的空间位置。之后有几次作业中要编写颜色直方图的处理，一开始还是挺棘手的。不过跟后来的图像特征提取就是小巫见大巫了</li>\n<li><a href=\"http://blog.csdn.net/zouxy09/article/details/7929348\" target=\"_blank\" rel=\"noopener\">HOG特征</a>，主要思想：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。这也是之后的需要实现的任务，学习过程中，只有这个博客资料可以参考，其他资料要么可能是全英文晦涩难懂，要么还不如这个。这个博客写的太精炼了，初学的时候，实现起来非常困难，以至于有些同学对<code>根据这个博客写出算法</code>的可能性产生怀疑。我这周的作业也卡在这里了，学习机器学习的时候反而是因为图像处理知识不过关。后来经过讲解对这些特征有更新的认识了，不过可能实现起来对于现在我的依然有些困难。</li>\n<li><a href=\"http://blog.csdn.net/zouxy09/article/details/7929531\" target=\"_blank\" rel=\"noopener\">LBP特征</a>、<a href=\"http://blog.csdn.net/zouxy09/article/details/7929570\" target=\"_blank\" rel=\"noopener\">Haar特征</a>也是这周的基础知识，我稍微学习了下LBP，发现比HOG要好懂，Haar并没有怎么看，最后这2个内容没有出现在作业里，我对这些也只有粗浅的认识。<code>LBP</code>（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。而<code>Haar</code>特征值反映了图像的灰度变化情况。</li>\n</ul>\n<p>图像的部分内容学习后，开始了最基础的机器学习的内容：</p>\n<ul>\n<li><p><a href=\"http://www.bilibili.com/video/av10590361/\" target=\"_blank\" rel=\"noopener\">Regression</a>，先从最简单的<code>线性回归</code>开始，线性回归可能是踏入机器学习世界的第一步吧，它教你如何做最简单的预测和机器学习比较本质的思维。前几周学习的知识大多是看李宏毅的视频，前几周感觉还是不错的。从线性回归开始，学到了基本的<code>梯度下降</code>思想和度量性能的<code>代价函数</code>。</p>\n</li>\n<li><p><a href=\"http://www.bilibili.com/video/av10590361/#page=2\" target=\"_blank\" rel=\"noopener\">Error</a>，第二节就是深入理解各种模型评估的知识，讲授了<code>误差</code>,<code>偏差</code>,<code>方差</code>的区别与联系。</p>\n</li>\n<li><p><a href=\"http://www.bilibili.com/video/av10590361/#page=3\" target=\"_blank\" rel=\"noopener\">Gradient Descent</a>，最后是深入学习梯度下降，学习推导基本的梯度下降，然后提出<code>随机梯度下降(SGD)</code>，从大量数据中随机选择一定量数据来训练，提高学习效率。除此之外，讲解了梯度下降的问题：学习率的选择。然后基于此讲解了一个算法<code>Adagrad</code>来控制学习率。</p>\n</li>\n<li><p>最后还有一些比较杂的知识，了解了<a href=\"https://github.com/basicv8vc/Python-Machine-Learning-zh/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_section2.md\" target=\"_blank\" rel=\"noopener\">K折交叉验证</a>的思想与作用，把数据集分割为训练集，验证集，测试集的思想与作用。各种<a href=\"http://blog.csdn.net/shiwei408/article/details/7602324\" target=\"_blank\" rel=\"noopener\">距离度量</a>，可以衡量样本近似度。最后完成两个作业</p>\n</li>\n</ul>\n<p>图像知识可能在第一周学习，有点不知其有何用的感觉，就算想在思想上重视它，但没有实际用起来，还是难以深刻理解它的重要性吧。谈点个人感受，我其实挺不擅长也不太喜欢处理图像的，大一自己有简单接触过图像处理（跟现在的学的不太一样，而是常规的图像处理，不跟特征，知识等内容关联），虽然不比这些难，但也很吃力。</p>\n<h2 id=\"第二周\"><a href=\"#第二周\" class=\"headerlink\" title=\"第二周\"></a>第二周</h2><p>第二周主要学习的是<code>分类</code>的基础算法，分别学习<code>K近邻</code>,<code>决策树</code>,<code>逻辑斯蒂回归</code>：</p>\n<ul>\n<li><p><a href=\"http://cs231n.github.io/classification/\" target=\"_blank\" rel=\"noopener\">KNN</a>的思想就是把某个样本跟其他所有样本进行距离度量并总和，该样本离哪个类别’最近’，就标记为该类别。KNN是<code>懒惰学习</code>的典型算法，即到需要分类的时候才使用上训练集。在学习KNN的时候还了解到矢量化编程的重要性，减少不必要的python for 循环可以利于底层numpy优化为并行代码，在我这次实验里速度提升了近百倍。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/av10590361/#page=5\" target=\"_blank\" rel=\"noopener\">Logistic Regression</a> 该算法跟线性回归（跟感知器也类似）基本类似，不过它加入了<code>sigmoid</code>函数来进行分类而不是回归。后来学习<code>深度学习</code>才知道这里有<code>神经网络</code>的最基本的思想，或者说可能是最简单的神经网络了。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/av12469267/#page=34\" target=\"_blank\" rel=\"noopener\">Decision Tree</a>决策树可能是到这周为止最难的算法了，写起来会特别长。思想其实很简单，就是树的思想 + 人类决策过程。常用的决策树有<code>ID3</code>,<code>C4.5</code>,<code>C5.0</code>,<code>CART</code>等，不过我只编写了最简单的ID3，其他决策树进行了简单的了解。学习过程中认识到如果生成完整的决策树，那会变得非常耗时，后面学习到剪枝知识（我在作业里面编写<code>预剪枝</code>了，不过效果很差）。学习决策树里面知道了一些信息论的知识，如<code>信息熵</code>,<code>信息增益</code>,<code>纯度</code>等知识，决策的依据便是依据这些数值来找到最佳决策特征。</p>\n</li>\n</ul>\n<p>最后根据学到的知识完成一个井字棋胜负预测，不过我的模型很一般。这周的知识量不是很大，更多侧重机器学习基础编程，但是感觉学到东西很多的一周。</p>\n<h2 id=\"第三周\"><a href=\"#第三周\" class=\"headerlink\" title=\"第三周\"></a>第三周</h2><p>这周学习的机器学习非常强大和实用，是现在也很常用的模型：</p>\n<ul>\n<li><p><a href=\"https://www.bilibili.com/video/av9770190/index_27.html#page=20\" target=\"_blank\" rel=\"noopener\">SVM</a>非常理论，学到这里，我感觉我的高数白学了。其实现在我也不是很了解SVM，只对基本概念有了解。基本思想应该是把低维空间的非线性问题映射到高维空间线性问题来解决。然后里面概念非常多：支持向量的概念，距离度量，核函数，核方法，对偶问题，KKT等。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/av10590361/index_22.html#page=22\" target=\"_blank\" rel=\"noopener\">集成学习</a>非常实用且广用。许多一般模型集成后都可以大幅度提升性能。这周接触了许多集成学习算法：</p>\n<ul>\n<li><p><code>bagging</code>，非常简单的集成学习算法，我后来实现了bagging决策树，性能提升了许多。基本思想是<code>自助采样</code>一些样本后，分别训练n个模型，然后进行投票决策。这样可以大大减少过拟合而提升性能。</p>\n</li>\n<li><p><code>Random Forest</code>，bagging算法的变体，基于决策树实现的。它与bagging的区别在于特化了决策树，在节点决策时，加入<code>属性扰动</code>（即只从一部分特征里选择最优特征），而bagging只有<code>样本扰动</code>（随机采集样本）。它的性能一般来说比bagging要好，我猜大概是加入了新的扰动后，更能避免决策树容易过拟合的缺点吧。</p>\n</li>\n<li><p>其他如 <code>boosting</code>的<code>adboost</code>和<code>xgboost</code>，进行了简单了解，xgboost在kaggle里面很热门，因为性能特别好。不过这几个算法难度更大，我了解的也比较少。adboost的基本思想是让之前训练错误的部分对应的权重变大，让模型认识到这点。</p>\n</li>\n</ul>\n</li>\n<li><p>最后是一点点图像特征的知识<a href=\"https://gurus.pyimagesearch.com/the-bag-of-visual-words-model/\" target=\"_blank\" rel=\"noopener\">bag of words model</a>，对此进行一些了解</p>\n</li>\n</ul>\n<h2 id=\"第四周\"><a href=\"#第四周\" class=\"headerlink\" title=\"第四周\"></a>第四周</h2><p>这周学习无监督学习，主要是聚类跟降维，不过主要是侧重分析并运用这些技术：</p>\n<ul>\n<li><p><code>聚类</code>可以按结构特性分为原型聚类，层次聚类，密度聚类。<a href=\"https://www.bilibili.com/video/av9912938/#page=78\" target=\"_blank\" rel=\"noopener\">K-means</a>是最基础的聚类算法，主要思想是通过多次迭代来把刻画原型，来使误差最小。K-means之后是了解了<code>高斯混合聚类</code>，也是原型聚类。</p>\n</li>\n<li><p><code>降维</code>这部分主要接触了<a href=\"https://www.bilibili.com/video/av10590361/index_22.html#page=13\" target=\"_blank\" rel=\"noopener\">PCA</a>，不过这部分理论特别麻烦，我只搞懂了基本思想，并学会基本运用。总之，它变换了基底，并把比重最小的维度去掉来降维，这样能最大程度的保存原始样本的信息。</p>\n</li>\n</ul>\n<p>这周机器学习的知识就进入进阶难度了，说实话，我掌握的不太会好，不过算是对机器学习的体系更加了解了。除了以上还有一些<a href=\"http://ufldl.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">其他知识</a>，不过比较零碎，我就不一一总结了。</p>\n<h2 id=\"第五六七八周\"><a href=\"#第五六七八周\" class=\"headerlink\" title=\"第五六七八周\"></a>第五六七八周</h2><p>这里把深度学习一起总结了吧，这几周感觉学习的不太好。</p>\n<p>第六周开始，陆陆续续有许多高大上的报告可以听讲了，了解了许多前沿的应用，思想，算法。从第五周开始也步入了<a href=\"https://www.bilibili.com/video/av10590361/index_13.html#page=6\" target=\"_blank\" rel=\"noopener\">深度学习</a>的大门。</p>\n<p>这几周主要学习<code>全连接网络</code>跟<code>卷积神经网络</code>跟<code>循环神经网络</code>，理解了很久<a href=\"https://www.bilibili.com/video/av10590361/index_13.html#page=7\" target=\"_blank\" rel=\"noopener\">反向传播</a>，<a href=\"https://www.bilibili.com/video/av10590361/index_13.html#page=10\" target=\"_blank\" rel=\"noopener\">卷积运算</a>。其实参考过很多资料，这里就不一一列出了。目前对<code>反向传播</code>也有稍微清晰的了解了，对于卷积，了解了其思想，但对其运算还是只有抽象的认识，反向传播可以说是目前神经网络的基础。<code>全连接网络</code>在理论上是近似的<code>图灵机</code>，不过实用性很差，一般是配合其他网络而使用。而卷积神经网络是针对图像而发明的，在图像处理跟机器视觉应用广泛。而循环神经网络更适用于序列数据，如文本，这在自然语言处理很常用，而由于一般的<code>RNN</code>有局限性，所以有一个<code>LSTM</code>的变体，这个模型我不是很清楚，但它的表现更好（最近好像又出现一个比较厉害的新变体<code>SRU</code>）。</p>\n<p>由于神经网络的代码非常难写，写出来也基本不可以重用，我们学习了<code>keras</code>这个基于<code>tensorflow</code>的深度学习框架来实现一些经典的模型。后来应用keras解决了一些基本的图像分类问题。</p>\n<p>第七八周陆陆续续的讲座也应该提一提，感觉大大开阔了我的视野。原来我以为深度学习基本都是在对图像上进行工作，好像这样也没什么意思。不过后来发现图像几乎是实现人工智能最基本的办法。而老师们的方向五花八门，问题的复杂度也远超过我的脑容量，深度学习反而变成了实现人工智能的基本工具而已，更多在于对于问题的深入研究和对特征的深入探究。</p>\n<p>这几周的学习积极性变得比较差劲了，不过收获还是很多。至少认识到机器学习跟深度学习的基本思想，我觉得未来的程序员都或多或少需要了解这些知识，因为他们可能会用到相应的算法来部署一些人工智能应用到各种设备、各种网站、各种系统中去，而懂得这些知识的人显然能在工作中更胜一筹。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上大概就是我的总结了，很粗略，也没有讲到具体的数学知识，更多是讲到自己的小小收获跟感受。我不清楚以后是否会从事机器学习相关的工作，但我以后肯定会抱着好奇心继续完善我对这些知识认识，了解里面的新思想，跟上人工智能的潮流，做一个终身学习的人吧。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"机器学习学习总结\"><a href=\"#机器学习学习总结\" class=\"headerlink\" title=\"机器学习学习总结\"></a>机器学习学习总结</h1><p>经过两个月的学习，从对机器学习一点点懵懂认知，到现在对机器学习的基础知识跟体系有一定的认知。如今学习暂告一段落，总结如今学习过的重点知识，可以起到很好的复习作业，也是对两个月以来的交代。以下，我将按照每周学习进度来总结回顾机器学习的知识。</p>","more":"<h2 id=\"第一周\"><a href=\"#第一周\" class=\"headerlink\" title=\"第一周\"></a>第一周</h2><p>我们先学习了<code>python</code>编程基础，之后的学习是基于python各种库来实验的。我之前已经比较熟悉python，所以很快就完成这段学习；之后接触<code>numpy</code>，这是C语言为python编写的底层矩阵库，我之前也接触过，但比较浅，不过numpy封装的很好，用起来门槛也很低，很快就上手了；numpy之后就是<code>pandas</code>,它是数据分析常用的库，基于numpy，非常全面，我之前也用过，但基本需要重新学习，pandas比较难用，尤其是IO部分，有细粒度的操作，文档看起来也比较麻烦，没有示例，所以学习的过程中，是遇到问题再去查找方法，后面的学习pandas其实用到的也比较少。</p>\n<p>以上内容大概花了两天，算是对机器学习的预备知识的准备。当然期间也学习了简单的使用anaconda，jupyter等工具，不再一一总结了。</p>\n<p>之后开始学习基本的图像知识：</p>\n<ul>\n<li><a href=\"http://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E7%9B%B4%E6%96%B9%E5%9B%BE\" target=\"_blank\" rel=\"noopener\">颜色直方图</a>,它所描述的是不同色彩在整幅图像中所占的比例，而并不关心每种色彩所处的空间位置。之后有几次作业中要编写颜色直方图的处理，一开始还是挺棘手的。不过跟后来的图像特征提取就是小巫见大巫了</li>\n<li><a href=\"http://blog.csdn.net/zouxy09/article/details/7929348\" target=\"_blank\" rel=\"noopener\">HOG特征</a>，主要思想：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。（本质：梯度的统计信息，而梯度主要存在于边缘的地方）。这也是之后的需要实现的任务，学习过程中，只有这个博客资料可以参考，其他资料要么可能是全英文晦涩难懂，要么还不如这个。这个博客写的太精炼了，初学的时候，实现起来非常困难，以至于有些同学对<code>根据这个博客写出算法</code>的可能性产生怀疑。我这周的作业也卡在这里了，学习机器学习的时候反而是因为图像处理知识不过关。后来经过讲解对这些特征有更新的认识了，不过可能实现起来对于现在我的依然有些困难。</li>\n<li><a href=\"http://blog.csdn.net/zouxy09/article/details/7929531\" target=\"_blank\" rel=\"noopener\">LBP特征</a>、<a href=\"http://blog.csdn.net/zouxy09/article/details/7929570\" target=\"_blank\" rel=\"noopener\">Haar特征</a>也是这周的基础知识，我稍微学习了下LBP，发现比HOG要好懂，Haar并没有怎么看，最后这2个内容没有出现在作业里，我对这些也只有粗浅的认识。<code>LBP</code>（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。而<code>Haar</code>特征值反映了图像的灰度变化情况。</li>\n</ul>\n<p>图像的部分内容学习后，开始了最基础的机器学习的内容：</p>\n<ul>\n<li><p><a href=\"http://www.bilibili.com/video/av10590361/\" target=\"_blank\" rel=\"noopener\">Regression</a>，先从最简单的<code>线性回归</code>开始，线性回归可能是踏入机器学习世界的第一步吧，它教你如何做最简单的预测和机器学习比较本质的思维。前几周学习的知识大多是看李宏毅的视频，前几周感觉还是不错的。从线性回归开始，学到了基本的<code>梯度下降</code>思想和度量性能的<code>代价函数</code>。</p>\n</li>\n<li><p><a href=\"http://www.bilibili.com/video/av10590361/#page=2\" target=\"_blank\" rel=\"noopener\">Error</a>，第二节就是深入理解各种模型评估的知识，讲授了<code>误差</code>,<code>偏差</code>,<code>方差</code>的区别与联系。</p>\n</li>\n<li><p><a href=\"http://www.bilibili.com/video/av10590361/#page=3\" target=\"_blank\" rel=\"noopener\">Gradient Descent</a>，最后是深入学习梯度下降，学习推导基本的梯度下降，然后提出<code>随机梯度下降(SGD)</code>，从大量数据中随机选择一定量数据来训练，提高学习效率。除此之外，讲解了梯度下降的问题：学习率的选择。然后基于此讲解了一个算法<code>Adagrad</code>来控制学习率。</p>\n</li>\n<li><p>最后还有一些比较杂的知识，了解了<a href=\"https://github.com/basicv8vc/Python-Machine-Learning-zh/blob/master/%E7%AC%AC%E5%85%AD%E7%AB%A0/ch6_section2.md\" target=\"_blank\" rel=\"noopener\">K折交叉验证</a>的思想与作用，把数据集分割为训练集，验证集，测试集的思想与作用。各种<a href=\"http://blog.csdn.net/shiwei408/article/details/7602324\" target=\"_blank\" rel=\"noopener\">距离度量</a>，可以衡量样本近似度。最后完成两个作业</p>\n</li>\n</ul>\n<p>图像知识可能在第一周学习，有点不知其有何用的感觉，就算想在思想上重视它，但没有实际用起来，还是难以深刻理解它的重要性吧。谈点个人感受，我其实挺不擅长也不太喜欢处理图像的，大一自己有简单接触过图像处理（跟现在的学的不太一样，而是常规的图像处理，不跟特征，知识等内容关联），虽然不比这些难，但也很吃力。</p>\n<h2 id=\"第二周\"><a href=\"#第二周\" class=\"headerlink\" title=\"第二周\"></a>第二周</h2><p>第二周主要学习的是<code>分类</code>的基础算法，分别学习<code>K近邻</code>,<code>决策树</code>,<code>逻辑斯蒂回归</code>：</p>\n<ul>\n<li><p><a href=\"http://cs231n.github.io/classification/\" target=\"_blank\" rel=\"noopener\">KNN</a>的思想就是把某个样本跟其他所有样本进行距离度量并总和，该样本离哪个类别’最近’，就标记为该类别。KNN是<code>懒惰学习</code>的典型算法，即到需要分类的时候才使用上训练集。在学习KNN的时候还了解到矢量化编程的重要性，减少不必要的python for 循环可以利于底层numpy优化为并行代码，在我这次实验里速度提升了近百倍。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/av10590361/#page=5\" target=\"_blank\" rel=\"noopener\">Logistic Regression</a> 该算法跟线性回归（跟感知器也类似）基本类似，不过它加入了<code>sigmoid</code>函数来进行分类而不是回归。后来学习<code>深度学习</code>才知道这里有<code>神经网络</code>的最基本的思想，或者说可能是最简单的神经网络了。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/av12469267/#page=34\" target=\"_blank\" rel=\"noopener\">Decision Tree</a>决策树可能是到这周为止最难的算法了，写起来会特别长。思想其实很简单，就是树的思想 + 人类决策过程。常用的决策树有<code>ID3</code>,<code>C4.5</code>,<code>C5.0</code>,<code>CART</code>等，不过我只编写了最简单的ID3，其他决策树进行了简单的了解。学习过程中认识到如果生成完整的决策树，那会变得非常耗时，后面学习到剪枝知识（我在作业里面编写<code>预剪枝</code>了，不过效果很差）。学习决策树里面知道了一些信息论的知识，如<code>信息熵</code>,<code>信息增益</code>,<code>纯度</code>等知识，决策的依据便是依据这些数值来找到最佳决策特征。</p>\n</li>\n</ul>\n<p>最后根据学到的知识完成一个井字棋胜负预测，不过我的模型很一般。这周的知识量不是很大，更多侧重机器学习基础编程，但是感觉学到东西很多的一周。</p>\n<h2 id=\"第三周\"><a href=\"#第三周\" class=\"headerlink\" title=\"第三周\"></a>第三周</h2><p>这周学习的机器学习非常强大和实用，是现在也很常用的模型：</p>\n<ul>\n<li><p><a href=\"https://www.bilibili.com/video/av9770190/index_27.html#page=20\" target=\"_blank\" rel=\"noopener\">SVM</a>非常理论，学到这里，我感觉我的高数白学了。其实现在我也不是很了解SVM，只对基本概念有了解。基本思想应该是把低维空间的非线性问题映射到高维空间线性问题来解决。然后里面概念非常多：支持向量的概念，距离度量，核函数，核方法，对偶问题，KKT等。</p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/av10590361/index_22.html#page=22\" target=\"_blank\" rel=\"noopener\">集成学习</a>非常实用且广用。许多一般模型集成后都可以大幅度提升性能。这周接触了许多集成学习算法：</p>\n<ul>\n<li><p><code>bagging</code>，非常简单的集成学习算法，我后来实现了bagging决策树，性能提升了许多。基本思想是<code>自助采样</code>一些样本后，分别训练n个模型，然后进行投票决策。这样可以大大减少过拟合而提升性能。</p>\n</li>\n<li><p><code>Random Forest</code>，bagging算法的变体，基于决策树实现的。它与bagging的区别在于特化了决策树，在节点决策时，加入<code>属性扰动</code>（即只从一部分特征里选择最优特征），而bagging只有<code>样本扰动</code>（随机采集样本）。它的性能一般来说比bagging要好，我猜大概是加入了新的扰动后，更能避免决策树容易过拟合的缺点吧。</p>\n</li>\n<li><p>其他如 <code>boosting</code>的<code>adboost</code>和<code>xgboost</code>，进行了简单了解，xgboost在kaggle里面很热门，因为性能特别好。不过这几个算法难度更大，我了解的也比较少。adboost的基本思想是让之前训练错误的部分对应的权重变大，让模型认识到这点。</p>\n</li>\n</ul>\n</li>\n<li><p>最后是一点点图像特征的知识<a href=\"https://gurus.pyimagesearch.com/the-bag-of-visual-words-model/\" target=\"_blank\" rel=\"noopener\">bag of words model</a>，对此进行一些了解</p>\n</li>\n</ul>\n<h2 id=\"第四周\"><a href=\"#第四周\" class=\"headerlink\" title=\"第四周\"></a>第四周</h2><p>这周学习无监督学习，主要是聚类跟降维，不过主要是侧重分析并运用这些技术：</p>\n<ul>\n<li><p><code>聚类</code>可以按结构特性分为原型聚类，层次聚类，密度聚类。<a href=\"https://www.bilibili.com/video/av9912938/#page=78\" target=\"_blank\" rel=\"noopener\">K-means</a>是最基础的聚类算法，主要思想是通过多次迭代来把刻画原型，来使误差最小。K-means之后是了解了<code>高斯混合聚类</code>，也是原型聚类。</p>\n</li>\n<li><p><code>降维</code>这部分主要接触了<a href=\"https://www.bilibili.com/video/av10590361/index_22.html#page=13\" target=\"_blank\" rel=\"noopener\">PCA</a>，不过这部分理论特别麻烦，我只搞懂了基本思想，并学会基本运用。总之，它变换了基底，并把比重最小的维度去掉来降维，这样能最大程度的保存原始样本的信息。</p>\n</li>\n</ul>\n<p>这周机器学习的知识就进入进阶难度了，说实话，我掌握的不太会好，不过算是对机器学习的体系更加了解了。除了以上还有一些<a href=\"http://ufldl.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">其他知识</a>，不过比较零碎，我就不一一总结了。</p>\n<h2 id=\"第五六七八周\"><a href=\"#第五六七八周\" class=\"headerlink\" title=\"第五六七八周\"></a>第五六七八周</h2><p>这里把深度学习一起总结了吧，这几周感觉学习的不太好。</p>\n<p>第六周开始，陆陆续续有许多高大上的报告可以听讲了，了解了许多前沿的应用，思想，算法。从第五周开始也步入了<a href=\"https://www.bilibili.com/video/av10590361/index_13.html#page=6\" target=\"_blank\" rel=\"noopener\">深度学习</a>的大门。</p>\n<p>这几周主要学习<code>全连接网络</code>跟<code>卷积神经网络</code>跟<code>循环神经网络</code>，理解了很久<a href=\"https://www.bilibili.com/video/av10590361/index_13.html#page=7\" target=\"_blank\" rel=\"noopener\">反向传播</a>，<a href=\"https://www.bilibili.com/video/av10590361/index_13.html#page=10\" target=\"_blank\" rel=\"noopener\">卷积运算</a>。其实参考过很多资料，这里就不一一列出了。目前对<code>反向传播</code>也有稍微清晰的了解了，对于卷积，了解了其思想，但对其运算还是只有抽象的认识，反向传播可以说是目前神经网络的基础。<code>全连接网络</code>在理论上是近似的<code>图灵机</code>，不过实用性很差，一般是配合其他网络而使用。而卷积神经网络是针对图像而发明的，在图像处理跟机器视觉应用广泛。而循环神经网络更适用于序列数据，如文本，这在自然语言处理很常用，而由于一般的<code>RNN</code>有局限性，所以有一个<code>LSTM</code>的变体，这个模型我不是很清楚，但它的表现更好（最近好像又出现一个比较厉害的新变体<code>SRU</code>）。</p>\n<p>由于神经网络的代码非常难写，写出来也基本不可以重用，我们学习了<code>keras</code>这个基于<code>tensorflow</code>的深度学习框架来实现一些经典的模型。后来应用keras解决了一些基本的图像分类问题。</p>\n<p>第七八周陆陆续续的讲座也应该提一提，感觉大大开阔了我的视野。原来我以为深度学习基本都是在对图像上进行工作，好像这样也没什么意思。不过后来发现图像几乎是实现人工智能最基本的办法。而老师们的方向五花八门，问题的复杂度也远超过我的脑容量，深度学习反而变成了实现人工智能的基本工具而已，更多在于对于问题的深入研究和对特征的深入探究。</p>\n<p>这几周的学习积极性变得比较差劲了，不过收获还是很多。至少认识到机器学习跟深度学习的基本思想，我觉得未来的程序员都或多或少需要了解这些知识，因为他们可能会用到相应的算法来部署一些人工智能应用到各种设备、各种网站、各种系统中去，而懂得这些知识的人显然能在工作中更胜一筹。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上大概就是我的总结了，很粗略，也没有讲到具体的数学知识，更多是讲到自己的小小收获跟感受。我不清楚以后是否会从事机器学习相关的工作，但我以后肯定会抱着好奇心继续完善我对这些知识认识，了解里面的新思想，跟上人工智能的潮流，做一个终身学习的人吧。</p>"},{"title":"《Web API的设计与开发》读书笔记","date":"2017-08-08T04:11:10.000Z","_content":"# 第1章 什么是 Web API\n\n## Web API 的重要性\n\n一些在线服务能够对那些公开的API进行会话控制、访问控制、服务分析，提供面向用户的仪表盘，以及发布文档等，承接了各种各样的工作。\n\n通过对外公开 Web API，同外部其他服务的集成变得更加便捷，并从中衍生出了新的价值，使在线服务以及业务不断发展，逐步形成了“API经济学”的景象，并在这几年受到相当大的关注。\n\n## 各种各样的 API 模式\n\n* 将已发布的 Web 在线服务的数据或功能通过 API 公开\n* 将附加在其他网页上的微件公开\n* 构建现代 Web 应用\n* 开发智能手机应用\n* 公司内部多个系统的集成\n\n## 应该通过 API 公开什么\n\n* 最简洁的答案是将你的在线服务所能做的事情全部通过API公开\n* 不存在彻底屏蔽搜集信息的行为，所以无需担心盗用，公开 API并不意味着毫无限制的访问\n* 公开 API 将原来的服务组合成新的应用来为用户提供服务的“间接销售”模式\n\n## 设计优美 API 的重要性\n\n* 易于使用\n* 便于更改\n* 健壮性好\n* 不怕公之于众\n\n## 如何美化 Web API\n\n两个重要原则：\n\n* 设计规范明确的内容必须遵守相关规范\n* 没有设计规范的内容必须遵守相关事实标准\n\n## REST 与 Web API\n\nREST 依次一般指下面两种意思：\n\n* 符合 Fielding 的 REST 架构风格的Web服务系统\n* 符合 RPC风格的 XML (或JSON) + HTTP 接口的系统(不使用SOAP)\n\n## 小结\n\n* 如果尚未公开 Web AP，则应立即考虑公开\n* 设计优美的 Web API\n* 不用过分拘泥于 REST 一词\n\n","source":"_posts/《Web API的设计与开发》读书笔记.md","raw":"---\ntitle: 《Web API的设计与开发》读书笔记\ndate: 2017-08-08 12:11:10\ntags: web\ncategory: study\n---\n# 第1章 什么是 Web API\n\n## Web API 的重要性\n\n一些在线服务能够对那些公开的API进行会话控制、访问控制、服务分析，提供面向用户的仪表盘，以及发布文档等，承接了各种各样的工作。\n\n通过对外公开 Web API，同外部其他服务的集成变得更加便捷，并从中衍生出了新的价值，使在线服务以及业务不断发展，逐步形成了“API经济学”的景象，并在这几年受到相当大的关注。\n\n## 各种各样的 API 模式\n\n* 将已发布的 Web 在线服务的数据或功能通过 API 公开\n* 将附加在其他网页上的微件公开\n* 构建现代 Web 应用\n* 开发智能手机应用\n* 公司内部多个系统的集成\n\n## 应该通过 API 公开什么\n\n* 最简洁的答案是将你的在线服务所能做的事情全部通过API公开\n* 不存在彻底屏蔽搜集信息的行为，所以无需担心盗用，公开 API并不意味着毫无限制的访问\n* 公开 API 将原来的服务组合成新的应用来为用户提供服务的“间接销售”模式\n\n## 设计优美 API 的重要性\n\n* 易于使用\n* 便于更改\n* 健壮性好\n* 不怕公之于众\n\n## 如何美化 Web API\n\n两个重要原则：\n\n* 设计规范明确的内容必须遵守相关规范\n* 没有设计规范的内容必须遵守相关事实标准\n\n## REST 与 Web API\n\nREST 依次一般指下面两种意思：\n\n* 符合 Fielding 的 REST 架构风格的Web服务系统\n* 符合 RPC风格的 XML (或JSON) + HTTP 接口的系统(不使用SOAP)\n\n## 小结\n\n* 如果尚未公开 Web AP，则应立即考虑公开\n* 设计优美的 Web API\n* 不用过分拘泥于 REST 一词\n\n","slug":"《Web API的设计与开发》读书笔记","published":1,"updated":"2017-09-19T14:59:46.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y9s00156svstfntig1c","content":"<h1 id=\"第1章-什么是-Web-API\"><a href=\"#第1章-什么是-Web-API\" class=\"headerlink\" title=\"第1章 什么是 Web API\"></a>第1章 什么是 Web API</h1><h2 id=\"Web-API-的重要性\"><a href=\"#Web-API-的重要性\" class=\"headerlink\" title=\"Web API 的重要性\"></a>Web API 的重要性</h2><p>一些在线服务能够对那些公开的API进行会话控制、访问控制、服务分析，提供面向用户的仪表盘，以及发布文档等，承接了各种各样的工作。</p>\n<p>通过对外公开 Web API，同外部其他服务的集成变得更加便捷，并从中衍生出了新的价值，使在线服务以及业务不断发展，逐步形成了“API经济学”的景象，并在这几年受到相当大的关注。</p>\n<h2 id=\"各种各样的-API-模式\"><a href=\"#各种各样的-API-模式\" class=\"headerlink\" title=\"各种各样的 API 模式\"></a>各种各样的 API 模式</h2><ul>\n<li>将已发布的 Web 在线服务的数据或功能通过 API 公开</li>\n<li>将附加在其他网页上的微件公开</li>\n<li>构建现代 Web 应用</li>\n<li>开发智能手机应用</li>\n<li>公司内部多个系统的集成</li>\n</ul>\n<h2 id=\"应该通过-API-公开什么\"><a href=\"#应该通过-API-公开什么\" class=\"headerlink\" title=\"应该通过 API 公开什么\"></a>应该通过 API 公开什么</h2><ul>\n<li>最简洁的答案是将你的在线服务所能做的事情全部通过API公开</li>\n<li>不存在彻底屏蔽搜集信息的行为，所以无需担心盗用，公开 API并不意味着毫无限制的访问</li>\n<li>公开 API 将原来的服务组合成新的应用来为用户提供服务的“间接销售”模式</li>\n</ul>\n<h2 id=\"设计优美-API-的重要性\"><a href=\"#设计优美-API-的重要性\" class=\"headerlink\" title=\"设计优美 API 的重要性\"></a>设计优美 API 的重要性</h2><ul>\n<li>易于使用</li>\n<li>便于更改</li>\n<li>健壮性好</li>\n<li>不怕公之于众</li>\n</ul>\n<h2 id=\"如何美化-Web-API\"><a href=\"#如何美化-Web-API\" class=\"headerlink\" title=\"如何美化 Web API\"></a>如何美化 Web API</h2><p>两个重要原则：</p>\n<ul>\n<li>设计规范明确的内容必须遵守相关规范</li>\n<li>没有设计规范的内容必须遵守相关事实标准</li>\n</ul>\n<h2 id=\"REST-与-Web-API\"><a href=\"#REST-与-Web-API\" class=\"headerlink\" title=\"REST 与 Web API\"></a>REST 与 Web API</h2><p>REST 依次一般指下面两种意思：</p>\n<ul>\n<li>符合 Fielding 的 REST 架构风格的Web服务系统</li>\n<li>符合 RPC风格的 XML (或JSON) + HTTP 接口的系统(不使用SOAP)</li>\n</ul>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>如果尚未公开 Web AP，则应立即考虑公开</li>\n<li>设计优美的 Web API</li>\n<li>不用过分拘泥于 REST 一词</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第1章-什么是-Web-API\"><a href=\"#第1章-什么是-Web-API\" class=\"headerlink\" title=\"第1章 什么是 Web API\"></a>第1章 什么是 Web API</h1><h2 id=\"Web-API-的重要性\"><a href=\"#Web-API-的重要性\" class=\"headerlink\" title=\"Web API 的重要性\"></a>Web API 的重要性</h2><p>一些在线服务能够对那些公开的API进行会话控制、访问控制、服务分析，提供面向用户的仪表盘，以及发布文档等，承接了各种各样的工作。</p>\n<p>通过对外公开 Web API，同外部其他服务的集成变得更加便捷，并从中衍生出了新的价值，使在线服务以及业务不断发展，逐步形成了“API经济学”的景象，并在这几年受到相当大的关注。</p>\n<h2 id=\"各种各样的-API-模式\"><a href=\"#各种各样的-API-模式\" class=\"headerlink\" title=\"各种各样的 API 模式\"></a>各种各样的 API 模式</h2><ul>\n<li>将已发布的 Web 在线服务的数据或功能通过 API 公开</li>\n<li>将附加在其他网页上的微件公开</li>\n<li>构建现代 Web 应用</li>\n<li>开发智能手机应用</li>\n<li>公司内部多个系统的集成</li>\n</ul>\n<h2 id=\"应该通过-API-公开什么\"><a href=\"#应该通过-API-公开什么\" class=\"headerlink\" title=\"应该通过 API 公开什么\"></a>应该通过 API 公开什么</h2><ul>\n<li>最简洁的答案是将你的在线服务所能做的事情全部通过API公开</li>\n<li>不存在彻底屏蔽搜集信息的行为，所以无需担心盗用，公开 API并不意味着毫无限制的访问</li>\n<li>公开 API 将原来的服务组合成新的应用来为用户提供服务的“间接销售”模式</li>\n</ul>\n<h2 id=\"设计优美-API-的重要性\"><a href=\"#设计优美-API-的重要性\" class=\"headerlink\" title=\"设计优美 API 的重要性\"></a>设计优美 API 的重要性</h2><ul>\n<li>易于使用</li>\n<li>便于更改</li>\n<li>健壮性好</li>\n<li>不怕公之于众</li>\n</ul>\n<h2 id=\"如何美化-Web-API\"><a href=\"#如何美化-Web-API\" class=\"headerlink\" title=\"如何美化 Web API\"></a>如何美化 Web API</h2><p>两个重要原则：</p>\n<ul>\n<li>设计规范明确的内容必须遵守相关规范</li>\n<li>没有设计规范的内容必须遵守相关事实标准</li>\n</ul>\n<h2 id=\"REST-与-Web-API\"><a href=\"#REST-与-Web-API\" class=\"headerlink\" title=\"REST 与 Web API\"></a>REST 与 Web API</h2><p>REST 依次一般指下面两种意思：</p>\n<ul>\n<li>符合 Fielding 的 REST 架构风格的Web服务系统</li>\n<li>符合 RPC风格的 XML (或JSON) + HTTP 接口的系统(不使用SOAP)</li>\n</ul>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>如果尚未公开 Web AP，则应立即考虑公开</li>\n<li>设计优美的 Web API</li>\n<li>不用过分拘泥于 REST 一词</li>\n</ul>\n"},{"title":"欢迎，刚搭建好的博客","date":"2017-08-08T01:11:10.000Z","_content":"# 分享知识与见解\n\n## 博客搭建的过程\n\n照理说用hexo搭建博客是一分钟的事情，结果我花了6小时，其中绝大部分时间花在了主题上面，想找个能写数学公式的主题不容易啊，又要符合自己的审美，而且文档要齐全没有bug。\n最后找到了这个，但是文档还是不够详解，有些功能不知道如何使用，但暂且将就下吧。这个主题自带了mathjax，不过我还没有测试过能不能写公式，我现在就来测试\n\n$ (\\frac{1}{2})^2 = \\frac{1}{4} $\n\n顺便测试下代码效果吧\n\n```js\nclass Person{\n    constructor(name, age){\n        this.name = name\n        this.age = age\n    }\n}\n\nlet person = new Person('yjh', 20)\n```\n\n我把这个博客发了一下，看见真的可以写公式了，很开心，但这6个小时的苦大概是说不清了，而现在已经9点多了，我应该要继续学习无监督学习了。暂且这样吧，回去再折腾折腾，现在赶紧发个url给同学来测试下效果吧！\n","source":"_posts/欢迎，刚搭建好的博客.md","raw":"---\ntitle: 欢迎，刚搭建好的博客\ndate: 2017-08-08 09:11:10\ntags: life\ncategory: life\n---\n# 分享知识与见解\n\n## 博客搭建的过程\n\n照理说用hexo搭建博客是一分钟的事情，结果我花了6小时，其中绝大部分时间花在了主题上面，想找个能写数学公式的主题不容易啊，又要符合自己的审美，而且文档要齐全没有bug。\n最后找到了这个，但是文档还是不够详解，有些功能不知道如何使用，但暂且将就下吧。这个主题自带了mathjax，不过我还没有测试过能不能写公式，我现在就来测试\n\n$ (\\frac{1}{2})^2 = \\frac{1}{4} $\n\n顺便测试下代码效果吧\n\n```js\nclass Person{\n    constructor(name, age){\n        this.name = name\n        this.age = age\n    }\n}\n\nlet person = new Person('yjh', 20)\n```\n\n我把这个博客发了一下，看见真的可以写公式了，很开心，但这6个小时的苦大概是说不清了，而现在已经9点多了，我应该要继续学习无监督学习了。暂且这样吧，回去再折腾折腾，现在赶紧发个url给同学来测试下效果吧！\n","slug":"欢迎，刚搭建好的博客","published":1,"updated":"2017-10-24T09:26:44.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5y9w00196svs4vs7vyhy","content":"<h1 id=\"分享知识与见解\"><a href=\"#分享知识与见解\" class=\"headerlink\" title=\"分享知识与见解\"></a>分享知识与见解</h1><h2 id=\"博客搭建的过程\"><a href=\"#博客搭建的过程\" class=\"headerlink\" title=\"博客搭建的过程\"></a>博客搭建的过程</h2><p>照理说用hexo搭建博客是一分钟的事情，结果我花了6小时，其中绝大部分时间花在了主题上面，想找个能写数学公式的主题不容易啊，又要符合自己的审美，而且文档要齐全没有bug。<br>最后找到了这个，但是文档还是不够详解，有些功能不知道如何使用，但暂且将就下吧。这个主题自带了mathjax，不过我还没有测试过能不能写公式，我现在就来测试</p>\n<p>$ (\\frac{1}{2})^2 = \\frac{1}{4} $</p>\n<p>顺便测试下代码效果吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name, age)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'yjh'</span>, <span class=\"number\">20</span>)</div></pre></td></tr></table></figure>\n<p>我把这个博客发了一下，看见真的可以写公式了，很开心，但这6个小时的苦大概是说不清了，而现在已经9点多了，我应该要继续学习无监督学习了。暂且这样吧，回去再折腾折腾，现在赶紧发个url给同学来测试下效果吧！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"分享知识与见解\"><a href=\"#分享知识与见解\" class=\"headerlink\" title=\"分享知识与见解\"></a>分享知识与见解</h1><h2 id=\"博客搭建的过程\"><a href=\"#博客搭建的过程\" class=\"headerlink\" title=\"博客搭建的过程\"></a>博客搭建的过程</h2><p>照理说用hexo搭建博客是一分钟的事情，结果我花了6小时，其中绝大部分时间花在了主题上面，想找个能写数学公式的主题不容易啊，又要符合自己的审美，而且文档要齐全没有bug。<br>最后找到了这个，但是文档还是不够详解，有些功能不知道如何使用，但暂且将就下吧。这个主题自带了mathjax，不过我还没有测试过能不能写公式，我现在就来测试</p>\n<p>$ (\\frac{1}{2})^2 = \\frac{1}{4} $</p>\n<p>顺便测试下代码效果吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(name, age)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'yjh'</span>, <span class=\"number\">20</span>)</div></pre></td></tr></table></figure>\n<p>我把这个博客发了一下，看见真的可以写公式了，很开心，但这6个小时的苦大概是说不清了，而现在已经9点多了，我应该要继续学习无监督学习了。暂且这样吧，回去再折腾折腾，现在赶紧发个url给同学来测试下效果吧！</p>\n"},{"title":"DNS知识点","date":"2017-11-11T01:40:04.000Z","_content":"\n# DNS\n\nDNS 是域名系统（Domain Name System）的缩写，它是一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 I P 地址之间的转换及有关电子邮件的选路信息。所谓“分布式”是指在 Internet 上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供 Internet上的其他系统（客户程序）查询。\n\nDNS 命名方式中，采用了分散和分层的机制来实现域名空间的委派授权，以及域名与地址相转换的授权。通过使用 DNS 的命名方式来为遍布全球的网络设备分配域名，而这则是由分散在世界各地的服务器实现的。\n\n<!-- more -->\n\n## DNS 工作流程\n\n域名服务分为客户端和服务器端，客户端提出请求，询问一个 Domain Name 的 IP 地址，服务器端必须回答客户端的请求。本地 DNS 首先查询自己的数据库，如果自己的数据库中没有对应的 IP 地址，则向本地 DNS 上所设的上一级 DNS 询问，得到结果之后，将收到的结果保存在高速缓冲区，并回答给客户端。标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。16 bit 的标志字段被划分为若干子字段\n\n## DNS 协议\n\n标志中每一位的含义如下：\n\n* QR：是 1 bit 字段，0 表示查询报文，1 表示响应报文。\n* Opcode：报文类型，是一个 4 bit 字段，通常值为 0（标准查询），其他值为 1（反向查询）和 2（服务器状态请求）。\n* AA：是 1 bit 字段，表示“授权回答（authoritative answer）”，如果此位为 1，表示服务器对问题部分的回答是权威性的。\n* TC：是 1 bit 字段，表示“可截断的（truncated）”。使用 UDP 时，它表示当应答的总长度超过 512 字节时，只返回前 512 个字节。\n* RD：是 1 bit 字段，表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为 0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。\n* RA：是 1 bit 字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为 1。\n* Zero：随后的 3 bit 字段必须为 0。\n* Rcode：是一个 4 bit 的返回码字段。通常的值为 0（没有差错）和 3（名字差错）。名字差错只有从一个授权 DNS 服务器上返回，它表示在查询中制定的域名不存在。随后的 4 个 16 bit 字段说明最后 4 个变长字段中包含的条目数。对于查询报文，问题（question）数通常是 1，而其他 3 项则均为 0。类似地，对于应答报文，回答数至少是 1，剩下的两项可以是 0 或非 0。\n\n![](DNS-format.png)\n\n## DNS 抓包\n\n这里DNS报文首部前16bit格式如下：\n\n![](DNS-header.png)\n\nDNS服务器通过`Transaction ID`来分辨同台主机的不同请求。\n\n我打开浏览器访问百度\n\n我请求百度dns的字段如下：\n\n![](DNS-request.png)\n\n这里的前16bit是0x0100\n\n而dns的响应如下：\n\n![](DNS-response.png)\n\n如果请求的域名不存在，则如下：\n\n![](DNS-not-such-name.png)\n\n\n","source":"_posts/计算机网络实验.md","raw":"---\ntitle: DNS知识点\ndate: 2017-11-11 09:40:04\ntags:\n---\n\n# DNS\n\nDNS 是域名系统（Domain Name System）的缩写，它是一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 I P 地址之间的转换及有关电子邮件的选路信息。所谓“分布式”是指在 Internet 上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供 Internet上的其他系统（客户程序）查询。\n\nDNS 命名方式中，采用了分散和分层的机制来实现域名空间的委派授权，以及域名与地址相转换的授权。通过使用 DNS 的命名方式来为遍布全球的网络设备分配域名，而这则是由分散在世界各地的服务器实现的。\n\n<!-- more -->\n\n## DNS 工作流程\n\n域名服务分为客户端和服务器端，客户端提出请求，询问一个 Domain Name 的 IP 地址，服务器端必须回答客户端的请求。本地 DNS 首先查询自己的数据库，如果自己的数据库中没有对应的 IP 地址，则向本地 DNS 上所设的上一级 DNS 询问，得到结果之后，将收到的结果保存在高速缓冲区，并回答给客户端。标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。16 bit 的标志字段被划分为若干子字段\n\n## DNS 协议\n\n标志中每一位的含义如下：\n\n* QR：是 1 bit 字段，0 表示查询报文，1 表示响应报文。\n* Opcode：报文类型，是一个 4 bit 字段，通常值为 0（标准查询），其他值为 1（反向查询）和 2（服务器状态请求）。\n* AA：是 1 bit 字段，表示“授权回答（authoritative answer）”，如果此位为 1，表示服务器对问题部分的回答是权威性的。\n* TC：是 1 bit 字段，表示“可截断的（truncated）”。使用 UDP 时，它表示当应答的总长度超过 512 字节时，只返回前 512 个字节。\n* RD：是 1 bit 字段，表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为 0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。\n* RA：是 1 bit 字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为 1。\n* Zero：随后的 3 bit 字段必须为 0。\n* Rcode：是一个 4 bit 的返回码字段。通常的值为 0（没有差错）和 3（名字差错）。名字差错只有从一个授权 DNS 服务器上返回，它表示在查询中制定的域名不存在。随后的 4 个 16 bit 字段说明最后 4 个变长字段中包含的条目数。对于查询报文，问题（question）数通常是 1，而其他 3 项则均为 0。类似地，对于应答报文，回答数至少是 1，剩下的两项可以是 0 或非 0。\n\n![](DNS-format.png)\n\n## DNS 抓包\n\n这里DNS报文首部前16bit格式如下：\n\n![](DNS-header.png)\n\nDNS服务器通过`Transaction ID`来分辨同台主机的不同请求。\n\n我打开浏览器访问百度\n\n我请求百度dns的字段如下：\n\n![](DNS-request.png)\n\n这里的前16bit是0x0100\n\n而dns的响应如下：\n\n![](DNS-response.png)\n\n如果请求的域名不存在，则如下：\n\n![](DNS-not-such-name.png)\n\n\n","slug":"计算机网络实验","published":1,"updated":"2017-12-10T09:17:52.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5ya3001d6svslu112mzs","content":"<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><p>DNS 是域名系统（Domain Name System）的缩写，它是一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 I P 地址之间的转换及有关电子邮件的选路信息。所谓“分布式”是指在 Internet 上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供 Internet上的其他系统（客户程序）查询。</p>\n<p>DNS 命名方式中，采用了分散和分层的机制来实现域名空间的委派授权，以及域名与地址相转换的授权。通过使用 DNS 的命名方式来为遍布全球的网络设备分配域名，而这则是由分散在世界各地的服务器实现的。</p>\n<a id=\"more\"></a>\n<h2 id=\"DNS-工作流程\"><a href=\"#DNS-工作流程\" class=\"headerlink\" title=\"DNS 工作流程\"></a>DNS 工作流程</h2><p>域名服务分为客户端和服务器端，客户端提出请求，询问一个 Domain Name 的 IP 地址，服务器端必须回答客户端的请求。本地 DNS 首先查询自己的数据库，如果自己的数据库中没有对应的 IP 地址，则向本地 DNS 上所设的上一级 DNS 询问，得到结果之后，将收到的结果保存在高速缓冲区，并回答给客户端。标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。16 bit 的标志字段被划分为若干子字段</p>\n<h2 id=\"DNS-协议\"><a href=\"#DNS-协议\" class=\"headerlink\" title=\"DNS 协议\"></a>DNS 协议</h2><p>标志中每一位的含义如下：</p>\n<ul>\n<li>QR：是 1 bit 字段，0 表示查询报文，1 表示响应报文。</li>\n<li>Opcode：报文类型，是一个 4 bit 字段，通常值为 0（标准查询），其他值为 1（反向查询）和 2（服务器状态请求）。</li>\n<li>AA：是 1 bit 字段，表示“授权回答（authoritative answer）”，如果此位为 1，表示服务器对问题部分的回答是权威性的。</li>\n<li>TC：是 1 bit 字段，表示“可截断的（truncated）”。使用 UDP 时，它表示当应答的总长度超过 512 字节时，只返回前 512 个字节。</li>\n<li>RD：是 1 bit 字段，表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为 0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。</li>\n<li>RA：是 1 bit 字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为 1。</li>\n<li>Zero：随后的 3 bit 字段必须为 0。</li>\n<li>Rcode：是一个 4 bit 的返回码字段。通常的值为 0（没有差错）和 3（名字差错）。名字差错只有从一个授权 DNS 服务器上返回，它表示在查询中制定的域名不存在。随后的 4 个 16 bit 字段说明最后 4 个变长字段中包含的条目数。对于查询报文，问题（question）数通常是 1，而其他 3 项则均为 0。类似地，对于应答报文，回答数至少是 1，剩下的两项可以是 0 或非 0。</li>\n</ul>\n<p><img src=\"DNS-format.png\" alt=\"\"></p>\n<h2 id=\"DNS-抓包\"><a href=\"#DNS-抓包\" class=\"headerlink\" title=\"DNS 抓包\"></a>DNS 抓包</h2><p>这里DNS报文首部前16bit格式如下：</p>\n<p><img src=\"DNS-header.png\" alt=\"\"></p>\n<p>DNS服务器通过<code>Transaction ID</code>来分辨同台主机的不同请求。</p>\n<p>我打开浏览器访问百度</p>\n<p>我请求百度dns的字段如下：</p>\n<p><img src=\"DNS-request.png\" alt=\"\"></p>\n<p>这里的前16bit是0x0100</p>\n<p>而dns的响应如下：</p>\n<p><img src=\"DNS-response.png\" alt=\"\"></p>\n<p>如果请求的域名不存在，则如下：</p>\n<p><img src=\"DNS-not-such-name.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><p>DNS 是域名系统（Domain Name System）的缩写，它是一种用于 TCP/IP 应用程序的分布式数据库，它提供主机名字和 I P 地址之间的转换及有关电子邮件的选路信息。所谓“分布式”是指在 Internet 上的单个站点不能拥有所有的信息。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供 Internet上的其他系统（客户程序）查询。</p>\n<p>DNS 命名方式中，采用了分散和分层的机制来实现域名空间的委派授权，以及域名与地址相转换的授权。通过使用 DNS 的命名方式来为遍布全球的网络设备分配域名，而这则是由分散在世界各地的服务器实现的。</p>","more":"<h2 id=\"DNS-工作流程\"><a href=\"#DNS-工作流程\" class=\"headerlink\" title=\"DNS 工作流程\"></a>DNS 工作流程</h2><p>域名服务分为客户端和服务器端，客户端提出请求，询问一个 Domain Name 的 IP 地址，服务器端必须回答客户端的请求。本地 DNS 首先查询自己的数据库，如果自己的数据库中没有对应的 IP 地址，则向本地 DNS 上所设的上一级 DNS 询问，得到结果之后，将收到的结果保存在高速缓冲区，并回答给客户端。标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。16 bit 的标志字段被划分为若干子字段</p>\n<h2 id=\"DNS-协议\"><a href=\"#DNS-协议\" class=\"headerlink\" title=\"DNS 协议\"></a>DNS 协议</h2><p>标志中每一位的含义如下：</p>\n<ul>\n<li>QR：是 1 bit 字段，0 表示查询报文，1 表示响应报文。</li>\n<li>Opcode：报文类型，是一个 4 bit 字段，通常值为 0（标准查询），其他值为 1（反向查询）和 2（服务器状态请求）。</li>\n<li>AA：是 1 bit 字段，表示“授权回答（authoritative answer）”，如果此位为 1，表示服务器对问题部分的回答是权威性的。</li>\n<li>TC：是 1 bit 字段，表示“可截断的（truncated）”。使用 UDP 时，它表示当应答的总长度超过 512 字节时，只返回前 512 个字节。</li>\n<li>RD：是 1 bit 字段，表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为 0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。</li>\n<li>RA：是 1 bit 字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为 1。</li>\n<li>Zero：随后的 3 bit 字段必须为 0。</li>\n<li>Rcode：是一个 4 bit 的返回码字段。通常的值为 0（没有差错）和 3（名字差错）。名字差错只有从一个授权 DNS 服务器上返回，它表示在查询中制定的域名不存在。随后的 4 个 16 bit 字段说明最后 4 个变长字段中包含的条目数。对于查询报文，问题（question）数通常是 1，而其他 3 项则均为 0。类似地，对于应答报文，回答数至少是 1，剩下的两项可以是 0 或非 0。</li>\n</ul>\n<p><img src=\"DNS-format.png\" alt=\"\"></p>\n<h2 id=\"DNS-抓包\"><a href=\"#DNS-抓包\" class=\"headerlink\" title=\"DNS 抓包\"></a>DNS 抓包</h2><p>这里DNS报文首部前16bit格式如下：</p>\n<p><img src=\"DNS-header.png\" alt=\"\"></p>\n<p>DNS服务器通过<code>Transaction ID</code>来分辨同台主机的不同请求。</p>\n<p>我打开浏览器访问百度</p>\n<p>我请求百度dns的字段如下：</p>\n<p><img src=\"DNS-request.png\" alt=\"\"></p>\n<p>这里的前16bit是0x0100</p>\n<p>而dns的响应如下：</p>\n<p><img src=\"DNS-response.png\" alt=\"\"></p>\n<p>如果请求的域名不存在，则如下：</p>\n<p><img src=\"DNS-not-such-name.png\" alt=\"\"></p>"},{"title":"计算机系统结构","date":"2017-09-28T11:48:52.000Z","_content":"\n系统结构的部分课后作业，因为需要写成电子版，故稍微整理下也放入到博客中，方便你我他。答案是自己组织的，不保证一定正确。\n书是张晨曦的《计算机系统结构（第2版）》\n\n<!-- more -->\n\n# 第一章\n\n## 1\n\n`翻译`技术是先把 L+1 级程序全部变换成 L 级程序后，再去执行新产生的 L 级程序，在执行过程中 L+1 级程序不再被访问。\n\n`解释`技术是每当一条 L+1 级指令被译码后，就直接去执行一串等效的 L 级指令，然后再去取下一条 L+1 级指令，以此重复进行。\n\n计算机`系统结构`是程序员所看到的计算机属性，即概念性结构与功能特性。\n\n`Amdahl定律`：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。\n\n`程序的局部性原理`是指程序执行时所访问的存储器地址不是随机的，而是相对簇聚。局部性原理又表现为：时间局部性和空间局部性。\n时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。\n空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。\n\n`CPI`(Cycles Per Instruction，每天指令的周期数) `CPI = 执行程序所需要的时钟时间 / 执行指令个数`。\n\n`模拟`是指用软件的方法在一台现有的计算机（宿主机host）上实现另一台计算机（虚拟机VM）的指令集。\n\n`仿真`是指用一台计算机（宿主机host）上的微程序去解释实现另一台计算机（目标机）的指令集。\n\n## 3\n\n`Flynn分类法`是按照指令流和数据流的多倍性进行分类的。\n\nFlynn分类法把计算机系统结构分为以下4类：\n\n* 单指令流单数据流（SISD）\n* 单指令流多数据流（SIMD）\n* 多指令流单数据流（MISD）\n* 多指令流多数据流（MIMD）\n\n## 4\n\n计算机系统设计经常使用的4个定量原理\n\n* 以经常性事件为重点，按照对经常性情况采用优化方法的原则，能得到更多整体上的改进。\n* Amdahl定律，加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。\n* CPU性能公式，`CPU时间 = 时钟周期时间 x CPI x IC`，只要改进任何一个参数都能提高CPU性能\n* 程序的局部性原理，程序执行时所访问的存储器地址不是随机的，而是相对簇聚。\n\n## 6\n\n执行时间 = 0.000575(s)\n\nCPI =(45000 + 750000 * 2 + 8000 * 4+ 1500 * 2) / （45000 + 75000 + 8000 + 1500）~= 1.776(s) \n\nMIPS = 400Mhz / (CPI * 10^6) ~= 225.217 \n\n执行时间 = 总时钟周期时间数 * 平均周期时间 = 0.000575(s) \n\n## 8\n\n1. \t加速比= 1/((0.9-x)+0.3/30+0.3/20+x/10)=10  x=0.361\n2.\t加速比=1/(0.2+0.3/30+0.2/20+0.2/10)=1/0.245 比例=0.2 * 加速比 ~= 0.816 \n\n# 第二章\n\n## 1\n\nCISC Complex Instruction Set Computer 复杂指令集计算机\n\n复杂指令集计算机的设计策略是使用大量的指令，包括复杂指令。与其他设计相比，在CISC中进行程序设计要比在其他设计中容易，因为每一项简单或复杂的任务都有一条对应的指令。程序设计者不需要写一大堆指令去完成一项复杂的任务。 但指令集的复杂性使得CPU和控制单元的电路非常复杂。\n\nRISC Reduced Instruction Set Computer 精简指令集计算机\n\n精简指令集计算机是一种执行较少类型计算机指令的微处理器。它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。\n\n数据表示(data representation) 是指计算机硬件能够直接识别和指令集可以直接调用的数据类型。\n\n## 2\n\n区分指令集结构的主要因素：寻址方式，数据表示，指令格式。\n根据该因素可将指令集结构分为以下三类：\n* 寄存器-寄存器类型(R-R)\n* 寄存器-存储器类型(R-M）\n* 存储器-存储器类型(M-M)\n\n## 4\n\n指令集应满足的基本要求：完备性，规整性，高效性，兼容性\n\n## 5\n\n指令集结构设计所涉及的内容有指令功能设计，数据表示，寻址方式，指令格式 \n\n## 9\n\n表示寻址方式的主要方法有2种：\n* 把寻址方式编码于操作码中，操作码在描述指令功能的同时也描述了相应的寻址方式，这缩短了指令长度，译码快，但增加了指令的条数和多样性，也增加了CPU对指令译码的难度。\n* 把寻址方式跟操作码分离，为每个操作数设置一个地址描述符，由地址描述符表示相应操作数的寻址方式，这扩大了寻址的范围，但增大了指令长度。这种方式译码较慢，但操作码和寻址互相独立，易于扩展。\n\n## 10\n\n体系结构中常用的指令格式有变长编码格式，定长编码格式，混合编码格式。\n分别是考虑目标代码的大小，性能，和兼顾两者。\n\n# 第三章\n\n## 1\n\n流水线：把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件实现。把多个处理过程在时间上错开，依次通过各功能段，这样每个子过程及其功能部件可以与其他子过程并行进行。\n\n流水线的特点：\n\n* 把大的处理功能分解为多个独立的功能部件，依靠他们的并行工作来缩短程序的执行时间\n* 流水线中的各段的时间尽可能相等，否则会引起流水线的阻塞、断流，因为时间长的段会成为流水线的瓶颈\n* 流水线每个功能部件后面都要有一个锁存器，作用是在相邻两段传送数据，保证后面要用到的数据，并把各段处理的工作隔离\n* 适用于大量重复的时序过程，只有在输入不断地提供任务，才能充分发挥效率\n* 流水线需要通过时间跟排空时间。\n\n流水线的分类：\n\n* 单功能流水线，多功能流水线\n* 静态流水线，动态流水线\n* 部件级流水线，处理机级流水线，处理机间流水线\n* 线性流水线，非线性流水线\n* 顺序流水线，乱序流水线\n\n`吞吐率ThroughPut`是指单位时间内流水线所完成的任务数量或输出结果的数量。\n\n`流水线加速比Speedup`是指完成同一批任务，不使用流水线与使用流水线所用时间之比。\n\n`流水线的效率Efficiency`是指流水线中的设备实际使用时间与整个运行时间比值，即流水线设备的利用率。\n\n名相关是指某两条指令使用相同的名，但是它们之间没有数据流动。\n\n`定向技术`：在某条指令产生计算结果之前，其他指令并不真正理解需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其他指令需要它的地方，那么就可以避免停顿。\n\n`链接技术`是指具有先写后读相关的两条指令，在不出现功能部件冲突\t和源向量冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的。\n\n`分段开采技术`：当向量长度大于向量寄存器长度时，必须把长向量分成长度固定的段，然后循环分段处理\t，每次循环只处理一个向量段。\n\n## 3\n\n解决流水线瓶颈问题通常有两种方法：细分瓶颈段，重复设置瓶颈段\n\n## 4\n减少分支延迟的静态方法：预测分支失败；预测分支成功；延迟分支。\n\n\n## 7\n\n3种向量处理方式：\n* 横向处理方式：向量长度为N时，则相当于N次循环，使用流水线时，在每次循环会出现数据相关和功能转换的问题，所以不适合流水线处理。\n* 纵向处理方式：将整个向量按相同的运算符处理完后，再去进行别的运算。无论N多大，相同运算都用一条向量指令完成。因此需要采用存储器-存储器结构流水线。\n* 纵横处理方式：结合以上两种，它把向量分成若干组，组内用纵向处理方式，依次处理各组。可以设置能快速访问的向量寄存器，用于存放源向量、目的向量、中间结果，构成了寄存器-寄存器结构流水线。\n\n## 9\n\n### 1)\nTP = 10 / (50 + 50 + (10-1) * 200) = 1/220\n\nE = (10 * (50 + 50 + 100 + 200)) / ((50 + 50 + 200 + (10 – 1) * 200) * 4) = 5/11\n\n### 2)\t\n\n该流水线的瓶颈在第四段。分别采用细分瓶颈段和重复设置瓶颈段。\n两种的吞吐率和效率相同\n\nTP = 10 / (50 + 50 + 100 + 100 + 100 + (10 – 1) * 100) = 1/130\n\nE = 10 * 400 / (1300 * 5) = 8/13\n\n## 11\n\nTP = 8 / ((1+2+1+1) + 2*3 + (1+1+1) + 1* 3) = 8 / 17\n\nS = 4 * (1+2+1+1) + 4 * (1+1+1) / 17 = 32/17\n\nE = S/TP = 1/4\n\n![时空图](3-11.jpg)\n\n \n\n\n\n","source":"_posts/计算机系统结构.md","raw":"---\ntitle: 计算机系统结构\ndate: 2017-09-28 19:48:52\ntags: 系统结构\ncategory: study\n---\n\n系统结构的部分课后作业，因为需要写成电子版，故稍微整理下也放入到博客中，方便你我他。答案是自己组织的，不保证一定正确。\n书是张晨曦的《计算机系统结构（第2版）》\n\n<!-- more -->\n\n# 第一章\n\n## 1\n\n`翻译`技术是先把 L+1 级程序全部变换成 L 级程序后，再去执行新产生的 L 级程序，在执行过程中 L+1 级程序不再被访问。\n\n`解释`技术是每当一条 L+1 级指令被译码后，就直接去执行一串等效的 L 级指令，然后再去取下一条 L+1 级指令，以此重复进行。\n\n计算机`系统结构`是程序员所看到的计算机属性，即概念性结构与功能特性。\n\n`Amdahl定律`：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。\n\n`程序的局部性原理`是指程序执行时所访问的存储器地址不是随机的，而是相对簇聚。局部性原理又表现为：时间局部性和空间局部性。\n时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。\n空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。\n\n`CPI`(Cycles Per Instruction，每天指令的周期数) `CPI = 执行程序所需要的时钟时间 / 执行指令个数`。\n\n`模拟`是指用软件的方法在一台现有的计算机（宿主机host）上实现另一台计算机（虚拟机VM）的指令集。\n\n`仿真`是指用一台计算机（宿主机host）上的微程序去解释实现另一台计算机（目标机）的指令集。\n\n## 3\n\n`Flynn分类法`是按照指令流和数据流的多倍性进行分类的。\n\nFlynn分类法把计算机系统结构分为以下4类：\n\n* 单指令流单数据流（SISD）\n* 单指令流多数据流（SIMD）\n* 多指令流单数据流（MISD）\n* 多指令流多数据流（MIMD）\n\n## 4\n\n计算机系统设计经常使用的4个定量原理\n\n* 以经常性事件为重点，按照对经常性情况采用优化方法的原则，能得到更多整体上的改进。\n* Amdahl定律，加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。\n* CPU性能公式，`CPU时间 = 时钟周期时间 x CPI x IC`，只要改进任何一个参数都能提高CPU性能\n* 程序的局部性原理，程序执行时所访问的存储器地址不是随机的，而是相对簇聚。\n\n## 6\n\n执行时间 = 0.000575(s)\n\nCPI =(45000 + 750000 * 2 + 8000 * 4+ 1500 * 2) / （45000 + 75000 + 8000 + 1500）~= 1.776(s) \n\nMIPS = 400Mhz / (CPI * 10^6) ~= 225.217 \n\n执行时间 = 总时钟周期时间数 * 平均周期时间 = 0.000575(s) \n\n## 8\n\n1. \t加速比= 1/((0.9-x)+0.3/30+0.3/20+x/10)=10  x=0.361\n2.\t加速比=1/(0.2+0.3/30+0.2/20+0.2/10)=1/0.245 比例=0.2 * 加速比 ~= 0.816 \n\n# 第二章\n\n## 1\n\nCISC Complex Instruction Set Computer 复杂指令集计算机\n\n复杂指令集计算机的设计策略是使用大量的指令，包括复杂指令。与其他设计相比，在CISC中进行程序设计要比在其他设计中容易，因为每一项简单或复杂的任务都有一条对应的指令。程序设计者不需要写一大堆指令去完成一项复杂的任务。 但指令集的复杂性使得CPU和控制单元的电路非常复杂。\n\nRISC Reduced Instruction Set Computer 精简指令集计算机\n\n精简指令集计算机是一种执行较少类型计算机指令的微处理器。它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。\n\n数据表示(data representation) 是指计算机硬件能够直接识别和指令集可以直接调用的数据类型。\n\n## 2\n\n区分指令集结构的主要因素：寻址方式，数据表示，指令格式。\n根据该因素可将指令集结构分为以下三类：\n* 寄存器-寄存器类型(R-R)\n* 寄存器-存储器类型(R-M）\n* 存储器-存储器类型(M-M)\n\n## 4\n\n指令集应满足的基本要求：完备性，规整性，高效性，兼容性\n\n## 5\n\n指令集结构设计所涉及的内容有指令功能设计，数据表示，寻址方式，指令格式 \n\n## 9\n\n表示寻址方式的主要方法有2种：\n* 把寻址方式编码于操作码中，操作码在描述指令功能的同时也描述了相应的寻址方式，这缩短了指令长度，译码快，但增加了指令的条数和多样性，也增加了CPU对指令译码的难度。\n* 把寻址方式跟操作码分离，为每个操作数设置一个地址描述符，由地址描述符表示相应操作数的寻址方式，这扩大了寻址的范围，但增大了指令长度。这种方式译码较慢，但操作码和寻址互相独立，易于扩展。\n\n## 10\n\n体系结构中常用的指令格式有变长编码格式，定长编码格式，混合编码格式。\n分别是考虑目标代码的大小，性能，和兼顾两者。\n\n# 第三章\n\n## 1\n\n流水线：把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件实现。把多个处理过程在时间上错开，依次通过各功能段，这样每个子过程及其功能部件可以与其他子过程并行进行。\n\n流水线的特点：\n\n* 把大的处理功能分解为多个独立的功能部件，依靠他们的并行工作来缩短程序的执行时间\n* 流水线中的各段的时间尽可能相等，否则会引起流水线的阻塞、断流，因为时间长的段会成为流水线的瓶颈\n* 流水线每个功能部件后面都要有一个锁存器，作用是在相邻两段传送数据，保证后面要用到的数据，并把各段处理的工作隔离\n* 适用于大量重复的时序过程，只有在输入不断地提供任务，才能充分发挥效率\n* 流水线需要通过时间跟排空时间。\n\n流水线的分类：\n\n* 单功能流水线，多功能流水线\n* 静态流水线，动态流水线\n* 部件级流水线，处理机级流水线，处理机间流水线\n* 线性流水线，非线性流水线\n* 顺序流水线，乱序流水线\n\n`吞吐率ThroughPut`是指单位时间内流水线所完成的任务数量或输出结果的数量。\n\n`流水线加速比Speedup`是指完成同一批任务，不使用流水线与使用流水线所用时间之比。\n\n`流水线的效率Efficiency`是指流水线中的设备实际使用时间与整个运行时间比值，即流水线设备的利用率。\n\n名相关是指某两条指令使用相同的名，但是它们之间没有数据流动。\n\n`定向技术`：在某条指令产生计算结果之前，其他指令并不真正理解需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其他指令需要它的地方，那么就可以避免停顿。\n\n`链接技术`是指具有先写后读相关的两条指令，在不出现功能部件冲突\t和源向量冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的。\n\n`分段开采技术`：当向量长度大于向量寄存器长度时，必须把长向量分成长度固定的段，然后循环分段处理\t，每次循环只处理一个向量段。\n\n## 3\n\n解决流水线瓶颈问题通常有两种方法：细分瓶颈段，重复设置瓶颈段\n\n## 4\n减少分支延迟的静态方法：预测分支失败；预测分支成功；延迟分支。\n\n\n## 7\n\n3种向量处理方式：\n* 横向处理方式：向量长度为N时，则相当于N次循环，使用流水线时，在每次循环会出现数据相关和功能转换的问题，所以不适合流水线处理。\n* 纵向处理方式：将整个向量按相同的运算符处理完后，再去进行别的运算。无论N多大，相同运算都用一条向量指令完成。因此需要采用存储器-存储器结构流水线。\n* 纵横处理方式：结合以上两种，它把向量分成若干组，组内用纵向处理方式，依次处理各组。可以设置能快速访问的向量寄存器，用于存放源向量、目的向量、中间结果，构成了寄存器-寄存器结构流水线。\n\n## 9\n\n### 1)\nTP = 10 / (50 + 50 + (10-1) * 200) = 1/220\n\nE = (10 * (50 + 50 + 100 + 200)) / ((50 + 50 + 200 + (10 – 1) * 200) * 4) = 5/11\n\n### 2)\t\n\n该流水线的瓶颈在第四段。分别采用细分瓶颈段和重复设置瓶颈段。\n两种的吞吐率和效率相同\n\nTP = 10 / (50 + 50 + 100 + 100 + 100 + (10 – 1) * 100) = 1/130\n\nE = 10 * 400 / (1300 * 5) = 8/13\n\n## 11\n\nTP = 8 / ((1+2+1+1) + 2*3 + (1+1+1) + 1* 3) = 8 / 17\n\nS = 4 * (1+2+1+1) + 4 * (1+1+1) / 17 = 32/17\n\nE = S/TP = 1/4\n\n![时空图](3-11.jpg)\n\n \n\n\n\n","slug":"计算机系统结构","published":1,"updated":"2017-11-20T08:18:15.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjezm5ya7001h6svsw4czdlee","content":"<p>系统结构的部分课后作业，因为需要写成电子版，故稍微整理下也放入到博客中，方便你我他。答案是自己组织的，不保证一定正确。<br>书是张晨曦的《计算机系统结构（第2版）》</p>\n<a id=\"more\"></a>\n<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p><code>翻译</code>技术是先把 L+1 级程序全部变换成 L 级程序后，再去执行新产生的 L 级程序，在执行过程中 L+1 级程序不再被访问。</p>\n<p><code>解释</code>技术是每当一条 L+1 级指令被译码后，就直接去执行一串等效的 L 级指令，然后再去取下一条 L+1 级指令，以此重复进行。</p>\n<p>计算机<code>系统结构</code>是程序员所看到的计算机属性，即概念性结构与功能特性。</p>\n<p><code>Amdahl定律</code>：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。</p>\n<p><code>程序的局部性原理</code>是指程序执行时所访问的存储器地址不是随机的，而是相对簇聚。局部性原理又表现为：时间局部性和空间局部性。<br>时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。<br>空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。</p>\n<p><code>CPI</code>(Cycles Per Instruction，每天指令的周期数) <code>CPI = 执行程序所需要的时钟时间 / 执行指令个数</code>。</p>\n<p><code>模拟</code>是指用软件的方法在一台现有的计算机（宿主机host）上实现另一台计算机（虚拟机VM）的指令集。</p>\n<p><code>仿真</code>是指用一台计算机（宿主机host）上的微程序去解释实现另一台计算机（目标机）的指令集。</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p><code>Flynn分类法</code>是按照指令流和数据流的多倍性进行分类的。</p>\n<p>Flynn分类法把计算机系统结构分为以下4类：</p>\n<ul>\n<li>单指令流单数据流（SISD）</li>\n<li>单指令流多数据流（SIMD）</li>\n<li>多指令流单数据流（MISD）</li>\n<li>多指令流多数据流（MIMD）</li>\n</ul>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>计算机系统设计经常使用的4个定量原理</p>\n<ul>\n<li>以经常性事件为重点，按照对经常性情况采用优化方法的原则，能得到更多整体上的改进。</li>\n<li>Amdahl定律，加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。</li>\n<li>CPU性能公式，<code>CPU时间 = 时钟周期时间 x CPI x IC</code>，只要改进任何一个参数都能提高CPU性能</li>\n<li>程序的局部性原理，程序执行时所访问的存储器地址不是随机的，而是相对簇聚。</li>\n</ul>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><p>执行时间 = 0.000575(s)</p>\n<p>CPI =(45000 + 750000 <em> 2 + 8000 </em> 4+ 1500 * 2) / （45000 + 75000 + 8000 + 1500）~= 1.776(s) </p>\n<p>MIPS = 400Mhz / (CPI * 10^6) ~= 225.217 </p>\n<p>执行时间 = 总时钟周期时间数 * 平均周期时间 = 0.000575(s) </p>\n<h2 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8\"></a>8</h2><ol>\n<li>加速比= 1/((0.9-x)+0.3/30+0.3/20+x/10)=10  x=0.361</li>\n<li>加速比=1/(0.2+0.3/30+0.2/20+0.2/10)=1/0.245 比例=0.2 * 加速比 ~= 0.816 </li>\n</ol>\n<h1 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h1><h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>CISC Complex Instruction Set Computer 复杂指令集计算机</p>\n<p>复杂指令集计算机的设计策略是使用大量的指令，包括复杂指令。与其他设计相比，在CISC中进行程序设计要比在其他设计中容易，因为每一项简单或复杂的任务都有一条对应的指令。程序设计者不需要写一大堆指令去完成一项复杂的任务。 但指令集的复杂性使得CPU和控制单元的电路非常复杂。</p>\n<p>RISC Reduced Instruction Set Computer 精简指令集计算机</p>\n<p>精简指令集计算机是一种执行较少类型计算机指令的微处理器。它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。</p>\n<p>数据表示(data representation) 是指计算机硬件能够直接识别和指令集可以直接调用的数据类型。</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>区分指令集结构的主要因素：寻址方式，数据表示，指令格式。<br>根据该因素可将指令集结构分为以下三类：</p>\n<ul>\n<li>寄存器-寄存器类型(R-R)</li>\n<li>寄存器-存储器类型(R-M）</li>\n<li>存储器-存储器类型(M-M)</li>\n</ul>\n<h2 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4\"></a>4</h2><p>指令集应满足的基本要求：完备性，规整性，高效性，兼容性</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>指令集结构设计所涉及的内容有指令功能设计，数据表示，寻址方式，指令格式 </p>\n<h2 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h2><p>表示寻址方式的主要方法有2种：</p>\n<ul>\n<li>把寻址方式编码于操作码中，操作码在描述指令功能的同时也描述了相应的寻址方式，这缩短了指令长度，译码快，但增加了指令的条数和多样性，也增加了CPU对指令译码的难度。</li>\n<li>把寻址方式跟操作码分离，为每个操作数设置一个地址描述符，由地址描述符表示相应操作数的寻址方式，这扩大了寻址的范围，但增大了指令长度。这种方式译码较慢，但操作码和寻址互相独立，易于扩展。</li>\n</ul>\n<h2 id=\"10\"><a href=\"#10\" class=\"headerlink\" title=\"10\"></a>10</h2><p>体系结构中常用的指令格式有变长编码格式，定长编码格式，混合编码格式。<br>分别是考虑目标代码的大小，性能，和兼顾两者。</p>\n<h1 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h1><h2 id=\"1-2\"><a href=\"#1-2\" class=\"headerlink\" title=\"1\"></a>1</h2><p>流水线：把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件实现。把多个处理过程在时间上错开，依次通过各功能段，这样每个子过程及其功能部件可以与其他子过程并行进行。</p>\n<p>流水线的特点：</p>\n<ul>\n<li>把大的处理功能分解为多个独立的功能部件，依靠他们的并行工作来缩短程序的执行时间</li>\n<li>流水线中的各段的时间尽可能相等，否则会引起流水线的阻塞、断流，因为时间长的段会成为流水线的瓶颈</li>\n<li>流水线每个功能部件后面都要有一个锁存器，作用是在相邻两段传送数据，保证后面要用到的数据，并把各段处理的工作隔离</li>\n<li>适用于大量重复的时序过程，只有在输入不断地提供任务，才能充分发挥效率</li>\n<li>流水线需要通过时间跟排空时间。</li>\n</ul>\n<p>流水线的分类：</p>\n<ul>\n<li>单功能流水线，多功能流水线</li>\n<li>静态流水线，动态流水线</li>\n<li>部件级流水线，处理机级流水线，处理机间流水线</li>\n<li>线性流水线，非线性流水线</li>\n<li>顺序流水线，乱序流水线</li>\n</ul>\n<p><code>吞吐率ThroughPut</code>是指单位时间内流水线所完成的任务数量或输出结果的数量。</p>\n<p><code>流水线加速比Speedup</code>是指完成同一批任务，不使用流水线与使用流水线所用时间之比。</p>\n<p><code>流水线的效率Efficiency</code>是指流水线中的设备实际使用时间与整个运行时间比值，即流水线设备的利用率。</p>\n<p>名相关是指某两条指令使用相同的名，但是它们之间没有数据流动。</p>\n<p><code>定向技术</code>：在某条指令产生计算结果之前，其他指令并不真正理解需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其他指令需要它的地方，那么就可以避免停顿。</p>\n<p><code>链接技术</code>是指具有先写后读相关的两条指令，在不出现功能部件冲突    和源向量冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的。</p>\n<p><code>分段开采技术</code>：当向量长度大于向量寄存器长度时，必须把长向量分成长度固定的段，然后循环分段处理    ，每次循环只处理一个向量段。</p>\n<h2 id=\"3-1\"><a href=\"#3-1\" class=\"headerlink\" title=\"3\"></a>3</h2><p>解决流水线瓶颈问题通常有两种方法：细分瓶颈段，重复设置瓶颈段</p>\n<h2 id=\"4-2\"><a href=\"#4-2\" class=\"headerlink\" title=\"4\"></a>4</h2><p>减少分支延迟的静态方法：预测分支失败；预测分支成功；延迟分支。</p>\n<h2 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h2><p>3种向量处理方式：</p>\n<ul>\n<li>横向处理方式：向量长度为N时，则相当于N次循环，使用流水线时，在每次循环会出现数据相关和功能转换的问题，所以不适合流水线处理。</li>\n<li>纵向处理方式：将整个向量按相同的运算符处理完后，再去进行别的运算。无论N多大，相同运算都用一条向量指令完成。因此需要采用存储器-存储器结构流水线。</li>\n<li>纵横处理方式：结合以上两种，它把向量分成若干组，组内用纵向处理方式，依次处理各组。可以设置能快速访问的向量寄存器，用于存放源向量、目的向量、中间结果，构成了寄存器-寄存器结构流水线。</li>\n</ul>\n<h2 id=\"9-1\"><a href=\"#9-1\" class=\"headerlink\" title=\"9\"></a>9</h2><h3 id=\"1-3\"><a href=\"#1-3\" class=\"headerlink\" title=\"1)\"></a>1)</h3><p>TP = 10 / (50 + 50 + (10-1) * 200) = 1/220</p>\n<p>E = (10 <em> (50 + 50 + 100 + 200)) / ((50 + 50 + 200 + (10 – 1) </em> 200) * 4) = 5/11</p>\n<h3 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2)\"></a>2)</h3><p>该流水线的瓶颈在第四段。分别采用细分瓶颈段和重复设置瓶颈段。<br>两种的吞吐率和效率相同</p>\n<p>TP = 10 / (50 + 50 + 100 + 100 + 100 + (10 – 1) * 100) = 1/130</p>\n<p>E = 10 <em> 400 / (1300 </em> 5) = 8/13</p>\n<h2 id=\"11\"><a href=\"#11\" class=\"headerlink\" title=\"11\"></a>11</h2><p>TP = 8 / ((1+2+1+1) + 2<em>3 + (1+1+1) + 1</em> 3) = 8 / 17</p>\n<p>S = 4 <em> (1+2+1+1) + 4 </em> (1+1+1) / 17 = 32/17</p>\n<p>E = S/TP = 1/4</p>\n<p><img src=\"3-11.jpg\" alt=\"时空图\"></p>\n","site":{"data":{}},"excerpt":"<p>系统结构的部分课后作业，因为需要写成电子版，故稍微整理下也放入到博客中，方便你我他。答案是自己组织的，不保证一定正确。<br>书是张晨曦的《计算机系统结构（第2版）》</p>","more":"<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p><code>翻译</code>技术是先把 L+1 级程序全部变换成 L 级程序后，再去执行新产生的 L 级程序，在执行过程中 L+1 级程序不再被访问。</p>\n<p><code>解释</code>技术是每当一条 L+1 级指令被译码后，就直接去执行一串等效的 L 级指令，然后再去取下一条 L+1 级指令，以此重复进行。</p>\n<p>计算机<code>系统结构</code>是程序员所看到的计算机属性，即概念性结构与功能特性。</p>\n<p><code>Amdahl定律</code>：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。</p>\n<p><code>程序的局部性原理</code>是指程序执行时所访问的存储器地址不是随机的，而是相对簇聚。局部性原理又表现为：时间局部性和空间局部性。<br>时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。<br>空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。</p>\n<p><code>CPI</code>(Cycles Per Instruction，每天指令的周期数) <code>CPI = 执行程序所需要的时钟时间 / 执行指令个数</code>。</p>\n<p><code>模拟</code>是指用软件的方法在一台现有的计算机（宿主机host）上实现另一台计算机（虚拟机VM）的指令集。</p>\n<p><code>仿真</code>是指用一台计算机（宿主机host）上的微程序去解释实现另一台计算机（目标机）的指令集。</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p><code>Flynn分类法</code>是按照指令流和数据流的多倍性进行分类的。</p>\n<p>Flynn分类法把计算机系统结构分为以下4类：</p>\n<ul>\n<li>单指令流单数据流（SISD）</li>\n<li>单指令流多数据流（SIMD）</li>\n<li>多指令流单数据流（MISD）</li>\n<li>多指令流多数据流（MIMD）</li>\n</ul>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>计算机系统设计经常使用的4个定量原理</p>\n<ul>\n<li>以经常性事件为重点，按照对经常性情况采用优化方法的原则，能得到更多整体上的改进。</li>\n<li>Amdahl定律，加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。</li>\n<li>CPU性能公式，<code>CPU时间 = 时钟周期时间 x CPI x IC</code>，只要改进任何一个参数都能提高CPU性能</li>\n<li>程序的局部性原理，程序执行时所访问的存储器地址不是随机的，而是相对簇聚。</li>\n</ul>\n<h2 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h2><p>执行时间 = 0.000575(s)</p>\n<p>CPI =(45000 + 750000 <em> 2 + 8000 </em> 4+ 1500 * 2) / （45000 + 75000 + 8000 + 1500）~= 1.776(s) </p>\n<p>MIPS = 400Mhz / (CPI * 10^6) ~= 225.217 </p>\n<p>执行时间 = 总时钟周期时间数 * 平均周期时间 = 0.000575(s) </p>\n<h2 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8\"></a>8</h2><ol>\n<li>加速比= 1/((0.9-x)+0.3/30+0.3/20+x/10)=10  x=0.361</li>\n<li>加速比=1/(0.2+0.3/30+0.2/20+0.2/10)=1/0.245 比例=0.2 * 加速比 ~= 0.816 </li>\n</ol>\n<h1 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h1><h2 id=\"1-1\"><a href=\"#1-1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>CISC Complex Instruction Set Computer 复杂指令集计算机</p>\n<p>复杂指令集计算机的设计策略是使用大量的指令，包括复杂指令。与其他设计相比，在CISC中进行程序设计要比在其他设计中容易，因为每一项简单或复杂的任务都有一条对应的指令。程序设计者不需要写一大堆指令去完成一项复杂的任务。 但指令集的复杂性使得CPU和控制单元的电路非常复杂。</p>\n<p>RISC Reduced Instruction Set Computer 精简指令集计算机</p>\n<p>精简指令集计算机是一种执行较少类型计算机指令的微处理器。它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。</p>\n<p>数据表示(data representation) 是指计算机硬件能够直接识别和指令集可以直接调用的数据类型。</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>区分指令集结构的主要因素：寻址方式，数据表示，指令格式。<br>根据该因素可将指令集结构分为以下三类：</p>\n<ul>\n<li>寄存器-寄存器类型(R-R)</li>\n<li>寄存器-存储器类型(R-M）</li>\n<li>存储器-存储器类型(M-M)</li>\n</ul>\n<h2 id=\"4-1\"><a href=\"#4-1\" class=\"headerlink\" title=\"4\"></a>4</h2><p>指令集应满足的基本要求：完备性，规整性，高效性，兼容性</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>指令集结构设计所涉及的内容有指令功能设计，数据表示，寻址方式，指令格式 </p>\n<h2 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h2><p>表示寻址方式的主要方法有2种：</p>\n<ul>\n<li>把寻址方式编码于操作码中，操作码在描述指令功能的同时也描述了相应的寻址方式，这缩短了指令长度，译码快，但增加了指令的条数和多样性，也增加了CPU对指令译码的难度。</li>\n<li>把寻址方式跟操作码分离，为每个操作数设置一个地址描述符，由地址描述符表示相应操作数的寻址方式，这扩大了寻址的范围，但增大了指令长度。这种方式译码较慢，但操作码和寻址互相独立，易于扩展。</li>\n</ul>\n<h2 id=\"10\"><a href=\"#10\" class=\"headerlink\" title=\"10\"></a>10</h2><p>体系结构中常用的指令格式有变长编码格式，定长编码格式，混合编码格式。<br>分别是考虑目标代码的大小，性能，和兼顾两者。</p>\n<h1 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h1><h2 id=\"1-2\"><a href=\"#1-2\" class=\"headerlink\" title=\"1\"></a>1</h2><p>流水线：把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件实现。把多个处理过程在时间上错开，依次通过各功能段，这样每个子过程及其功能部件可以与其他子过程并行进行。</p>\n<p>流水线的特点：</p>\n<ul>\n<li>把大的处理功能分解为多个独立的功能部件，依靠他们的并行工作来缩短程序的执行时间</li>\n<li>流水线中的各段的时间尽可能相等，否则会引起流水线的阻塞、断流，因为时间长的段会成为流水线的瓶颈</li>\n<li>流水线每个功能部件后面都要有一个锁存器，作用是在相邻两段传送数据，保证后面要用到的数据，并把各段处理的工作隔离</li>\n<li>适用于大量重复的时序过程，只有在输入不断地提供任务，才能充分发挥效率</li>\n<li>流水线需要通过时间跟排空时间。</li>\n</ul>\n<p>流水线的分类：</p>\n<ul>\n<li>单功能流水线，多功能流水线</li>\n<li>静态流水线，动态流水线</li>\n<li>部件级流水线，处理机级流水线，处理机间流水线</li>\n<li>线性流水线，非线性流水线</li>\n<li>顺序流水线，乱序流水线</li>\n</ul>\n<p><code>吞吐率ThroughPut</code>是指单位时间内流水线所完成的任务数量或输出结果的数量。</p>\n<p><code>流水线加速比Speedup</code>是指完成同一批任务，不使用流水线与使用流水线所用时间之比。</p>\n<p><code>流水线的效率Efficiency</code>是指流水线中的设备实际使用时间与整个运行时间比值，即流水线设备的利用率。</p>\n<p>名相关是指某两条指令使用相同的名，但是它们之间没有数据流动。</p>\n<p><code>定向技术</code>：在某条指令产生计算结果之前，其他指令并不真正理解需要该计算结果，如果能够将该计算结果从其产生的地方直接送到其他指令需要它的地方，那么就可以避免停顿。</p>\n<p><code>链接技术</code>是指具有先写后读相关的两条指令，在不出现功能部件冲突    和源向量冲突的情况下，可以把功能部件链接起来进行流水处理，以达到加快执行的目的。</p>\n<p><code>分段开采技术</code>：当向量长度大于向量寄存器长度时，必须把长向量分成长度固定的段，然后循环分段处理    ，每次循环只处理一个向量段。</p>\n<h2 id=\"3-1\"><a href=\"#3-1\" class=\"headerlink\" title=\"3\"></a>3</h2><p>解决流水线瓶颈问题通常有两种方法：细分瓶颈段，重复设置瓶颈段</p>\n<h2 id=\"4-2\"><a href=\"#4-2\" class=\"headerlink\" title=\"4\"></a>4</h2><p>减少分支延迟的静态方法：预测分支失败；预测分支成功；延迟分支。</p>\n<h2 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h2><p>3种向量处理方式：</p>\n<ul>\n<li>横向处理方式：向量长度为N时，则相当于N次循环，使用流水线时，在每次循环会出现数据相关和功能转换的问题，所以不适合流水线处理。</li>\n<li>纵向处理方式：将整个向量按相同的运算符处理完后，再去进行别的运算。无论N多大，相同运算都用一条向量指令完成。因此需要采用存储器-存储器结构流水线。</li>\n<li>纵横处理方式：结合以上两种，它把向量分成若干组，组内用纵向处理方式，依次处理各组。可以设置能快速访问的向量寄存器，用于存放源向量、目的向量、中间结果，构成了寄存器-寄存器结构流水线。</li>\n</ul>\n<h2 id=\"9-1\"><a href=\"#9-1\" class=\"headerlink\" title=\"9\"></a>9</h2><h3 id=\"1-3\"><a href=\"#1-3\" class=\"headerlink\" title=\"1)\"></a>1)</h3><p>TP = 10 / (50 + 50 + (10-1) * 200) = 1/220</p>\n<p>E = (10 <em> (50 + 50 + 100 + 200)) / ((50 + 50 + 200 + (10 – 1) </em> 200) * 4) = 5/11</p>\n<h3 id=\"2-1\"><a href=\"#2-1\" class=\"headerlink\" title=\"2)\"></a>2)</h3><p>该流水线的瓶颈在第四段。分别采用细分瓶颈段和重复设置瓶颈段。<br>两种的吞吐率和效率相同</p>\n<p>TP = 10 / (50 + 50 + 100 + 100 + 100 + (10 – 1) * 100) = 1/130</p>\n<p>E = 10 <em> 400 / (1300 </em> 5) = 8/13</p>\n<h2 id=\"11\"><a href=\"#11\" class=\"headerlink\" title=\"11\"></a>11</h2><p>TP = 8 / ((1+2+1+1) + 2<em>3 + (1+1+1) + 1</em> 3) = 8 / 17</p>\n<p>S = 4 <em> (1+2+1+1) + 4 </em> (1+1+1) / 17 = 32/17</p>\n<p>E = S/TP = 1/4</p>\n<p><img src=\"3-11.jpg\" alt=\"时空图\"></p>"}],"PostAsset":[{"_id":"source/_posts/VAET阅读稿/feature-extraction.png","slug":"feature-extraction.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/visual-organization.png","slug":"visual-organization.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/Visual-Encoding.png","slug":"Visual-Encoding.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/TOS-map.png","slug":"TOS-map.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/VAET-overview.png","slug":"VAET-overview.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/fig11.png","slug":"fig11.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/JS函数式编程笔记1/compose.png","slug":"compose.png","post":"cjezm5y7p000f6svsgt5p6vdk","modified":0,"renderable":0},{"_id":"source/_posts/JS函数式编程笔记1/范畴学.png","slug":"范畴学.png","post":"cjezm5y7p000f6svsgt5p6vdk","modified":0,"renderable":0},{"_id":"source/_posts/IEEE802.11无线LANs概述/802.11.jpg","slug":"802.11.jpg","post":"cjezm5y7800086svs60m92sar","modified":0,"renderable":0},{"_id":"source/_posts/IEEE802.11无线LANs概述/BBS.jpg","slug":"BBS.jpg","post":"cjezm5y7800086svs60m92sar","modified":0,"renderable":0},{"_id":"source/_posts/IEEE802.11无线LANs概述/中央基站.jpg","slug":"中央基站.jpg","post":"cjezm5y7800086svs60m92sar","modified":0,"renderable":0},{"_id":"source/_posts/JS函数式编程笔记2/functor映射.png","slug":"functor映射.png","post":"cjezm5y8b000k6svsz3hvktfo","modified":0,"renderable":0},{"_id":"source/_posts/JS函数式编程笔记2/functor映射2.png","slug":"functor映射2.png","post":"cjezm5y8b000k6svsz3hvktfo","modified":0,"renderable":0},{"_id":"source/_posts/JS函数式编程笔记2/functor映射实例.png","slug":"functor映射实例.png","post":"cjezm5y8b000k6svsz3hvktfo","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/Navicat使用期限.png","slug":"Navicat使用期限.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/Navicat使用界面.png","slug":"Navicat使用界面.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/mysql启动.png","slug":"mysql启动.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/mysql安装.png","slug":"mysql安装.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/mysql安装路径.png","slug":"mysql安装路径.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/mysql目录结构.png","slug":"mysql目录结构.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/mysql配置完成.png","slug":"mysql配置完成.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/操作界面.png","slug":"操作界面.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/Install-MySQL5-7/查看mysql字符编码.png","slug":"查看mysql字符编码.png","post":"cjezm5y7d000a6svsdainlp2b","modified":0,"renderable":0},{"_id":"source/_posts/计算机系统结构/3-11.jpg","slug":"3-11.jpg","post":"cjezm5ya7001h6svsw4czdlee","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络实验/DNS-format.png","slug":"DNS-format.png","post":"cjezm5ya3001d6svslu112mzs","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络实验/DNS-header.png","slug":"DNS-header.png","post":"cjezm5ya3001d6svslu112mzs","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络实验/DNS-not-such-name.png","slug":"DNS-not-such-name.png","post":"cjezm5ya3001d6svslu112mzs","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络实验/DNS-request.png","slug":"DNS-request.png","post":"cjezm5ya3001d6svslu112mzs","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络实验/DNS-response.png","slug":"DNS-response.png","post":"cjezm5ya3001d6svslu112mzs","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/Knotlines.png","slug":"Knotlines.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/VAET-system.png","slug":"VAET-system.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/confusion-matrix.png","slug":"confusion-matrix.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/decision-tree.png","slug":"decision-tree.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/fig12.png","slug":"fig12.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/hierarchical-tree.png","slug":"hierarchical-tree.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0},{"_id":"source/_posts/VAET阅读稿/salient-transactions.png","slug":"salient-transactions.png","post":"cjezm5y82000i6svsl7b0250y","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjezm5y6c00026svsgmwrvc19","category_id":"cjezm5y7f000b6svs8pa2pgpw","_id":"cjezm5y8e000m6svsd76gkejq"},{"post_id":"cjezm5y8l000o6svsuyyw85z5","category_id":"cjezm5y7f000b6svs8pa2pgpw","_id":"cjezm5y9d000w6svsju7g62id"},{"post_id":"cjezm5y7800086svs60m92sar","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5y9n00106svs7vykre5f"},{"post_id":"cjezm5y8t000q6svsen6k00zo","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5y9q00136svseq5vd7w1"},{"post_id":"cjezm5y99000t6svsm6f5i7rv","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5y9u00166svsrgerbr90"},{"post_id":"cjezm5y5z00006svsubfzlqm9","category_id":"cjezm5y6h00046svsgkggh0d4","_id":"cjezm5y9y001a6svszbryryf8"},{"post_id":"cjezm5y5z00006svsubfzlqm9","category_id":"cjezm5y90000r6svsypfuoepy","_id":"cjezm5ya5001e6svsf7mefmjy"},{"post_id":"cjezm5y9b000v6svsmko2x1f4","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5ya8001i6svsaugexdrs"},{"post_id":"cjezm5y7d000a6svsdainlp2b","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5yap001k6svs1x5r381l"},{"post_id":"cjezm5y9p00126svstzbmta1t","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5yb0001m6svscb3qcasr"},{"post_id":"cjezm5y9s00156svstfntig1c","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5yb2001p6svsxiidr7j5"},{"post_id":"cjezm5y7p000f6svsgt5p6vdk","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5ybl001s6svs0qskmubd"},{"post_id":"cjezm5y9w00196svs4vs7vyhy","category_id":"cjezm5y7f000b6svs8pa2pgpw","_id":"cjezm5ybm001t6svsftq3seg2"},{"post_id":"cjezm5y82000i6svsl7b0250y","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5ybm001u6svspl9528dc"},{"post_id":"cjezm5ya7001h6svsw4czdlee","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5ybn001x6svsvlo3l8e1"},{"post_id":"cjezm5y7200066svsgflhar4a","category_id":"cjezm5y6h00046svsgkggh0d4","_id":"cjezm5ybx001z6svsbkz6zfn8"},{"post_id":"cjezm5y7200066svsgflhar4a","category_id":"cjezm5y90000r6svsypfuoepy","_id":"cjezm5yc200216svs3unhd4n1"},{"post_id":"cjezm5y8b000k6svsz3hvktfo","category_id":"cjezm5y8e000l6svs791mvnui","_id":"cjezm5yc200226svsl3nok0qs"}],"PostTag":[{"post_id":"cjezm5y5z00006svsubfzlqm9","tag_id":"cjezm5y7100056svsiiuu68a7","_id":"cjezm5y7g000d6svs7v0l65md"},{"post_id":"cjezm5y6c00026svsgmwrvc19","tag_id":"cjezm5y7f000c6svs1dw1kwxs","_id":"cjezm5y84000j6svsi5063tat"},{"post_id":"cjezm5y7200066svsgflhar4a","tag_id":"cjezm5y7100056svsiiuu68a7","_id":"cjezm5y8o000p6svsp9pqoh66"},{"post_id":"cjezm5y7800086svs60m92sar","tag_id":"cjezm5y8f000n6svss0jjbv3r","_id":"cjezm5y9b000u6svsjeig1uo2"},{"post_id":"cjezm5y7d000a6svsdainlp2b","tag_id":"cjezm5y90000s6svs7a3yu6et","_id":"cjezm5y9o00116svs6itkbr25"},{"post_id":"cjezm5y9p00126svstzbmta1t","tag_id":"cjezm5y9l000y6svsuprg9gn7","_id":"cjezm5y9v00186svsrbpvj92j"},{"post_id":"cjezm5y7h000e6svsuvuijhho","tag_id":"cjezm5y9l000y6svsuprg9gn7","_id":"cjezm5ya1001b6svseuluvc2w"},{"post_id":"cjezm5y9w00196svs4vs7vyhy","tag_id":"cjezm5y7f000c6svs1dw1kwxs","_id":"cjezm5ya7001g6svs8y8q2vcg"},{"post_id":"cjezm5y7p000f6svsgt5p6vdk","tag_id":"cjezm5y9u00176svs008pdy0s","_id":"cjezm5yb1001n6svsc2989jx5"},{"post_id":"cjezm5y7p000f6svsgt5p6vdk","tag_id":"cjezm5ya6001f6svsklric9y2","_id":"cjezm5yb2001q6svs7p0r1ys1"},{"post_id":"cjezm5y82000i6svsl7b0250y","tag_id":"cjezm5yaq001l6svs4gg0pl71","_id":"cjezm5ybn001w6svsk01rnvfs"},{"post_id":"cjezm5y82000i6svsl7b0250y","tag_id":"cjezm5ybk001r6svsqjl5xkp9","_id":"cjezm5ybo001y6svs4d6cjmxq"},{"post_id":"cjezm5y8b000k6svsz3hvktfo","tag_id":"cjezm5y9u00176svs008pdy0s","_id":"cjezm5yc300246svsbryvwogq"},{"post_id":"cjezm5y8b000k6svsz3hvktfo","tag_id":"cjezm5ya6001f6svsklric9y2","_id":"cjezm5yc400256svsost4j9i1"},{"post_id":"cjezm5y8l000o6svsuyyw85z5","tag_id":"cjezm5yc300236svs1f6jq8vt","_id":"cjezm5yc600276svsepd130st"},{"post_id":"cjezm5y8t000q6svsen6k00zo","tag_id":"cjezm5y9l000y6svsuprg9gn7","_id":"cjezm5yc800296svslmh0uuf3"},{"post_id":"cjezm5y99000t6svsm6f5i7rv","tag_id":"cjezm5yc300236svs1f6jq8vt","_id":"cjezm5yc9002b6svss8mftg23"},{"post_id":"cjezm5y9b000v6svsmko2x1f4","tag_id":"cjezm5yc300236svs1f6jq8vt","_id":"cjezm5ycd002d6svsig7nvrob"},{"post_id":"cjezm5y9l000z6svs84c2tboa","tag_id":"cjezm5y9l000y6svsuprg9gn7","_id":"cjezm5ycf002f6svs82xmxoss"},{"post_id":"cjezm5y9s00156svstfntig1c","tag_id":"cjezm5yce002e6svsvvhd724z","_id":"cjezm5ycf002h6svsqb19z3rm"},{"post_id":"cjezm5ya7001h6svsw4czdlee","tag_id":"cjezm5ycf002g6svsndwnp55c","_id":"cjezm5ycg002i6svsc2m53g31"}],"Tag":[{"name":"study","_id":"cjezm5y7100056svsiiuu68a7"},{"name":"life","_id":"cjezm5y7f000c6svs1dw1kwxs"},{"name":"network","_id":"cjezm5y8f000n6svss0jjbv3r"},{"name":"Database","_id":"cjezm5y90000s6svs7a3yu6et"},{"name":"ML","_id":"cjezm5y9l000y6svsuprg9gn7"},{"name":"JS","_id":"cjezm5y9u00176svs008pdy0s"},{"name":"FP","_id":"cjezm5ya6001f6svsklric9y2"},{"name":"数据可视化","_id":"cjezm5yaq001l6svs4gg0pl71"},{"name":"论文阅读","_id":"cjezm5ybk001r6svsqjl5xkp9"},{"name":"summary","_id":"cjezm5yc300236svs1f6jq8vt"},{"name":"web","_id":"cjezm5yce002e6svsvvhd724z"},{"name":"系统结构","_id":"cjezm5ycf002g6svsndwnp55c"}]}}